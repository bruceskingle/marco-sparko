# A charge to the customer.
type Charge implements TransactionType {
  id: ID
  postedDate: Date

  # The date time when the transaction is created.
  createdAt: DateTime

  # Unique identifier of the account the transaction belongs to.
  accountNumber: String

  # Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  amount: Int
    @deprecated(
      reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01."
    )

  # The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  amounts: TransactionAmountType

  # The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  balanceCarriedForward: Int

  # Deprecated.
  isCredit: Boolean
    @deprecated(
      reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Deprecated.
  isAccountCharge: Boolean
    @deprecated(
      reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Deprecated.
  isAccountPayment: Boolean
    @deprecated(
      reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  isHeld: Boolean

  # Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  isIssued: Boolean
  title: String

  # The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  billingDocumentIdentifier: ID

  # Returns None if a statement is not linked with the transaction.
  statementId: ID
    @deprecated(
      reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01."
    )
  isReversed: Boolean!

  # Returns True if the transaction is linked with a statement.
  hasStatement: Boolean

  # Returns the note field value for the transaction, which contains additional info.
  note: String

  # If this charge is for consumption of a good or service, this field will contain details of how much was consumed. Omitted in cases where the charge is not for consumption, or where consumption information is not available (e.g. for some older records).
  consumption: Consumption

  # Whether the charge is for export electricity.
  isExport: Boolean
}

# An enumeration.
enum ConsumptionUnit {
  kWh
  MJ
}

type StatementType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  # Requesting this field generates a temporary URL at which bill is available.
  #         This URL will expire after approximately an hour.  It is intended for redirection purposes,
  #         NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  #         This field can raise an error with errorClass NOT_FOUND if the bill document has not
  #         been created/issued yet.
  #
  #
  #
  temporaryUrl: String

  # The date the bill was sent to the customer.
  issuedDate: Date

  # This field returns the closing balance of an issued statement.
  closingBalance: Int

  # This field returns the opening balance of a statement.
  openingBalance: Int

  # Whether the bill originated in Kraken or externally.
  isExternalBill: Boolean

  # Transactions on the bill.
  transactions(
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection

  # Email recipient user ID.
  userId: Int

  # Email recipient address.
  toAddress: String

  # The date the bill is due to be paid.
  paymentDueDate: Date

  # The first day of consumption that this statement includes.
  consumptionStartDate: Date

  # The last day of consumption that this statement includes.
  consumptionEndDate: Date

  # How many charges have been reversed after the close date.
  reversalsAfterClose: StatementReversalsAfterClose!

  # Current status of the associated statement.
  status: AccountStatementStatus

  # Retrieve the held status of a account statement.
  heldStatus: HeldStatus

  # The total amounts for all charges on the statement.
  totalCharges: StatementTotalType

  # The total amounts for all credits on the statement.
  totalCredits: StatementTotalType
}

# An enumeration.
enum StatementReversalsAfterClose {
  # All charges have been reversed after the statement was closed.
  ALL

  # Some charges have been reversed after the statement was closed.
  SOME

  # No reversals after the statement was closed.
  NONE

  # The statement has not been closed yet.
  NOT_CLOSED
}

# An enumeration.
enum AccountStatementStatus {
  OPEN
  CLOSED
}

type HeldStatus {
  # Whether a statement is currently held.
  isHeld: Boolean

  # Reason for statement being held.
  reason: String
}

type StatementTotalType {
  # The net total amount for the statement (in minor currency units).
  netTotal: Int

  # The total amount of tax on the statement (in minor currency units).
  taxTotal: Int

  # The gross total amount for the statement (in minor currency units).
  grossTotal: Int
}

type PreKrakenBillType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  # Requesting this field generates a temporary URL at which bill is available.
  #         This URL will expire after approximately an hour.  It is intended for redirection purposes,
  #         NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  #         This field can raise an error with errorClass NOT_FOUND if the bill document has not
  #         been created/issued yet.
  #
  #
  #
  temporaryUrl: String

  # The date the bill was sent to the customer.
  issuedDate: Date

  # The params associated with the historical bill.
  params: JSONString
}

type PeriodBasedDocumentType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  # Requesting this field generates a temporary URL at which bill is available.
  #         This URL will expire after approximately an hour.  It is intended for redirection purposes,
  #         NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  #         This field can raise an error with errorClass NOT_FOUND if the bill document has not
  #         been created/issued yet.
  #
  #
  #
  temporaryUrl: String

  # The date the bill was sent to the customer.
  issuedDate: Date

  #
  # The unique identifier for the billing document. Note: a pending billing document will not have an identifier yet;
  # and not all finalized billing documents will have an identifier assigned to them, in which case this will be null.
  #
  identifier: ID

  # The total amounts for all charges on the billing document.
  totalCharges: StatementTotalType

  # The total amounts for all credits on the statement.
  totalCredits: StatementTotalType
}

type InvoiceType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  # Requesting this field generates a temporary URL at which bill is available.
  #         This URL will expire after approximately an hour.  It is intended for redirection purposes,
  #         NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  #         This field can raise an error with errorClass NOT_FOUND if the bill document has not
  #         been created/issued yet.
  #
  #
  #
  temporaryUrl: String

  # The date the bill was sent to the customer.
  issuedDate: Date

  # This field returns the total gross amount of the bill in pence.
  grossAmount: Int
}

# A payment from the customer to the energy supplier.
type Payment implements TransactionType {
  id: ID
  postedDate: Date

  # The date time when the transaction is created.
  createdAt: DateTime

  # Unique identifier of the account the transaction belongs to.
  accountNumber: String

  # Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  amount: Int
    @deprecated(
      reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01."
    )

  # The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  amounts: TransactionAmountType

  # The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  balanceCarriedForward: Int

  # Deprecated.
  isCredit: Boolean
    @deprecated(
      reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Deprecated.
  isAccountCharge: Boolean
    @deprecated(
      reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Deprecated.
  isAccountPayment: Boolean
    @deprecated(
      reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  isHeld: Boolean

  # Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  isIssued: Boolean
  title: String

  # The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  billingDocumentIdentifier: ID

  # Returns None if a statement is not linked with the transaction.
  statementId: ID
    @deprecated(
      reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01."
    )
  isReversed: Boolean!

  # Returns True if the transaction is linked with a statement.
  hasStatement: Boolean

  # Returns the note field value for the transaction, which contains additional info.
  note: String
}

# A refund to the customer from the energy supplier.
type Refund implements TransactionType {
  id: ID
  postedDate: Date

  # The date time when the transaction is created.
  createdAt: DateTime

  # Unique identifier of the account the transaction belongs to.
  accountNumber: String

  # Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  amount: Int
    @deprecated(
      reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01."
    )

  # The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  amounts: TransactionAmountType

  # The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  balanceCarriedForward: Int

  # Deprecated.
  isCredit: Boolean
    @deprecated(
      reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Deprecated.
  isAccountCharge: Boolean
    @deprecated(
      reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Deprecated.
  isAccountPayment: Boolean
    @deprecated(
      reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  isHeld: Boolean

  # Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  isIssued: Boolean
  title: String

  # The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  billingDocumentIdentifier: ID

  # Returns None if a statement is not linked with the transaction.
  statementId: ID
    @deprecated(
      reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01."
    )
  isReversed: Boolean!

  # Returns True if the transaction is linked with a statement.
  hasStatement: Boolean

  # Returns the note field value for the transaction, which contains additional info.
  note: String
}

type Consumption {
  startDate: Date
  endDate: Date
  quantity: Decimal
  unit: ConsumptionUnit
  usageCost: Int
  supplyCharge: Int
}

# The metadata input type for mutations.
input MetadataInput {
  # An identifier for the associated object, e.g. account_number for the Account linked object type.
  identifier: String!

  # The object that the metadata is associated with.
  linkedObjectType: LinkedObjectType!

  # The key for the metadata.
  key: String!

  # The metadata value which should be a valid JSON string.
  value: JSONString!
}

enum LinkedObjectType {
  ACCOUNT
  ACCOUNT_USER
}

# A Loyalty Point ledger entry.
type LoyaltyPointLedgerEntryType {
  id: ID!

  # The `LedgerEntryType`. Either CHARGE or CREDIT.
  ledgerType: String

  # The value of the charge or credit.
  value: String

  # Equal to the `balance_carried_forward` from the previous ledger entry or zero if this is the first one.
  balanceBroughtForward: String

  # Equal to the `balance_brought_forward` plus or minus the value depending on the ledger_type.
  balanceCarriedForward: String

  # The reason the entry was being added.
  reasonCode: String

  # The date the points were added to the ledger.
  postedAt: DateTime

  # The account number associated with the entry.
  accountNumber: String
}

type InkConversation {
  id: ID!

  # The status of the conversation.
  status: InkConversationStatus!

  # The contact channel identities associated with this conversation.
  contactChannelIdentities: InkContactChannelIdentities!

  # The account users on the conversation.
  accountUsers: [AccountUserType!]

  # Conversation events.
  events(
    before: String
    after: String
    first: Int
    last: Int
  ): InkConversationEventsConnection!

  # The buckets the conversation is currently in.
  buckets: [InkBucket!]
}

enum InkConversationStatus {
  OPEN
  OPEN_NEW
  OPEN_CUSTOMER_REPLIED
  OPEN_REMINDED
  SNOOZED
  CLOSED
}

type InkContactChannelIdentities {
  # The default contact for this conversation.
  default: InkContactChannelIdentity

  # All contacts for this conversation.
  all: [InkContactChannelIdentity!]!
}

type InkContactChannelIdentity {
  # The channel of the contact.
  channel: InkCommunicationChannel!

  # The handle.
  handle: String!

  # The name to display to the user.
  displayName: String!
}

# An enumeration.
enum InkCommunicationChannel {
  EMAIL
  SMS
  POST
  GENERIC_API
  WHATSAPP
}

type InkConversationEventsConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [InkConversationEventsEdge!]!
}

# A Relay edge containing a `InkConversationEvents` and its cursor.
type InkConversationEventsEdge {
  # The item at the end of the edge
  node: InkConversationEvent!

  # A cursor for use in pagination
  cursor: String!
}

union InkConversationEvent = InkNewMessage

# This types is used for both the message-received and message-sent conversation events.
type InkNewMessage implements InkConversationEventInterface {
  # The time the conversation event occurred.
  occurredAt: DateTime!

  # The message.
  message: InkMessage!
}

interface InkConversationEventInterface {
  # The time the conversation event occurred.
  occurredAt: DateTime!
}

union InkMessage =
    InkEmail
  | InkSMS
  | InkLine
  | InkWhatsApp
  | InkPost
  | InkGenericMessage

# This type wraps around the `Message` type for emails.
type InkEmail {
  # The direction of the email.
  direction: InkMessageDirection!

  # The addresses that the message was sent to.
  toHandles: [String!]

  # From email address.
  fromHandle: String!

  # The delivery status of the message.
  delivery: InkMessageDelivery!

  # The contact channel identity.
  contactChannelIdentity: InkContactChannelIdentity!

  # The time the message was sent/received.
  occurredAt: DateTime!

  # The email subject.
  subject: String!

  # The content of the message.
  displayContent: String!

  # Attachments on the message.
  attachments: [InkMessageAttachment!]!

  # CC recipients on the message.
  cc: [String!]!

  # Is this an message an email.
  isChannelEmail: Boolean!

  # All Tags associated with a message.
  tags: [InkTag!]!
}

enum InkMessageDirection {
  INBOUND
  OUTBOUND
}

type InkMessageDelivery {
  # Message delivery status.
  status: InkMessageDeliveryStatus!
}

enum InkMessageDeliveryStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  OUTSIDE_REPLY_WINDOW
}

type InkMessageAttachment {
  # The filename.
  filename: String!

  # The url for fetching the attachment.
  fetchUrl: String

  # The size in bytes.
  sizeInBytes: Int
}

type InkTag implements Node {
  # The ID of the object
  id: ID!

  # Tag for a message.
  name: String!
}

# This type wraps around the `Message` type for SMS.
type InkSMS {
  # The direction of the message.
  direction: InkMessageDirection!

  # The phone number the message was sent from.
  fromHandle: String!

  # The phone number the message was sent to.
  toHandle: String!

  # The delivery status.
  delivery: InkMessageDelivery!

  # The contact channel identity.
  contactChannelIdentity: InkContactChannelIdentity!

  # The time the message was sent/received at.
  occurredAt: DateTime!

  # The content of the message.
  displayContent: String!

  # Is this an SMS message.
  isChannelSms: Boolean!

  # All Tags associated with a message.
  tags: [InkTag!]!
}

# This type wraps around the `Message` type for LINE message.
type InkLine {
  # The direction of the message.
  direction: InkMessageDirection!

  # From LINE id.
  fromHandle: String!

  # To LINE id.
  toHandle: String!

  # The delivery status of the message.
  delivery: InkMessageDelivery!

  # The contact channel identity.
  contactChannelIdentity: InkContactChannelIdentity!

  # The time the message was sent/received.
  occurredAt: DateTime!

  # The line message content.
  lineMessage: LineMessage!

  # Is this a LINE message.
  isChannelLine: Boolean!

  # Attachments on the LINE message.
  attachments: [InkMessageAttachment!]!

  # All Tags associated with a message.
  tags: [InkTag!]!
}

union LineMessage = LineTextMessage | LineStickerMessage | LineImageMessage

type LineTextMessage {
  # The display content.
  displayContent: String!

  # The emojis in the message.
  emojis: [LineEmoji!]
}

# A LINE specific emoji object.
# refs: https://developers.line.biz/en/reference/messaging-api/#text-message
type LineEmoji {
  # The location of the emoji in the message.
  index: Int!

  # The length of the emoji string placeholder.
  length: Int

  # The product id.
  productId: String!

  # The emoji id.
  emojiId: String!
}

type LineStickerMessage {
  # Sticker package id.
  packageId: String!

  # Sticker id.
  stickerId: String!

  # Sticker resource type.
  resourceType: String!

  # Keywords describing the sticker.
  keywords: [String!]!

  # Text used to customize some stickers.
  text: String!
}

type LineImageMessage {
  id: ID!
}

# This type wraps around the `Message` type for WhatsApp message.
type InkWhatsApp {
  # The direction of the message.
  direction: InkMessageDirection!

  # From WhatsApp phone number.
  fromHandle: String!

  # Whatsapp contact phone number.
  toHandle: String!

  # Whatsapp message delivery status.
  delivery: InkMessageDelivery!

  # Whatsapp message contact channel identity.
  contactChannelIdentity: InkContactChannelIdentity!

  # Date when the conversation event was created.
  occurredAt: DateTime!

  # The vendor id.
  vendorId: String

  # Whatsapp message content.
  whatsappContent: WhatsAppTextMessage!

  # Whether or not the message is a whatsapp message.
  isChannelWhatsapp: Boolean!

  # All Tags associated with a message.
  tags: [InkTag!]!
}

type WhatsAppTextMessage {
  # Whatsapp text message body.
  body: String!
}

# This type wraps around the `Message` type for Post.
type InkPost {
  # The from property id.
  fromHandle: String!

  # The to property id.
  toHandle: String!

  # The notes left when a message was uploaded.
  displayContent: String!

  # The content of the message.
  rawPlainTextContent: String!

  # Determine if the message is a post message.
  isChannelPost: Boolean!

  # The contact channel identity.
  contactChannelIdentity: InkContactChannelIdentity!
}

# This message type is used for messages that belong to contact
# channels without a more granular message type.
type InkGenericMessage implements Node {
  # The ID of the object
  id: ID!

  # The direction of the message.
  direction: InkMessageDirection!

  # The identity the message was sent from.
  fromHandle: String!

  # The identity the message was sent to.
  toHandle: String!

  # The delivery status.
  delivery: InkMessageDelivery!

  # The contact channel identity.
  contactChannelIdentity: InkContactChannelIdentity!

  # The time the message was sent/received at.
  occurredAt: DateTime!

  # The content of the message.
  displayContent: String!
}

type InkBucket implements Node {
  # The ID of the object
  id: ID!

  # The ink bucket name.
  name: String!

  # The icon code point.
  icon: String
}

# A loyalty card.
type LoyaltyCardType {
  id: ID!

  # The scheme of the loyalty card.
  scheme: String

  # The number of the loyalty card.
  number: String

  # The status of the loyalty card.
  status: String
}

# Represents print batch details
type PrintBatchType {
  id: ID!

  # The status of the print batch.
  status: PrintBatchStatus

  # Messages in a print batch.
  messages(
    # Whether to filter to include or exclude high priority messages. If not supplied, no filtering will be performed.
    isHighPriority: Boolean = null
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): PrintMessageTypeConnection
}

# An enumeration.
enum PrintBatchStatus {
  OPEN
  CLOSED
  PROCESSED
}

type PrintMessageTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [PrintMessageTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `PrintMessageType` and its cursor.
type PrintMessageTypeEdge {
  # The item at the end of the edge
  node: PrintMessageType

  # A cursor for use in pagination
  cursor: String!
}

# Information about what version of Kraken is being executed by this service.
type KrakenVersionType {
  # The version number that is being executed.
  number: String

  # The git commit SHA that is being executed.
  SHA: String
}

type TermsAndConditionsType {
  name: String
  pdfUrl: String
  brandCode: String

  # The markdown text of the terms and conditions.
  markdown: String

  # The html of the terms and conditions document rendered as a JSON string.
  html: String
  version: String
  effectiveFrom: DateTime
}

type RateLimitInformation {
  # The maximum number of points the viewer gets for requests per hour.
  limit: Int

  # The remaining points for the viewer in one hour time limit.
  remainingPoints: Int

  # The points used so far in one hour time limit.
  usedPoints: Int
}

type CombinedRateLimitInformation {
  # Information about points-allowance rate limit for viewer.
  pointsAllowanceRateLimit: PointsAllowanceRateLimitInformation
}

type PointsAllowanceRateLimitInformation {
  # The maximum number of points the viewer gets for requests per hour.
  limit: Int

  # The remaining points for the viewer in one hour time limit.
  remainingPoints: Int

  # The points used so far in one hour time limit.
  usedPoints: Int

  # Time To Live: UNIX timestamp when the viewer will get a new allowance of points.
  ttl: Int

  # Whether the viewer has been blocked due to spending all its allowed points.
  isBlocked: Boolean
}

type QueryComplexityOutputType {
  # The complexity of the query.
  complexityValue: Int
}

# Information about the complexity of the query.
input QueryComplexityInputType {
  # The query to calculate complexity for.
  query: String!

  # Any variables to include for the query. Pagination variables should be included as they will affect the overall weight of the query.
  variables: JSONString

  # The operation name of the query to calculate complexity for if more than one is provided.
  operationName: String
}

type DepositAgreementOutput {
  depositKey: String
  depositAmount: Int
  acceptedAt: DateTime
  fulfilledAt: DateTime
}

# An enumeration.
enum PaymentType {
  BPAY
  CARD
  DIRECT_DEBIT
  GMO_REFUND
  PAYMENT_SLIP
}

# A key-value pair (both Strings) which is passed in parameters to a backend action.
input BackendScreenParamInputType {
  key: String!
  value: String!
}

# Represents a Leave Supplier process. Conceptually, it contains information related to supply points that are associated with a Leave Supplier journey.
type LeaveSupplierProcessType implements AbstractSupplyPointProcessInterface {
  # The ID or the primary key of the lifecycle process.
  id: ID

  # The status of the process.
  status: LeaveSupplierProcessStatus

  # The supply points associated with the process.
  supplyPoints(
    before: String
    after: String
    first: Int
    last: Int
  ): SupplyPointConnectionTypeConnection!
}

# Interface for all lifecycle journey processes that
# inherit from AbstractSupplyPointProcess.
interface AbstractSupplyPointProcessInterface {
  # The ID or the primary key of the lifecycle process.
  id: ID

  # The status of the process.
  status: LeaveSupplierProcessStatus

  # The supply points associated with the process.
  supplyPoints(
    before: String
    after: String
    first: Int
    last: Int
  ): SupplyPointConnectionTypeConnection!
}

# The status of the LeaveSupplier process.
enum LeaveSupplierProcessStatus {
  COMPLETED
  PARTIALLY_COMPLETED
  PENDING
  IN_PROGRESS
  STALLED
  CANCELLED
  PARTIALLY_CANCELLED
  REVERSE_IN_PROGRESS
  REVERSED
  PARTIALLY_REVERSED
  FAILED
  ERRORED
}

type SupplyPointConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [SupplyPointConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `SupplyPointConnectionType` and its cursor.
type SupplyPointConnectionTypeEdge {
  # The item at the end of the edge
  node: SupplyPointType

  # A cursor for use in pagination
  cursor: String!
}

# Represents a SupplyPoint.
type SupplyPointType implements CommonSupplyPointInterface {
  # The ID of the supply point.
  id: ID!

  # The market this supply point belongs to.
  marketName: String!

  # The external identifier of the supply point.
  externalIdentifier: String
}

interface CommonSupplyPointInterface {
  # The ID of the supply point.
  id: ID!

  # The market this supply point belongs to.
  marketName: String!

  # The external identifier of the supply point.
  externalIdentifier: String
}

type LifecycleProcessesType {
  # List of LeaveSupplierProcess for an account.
  leaveSupplierProcesses(
    before: String
    after: String
    first: Int
    last: Int
  ): LeaveSupplierProcessConnectionTypeConnection

  # List of JoinSupplierProcess for an account.
  joinSupplierProcesses(
    before: String
    after: String
    first: Int
    last: Int
  ): JoinSupplierProcessConnectionTypeConnection

  # List of OccupyPropertyProcess for an account.
  occupyPropertyProcesses(
    before: String
    after: String
    first: Int
    last: Int
  ): OccupyPropertyProcessConnectionTypeConnection

  # List of LeavePropertyProcess for an account.
  leavePropertyProcesses(
    before: String
    after: String
    first: Int
    last: Int
  ): LeavePropertyProcessConnectionTypeConnection
}

type LeaveSupplierProcessConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [LeaveSupplierProcessConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `LeaveSupplierProcessConnectionType` and its cursor.
type LeaveSupplierProcessConnectionTypeEdge {
  # The item at the end of the edge
  node: LeaveSupplierProcessType

  # A cursor for use in pagination
  cursor: String!
}

type JoinSupplierProcessConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [JoinSupplierProcessConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `JoinSupplierProcessConnectionType` and its cursor.
type JoinSupplierProcessConnectionTypeEdge {
  # The item at the end of the edge
  node: JoinSupplierProcessType

  # A cursor for use in pagination
  cursor: String!
}

# Represents a Join Supplier process.
type JoinSupplierProcessType implements AbstractSupplyPointProcessInterface {
  # The ID or the primary key of the lifecycle process.
  id: ID

  # The status of the process.
  status: LeaveSupplierProcessStatus

  # The supply points associated with the process.
  supplyPoints(
    before: String
    after: String
    first: Int
    last: Int
  ): SupplyPointConnectionTypeConnection!
}

type OccupyPropertyProcessConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [OccupyPropertyProcessConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `OccupyPropertyProcessConnectionType` and its cursor.
type OccupyPropertyProcessConnectionTypeEdge {
  # The item at the end of the edge
  node: OccupyPropertyProcessType

  # A cursor for use in pagination
  cursor: String!
}

# Represents a Occupy Property process.
type OccupyPropertyProcessType implements AbstractSupplyPointProcessInterface {
  # The ID or the primary key of the lifecycle process.
  id: ID

  # The status of the process.
  status: LeaveSupplierProcessStatus
  occupyAt: DateTime!

  # The supply points associated with the process.
  supplyPoints(
    before: String
    after: String
    first: Int
    last: Int
  ): SupplyPointConnectionTypeConnection!
}

type LeavePropertyProcessConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [LeavePropertyProcessConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `LeavePropertyProcessConnectionType` and its cursor.
type LeavePropertyProcessConnectionTypeEdge {
  # The item at the end of the edge
  node: LeavePropertyProcessType

  # A cursor for use in pagination
  cursor: String!
}

# Represents a Leave Property process.
type LeavePropertyProcessType implements AbstractSupplyPointProcessInterface {
  # The ID or the primary key of the lifecycle process.
  id: ID

  # The status of the process.
  status: LeaveSupplierProcessStatus

  # The supply points associated with the process.
  supplyPoints(
    before: String
    after: String
    first: Int
    last: Int
  ): SupplyPointConnectionTypeConnection!
}

type GoodsQuote {
  # ID of the quote.
  id: Int

  # Code of the quote.
  code: String

  # Total net amount of the quote in cents.
  totalNetAmount: Int

  # Date and time when the quote was created.
  quotedAt: DateTime

  # Products of this quote.
  goodsQuotedProducts: [GoodsQuotedProduct]

  # Indicates whether or not the quote is expired.
  hasQuoteExpired: Boolean
}

type GoodsProductConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [GoodsProductConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `GoodsProductConnectionType` and its cursor.
type GoodsProductConnectionTypeEdge {
  # The item at the end of the edge
  node: GoodsProduct

  # A cursor for use in pagination
  cursor: String!
}

type GoodsProduct {
  # Product ID.
  id: Int

  # Market of the product.
  marketName: String

  # Type of the product.
  productType: GoodsProductType

  # Product code.
  code: String

  # Product internal name.
  internalName: String

  # Product customer name.
  customerName: String

  # Product notes.
  notes: String

  # Product description.
  description: String

  # Product available from.
  availableFrom: Date

  # Product available to.
  availableTo: Date

  # Price per unit.
  pricePerUnit: Float

  # Gross price per unit.
  grossPricePerUnit: Float

  # Currency.
  currency: String
}

type GoodsProductType {
  # Product type code.
  code: String

  # Product type name.
  internalName: String
}

type GoodsPurchase {
  # Purchase code.
  code: String

  # Ledger ID associated to the purchase.
  ledgerId: String

  # Sale items in this purchase.
  goodsSaleItems: [GoodsSaleItem]

  # Grants that apply in this purchase.
  goodsGrants: [GoodsGrant]

  # Market parameters of the purchase.
  marketParams: JSONString

  # Client parameters of the purchase.
  clientParams: JSONString
}

type GoodsSaleItem {
  # Product code.
  product: String

  # Number of units.
  numberOfUnits: Int

  # Price per unit.
  pricePerUnit: Float

  # Net amount.
  netAmount: Float

  # Gross amount.
  grossAmount: Float

  # Currency.
  currency: String
}

type GoodsGrant {
  # Grant type.
  type: String

  # Net amount.
  netAmount: Float

  # Gross amount.
  grossAmount: Float

  # Currency.
  currency: String
}

# Energy mix data can include the latest carbon intensity index in a region.
type EnergyMixDataType {
  # Current carbon intensity index.
  carbonIntensityIndex: String
}

# Paginator of API exceptions.
type APIExceptionConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [APIExceptionConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `APIExceptionConnectionType` and its cursor.
type APIExceptionConnectionTypeEdge {
  # The item at the end of the edge
  node: APIExceptionType

  # A cursor for use in pagination
  cursor: String!
}

type APIExceptionType {
  id: ID!

  # External identifier submitted by the API client to track this exception on their end.
  externalIdentifier: String!
  createdAt: DateTime!

  # Free field for the API caller to categorise a channel. This could be (but not limited to) the client's team that calleded the API, the name of the 'flow' the call belongs to, etc.
  channel: String!

  # Category associated with this exception.
  category: APIExceptionCategories

  # The account number provided to the exception.
  accountNumber: String

  # The user id provided to the exception.
  userId: Int

  # The customer contact provided to the exception.
  customerContact: String

  # The supply point identifier provided to the exception.
  supplyPointIdentifier: String

  # The current resolution status for the API exception.
  resolutionStatus: APIExceptionResolutionStatus!

  # The current resolution type for the API exception.
  resolutionType: APIExceptionResolutionType!

  # The current priority for the API exception.
  priority: APIExceptionPriority!

  # The API calls associated with this exception if any.
  apiCalls: [APICallType]

  # The events associated with this exception if any.
  events: [APIExceptionEventType]

  # Tags associated with this exception if any.
  tags: [APIExceptionTags]

  # Notes associated with this exception if any.
  notes: [APIExceptionNoteType]

  # The operations team assigned to this exception if any.
  operationsTeam: OperationsTeamType

  # Storage for the API client to submit any contextual information.
  context: JSONString

  # The key date associated with the exception, if available.
  keyDate: Date

  # The user assigned to handle this exception if any.
  assignedUser: AssignedUserType
}

# An enumeration.
enum APIExceptionCategories {
  UNKNOWN
  ACCOUNT
}

# An enumeration.
enum APIExceptionResolutionStatus {
  ASSIGNED
  CANCELLED
  IN_PROGRESS
  RESOLVED
  UNASSIGNED
  UNSUCCESSFUL
  WAITING_ON_THIRD_PARTY
}

# An enumeration.
enum APIExceptionResolutionType {
  AUTOMATIC
  MANUAL
  UNASSIGNED
}

# An enumeration.
enum APIExceptionPriority {
  LOW
  MEDIUM
  HIGH
}

type APICallType {
  id: ID!

  # The request's correlation id.
  correlationId: String!

  # Free field for the API caller to categorise their own operation name. This field can be used to filter entries on the UI.
  operationName: String!

  # Input data for the API call if any.
  inputData: JSONString

  # The response from the API call if any.
  response: JSONString

  # Storage for the API client to submit any contextual information.
  context: JSONString
  createdAt: DateTime!
}

type APIExceptionEventType {
  id: ID!

  # The type of the event.
  eventType: String!

  # The category of the event.
  category: String!

  # A description of the event.
  description: String

  # A JSON context to be provided with the event, if any.
  context: JSONString
  createdAt: DateTime!
}

# An enumeration.
enum APIExceptionTags {
  MOVE_IN
  MOVE_OUT
  PRODUCT_UPDATE
}

type APIExceptionNoteType {
  # The ID of the API Exception note.
  id: ID!

  # The content of the API Exception note.
  body: String!

  # Timestamp of when the API Exception note was created.
  createdAt: DateTime!
}

type AssignedUserType {
  # The ID of the assigned user.
  id: ID!

  # The username of the assigned user.
  username: String!
}

input APIExceptionQueryInput {
  # The external identifier to filter for.
  externalIdentifier: String

  # The resolution status to filter for.
  resolutionStatus: APIExceptionResolutionStatus = null

  # The resolution type to filter for.
  resolutionType: APIExceptionResolutionType = null

  # The channel to filter for.
  channel: String

  # The priority to filter for.
  priority: APIExceptionPriority = null

  # Tags to filter for.
  tags: [APIExceptionTags]

  # The category to filter for.
  category: APIExceptionCategories = null

  # The account number to filter for.
  accountNumber: ID

  # The user ID to filter for.
  userId: ID

  # The customer contact to filter for.
  customerContact: String

  # The supply point identifier to filter for.
  supplyPointIdentifier: ID
}

type CreditReasonType {
  # The credit reason code.
  code: String

  # The credit reason display text.
  display: String

  # Whether the credit reason is deprecated.
  isDeprecated: Boolean

  # Whether the credit reason is sales tax exempt.
  isTaxExempt: Boolean

  # Whether the credit reason is hidden.
  isHidden: Boolean

  # The group the credit reason belongs to (if applicable).
  group: String
}

type ChargeReasonType {
  # The charge reason code.
  code: String

  # The charge reason display text.
  display: String

  # Whether the charge reason is deprecated.
  isDeprecated: Boolean

  # Whether the charge reason is sales tax exempt.
  isTaxExempt: Boolean

  # Whether the charge reason is hidden.
  isHidden: Boolean

  # The group the charge reason belongs to (if applicable).
  group: String
}

# The account object can be one of several attached to a `Portfolio` (which usually has an `AccountUser` which is used to authenticate access to the `Portfolio`'s accounts). Typically a person has a single account attached to a portfolio and properties on the same account will appear on the same bill. Where separate bills are desired, multiple accounts  are created and added to the same portfolio of accounts.
type AccountType implements AccountInterface {
  id: ID!

  # A code that uniquely identifies the account.
  number: String

  # The current status of the account.
  status: AccountStatus

  # The schedules that describe how we would expect to take payments for an account on a given month.
  paymentSchedules(
    activeOnDate: Date
    active: Boolean

    # If false, we remove the currently valid schedule if it has already fulfilled its purpose and will have no further impact on customer payments, along with any schedules which are not valid from today.
    includeDormant: Boolean = true

    # The ledger to return transactions from.
    ledgerType: Int

    # The ledger id to return the payment schedules from.
    ledgerId: ID
    reason: PaymentScheduleReasonOptions
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentScheduleConnectionTypeConnection
  users: [AccountUserType!]!

  # The brand of the account.
  brand: String

  # The current account balance.
  balance(
    # If this variable is set to true, the balance will be calculated based on the sum of balances on all ledgers configured to contribute to this account's balance. Otherwise, only the main ledger's balance will be fetched (legacy behaviour). If you are unsure, set this value to true.
    includeAllLedgers: Boolean = false
  ): Int!

  # The current account overdue balance.
  overdueBalance: Int

  # Unique reference number from a 3rd party enrolment.
  urn: String

  # The billing name of the account.
  billingName: String

  # The billing sub name of the account.
  billingSubName: String

  # The billing email of the account.
  billingEmail: String

  # The billing address of the account.
  billingAddress: String
  billingAddressLine1: String
  billingAddressLine2: String
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingAddressPostcode: String
  billingCountryCode: String
  billingDeliveryPointIdentifier: String

  # List of billing address lines.
  splitBillingAddress: [String]

  #
  # The billing address of this account, stored in the new
  # libaddressinput-based format.
  #
  # Note that `name` and `organization` are very unlikely to be
  # supplied here; the `billing_name` field on the account
  # itself is generally used for that purpose instead.
  #
  address: RichAddressType

  # The portfolio this account is linked to.
  portfolio: PortfolioType

  # Ledgers provide the foundation of bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular customer account.
  ledgers(
    # The ledger to return
    ledgerId: ID

    # The ledger to return by its number
    ledgerNumber: String
  ): [LedgerType]

  # Metadata associated with the account.
  metadata: [Metadata]

  # Whether the account can request a credit refund.
  canRequestRefund: Boolean

  # Details about the eligibility status for requesting a refund.
  requestRefundEligibility: RequestRefundEligibilityType

  # The payments made into an account from a payment instruction.
  payments(
    # **WARNING: Will be mandatory in future versions**
    #
    # The ledger to return payments from.
    ledgerId: String
    status: AccountPaymentStatusOptions

    # Filter for payments that were taken for a particular reason.
    reason: PaymentReasonOptions

    # Whether to include payment promises (of any kind: made, broken or fulfilled) or not. The default is to include them.
    includePromises: Boolean = true
    before: String
    after: String
    first: Int
    last: Int
  ): AccountPaymentConnectionTypeConnection

  # The repayments that have been requested for this account.
  repayments(
    # Only return repayments whose status matches one of these statuses
    statuses: [AccountRepaymentStatusOptions]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountRepaymentConnectionTypeConnection

  # A list displaying the payment forecast for an account. The list starts from today's date (inclusive).
  paymentForecast(
    # The end date to retrieve forecasts for. This end date is inclusive.
    dateTo: Date!

    # The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    ledgerId: Int
  ): [PaymentForecastType]
    @deprecated(
      reason: "The 'paymentForecast' field is deprecated.\n\nPlease use 'paginatedPaymentForecast' instead.\n\n- Marked as deprecated on 2024-01-03.\n- Will be removed on 2025-01-01."
    )

  # Paginated payment forecasts for an account. Starts from today's date (inclusive). The interface supports `last` but does not guarantee 'lastness'.
  paginatedPaymentForecast(
    # The end date to retrieve forecasts for. This end date is inclusive.
    dateTo: Date

    # The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    ledgerId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentForecastConnectionTypeConnection

  # The referrals created by this account.
  referrals(
    before: String
    after: String
    first: Int
    last: Int
  ): ReferralConnectionTypeConnection

  # Number of referrals created by this account.
  referralsCreated: Int

  # The rewards applied to this account.
  rewards: [RewardType]

  # The referral schemes currently active for this account.
  activeReferralSchemes: ReferralSchemeTypes

  # Fetch transactions that have taken place on the account.
  transactions(
    # Include only these specific transaction types in the result.
    transactionTypes: [TransactionTypeFilter] = []

    # Exclude these specific transaction types from the result.
    transactionTypesExcluded: [TransactionTypeFilter] = []

    # The ledger to return transactions from.
    ledgerId: Int

    # In a multi-ledger scenario, include all ledgers' transactions if `true`. Analogously, if `false` and no `ledgerId` argument is present, the list of transactions defaults to the main ledger (legacy behaviour).
    includeAllLedgers: Boolean

    #
    # Optional date representing the beginning of the postedDate range filter.
    # This date value is inclusive.
    #
    fromDate: Date

    #
    # Optional date representing the end of the postedDate range filter.
    # This date value is exclusive.
    #
    toDate: Date

    # The order in which to return the transactions.
    orderBy: TransactionsOrderBy = POSTED_DATE_DESC
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection
  provisionalTransactions(
    before: String
    after: String
    first: Int
    last: Int
  ): ProvisionalTransactionConnectionTypeConnection

  # Fetch annual statements for the account.
  annualStatements(
    before: String
    after: String
    first: Int
    last: Int
  ): AnnualStatementConnectionTypeConnection

  # Fetch issued bills (invoices/statements) for the account.
  bills(
    # Include bills without PDFs.
    includeBillsWithoutPDF: Boolean = false

    #
    # Include open statements. This flag needs to be used along with
    # includeBillsWithoutPDF=false otherwise results will prove unexpected.
    #
    includeOpenStatements: Boolean = false

    # Include held statements within the results.
    includeHeldStatements: Boolean = false

    # Include pre-Kraken / historical statements within the results.
    includeHistoricStatements: Boolean = true

    # Only include bills emailed to the current user's email.
    onlyCurrentEmail: Boolean = false

    # Optional date representing the beginning of the search results. This date value is inclusive.
    fromDate: Date

    # Optional date representing the end of the search results. This date value is exclusive.
    toDate: Date

    # Optional date representing the beginning of the search results based on issued date. This date value is inclusive.
    issuedFromDate: Date

    # Optional date representing the end of the search results based on issued date. This date value is exclusive.
    issuedToDate: Date

    # The order in which to return the bills.
    orderBy: BillsOrderBy = FROM_DATE_DESC
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): BillConnectionTypeConnection

  # Information about the account's billing cycle.
  billingOptions: BillingOptionsType

  # Fetch a specific issued bill (invoice/statement) for the account.
  bill(id: ID!, billType: BillTypeEnum): BillInterface

  # The direct debit instructions of the account
  directDebitInstructions(
    # Filter the direct debit instructions by status
    statuses: [DirectDebitInstructionStatus]
    before: String
    after: String
    first: Int
    last: Int
  ): DirectDebitInstructionConnectionTypeConnection

  # The account events that were recorded for the account.
  events(
    # Filter the account events by their type.
    eventTypes: [AccountEventType]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountEventConnectionTypeConnection

  # Applications by this account to become our customer. More recent applications will be listed first.
  applications(
    before: String
    after: String
    first: Int
    last: Int
  ): AccountApplicationConnectionTypeConnection

  # The type of account.
  accountType: AccountTypeChoices

  # The company type of a business account.
  businessType: BusinessTypeOptions
    @deprecated(
      reason: "The 'businessType' field is deprecated.\n\nUse `business.businessType` instead\n\n- Marked as deprecated on 2022-03-09.\n- Will be removed on 2024-01-01."
    )

  # Business info related to a business account.
  business: BusinessType

  # The method the account has specified they prefer we contact them
  commsDeliveryPreference: CommsDeliveryPreference
  communicationDeliveryPreference: String
    @deprecated(
      reason: "The 'communicationDeliveryPreference' field is deprecated.\n\nUse `commsDeliveryPreference` instead\n\n- Marked as deprecated on 2022-05-27.\n- Will be removed on 2024-01-01."
    )

  # The document accessibility preference of the account.
  documentAccessibility: DocumentAccessibilityChoices

  # Account references linked to this account.
  references: [AccountReferenceType]

  # Files attached to this account. Only available if categories defined in settings.
  fileAttachments: [AccountFileAttachment]

  # Files attached to this account.
  paginatedFileAttachments(
    # File attachment id.
    id: Int

    # File attachment category.
    category: String
    before: String
    after: String
    first: Int
    last: Int
  ): AccountFileAttachmentConnectionTypeConnection

  # The maximum amount a customer is allowed to request as a refund and the reason why that's the maximum amount.
  maximumRefund: MaximumRefundType

  # The campaigns associated with an account.
  campaigns: [AccountCampaignType]

  # True if there is an active Hardship Agreement for this account. False otherwise.
  isInHardship: Boolean

  # List of active hardship agreements for the user when is_in_hardship is True.
  activeHardshipAgreements: [HardshipAgreementType]

  # Notes for the account.
  notes: [AccountNoteType]

  # Contribution agreements for account.
  contributionAgreements: [ContributionAgreementType]

  # Assistance agreements for account.
  assistanceAgreements: [AssistanceAgreementType]

  # Debt collection proceedings for account.
  debtCollectionProceedings: [DebtCollectionProceedingType]

  # The datetime that the account was originally created.
  createdAt: DateTime

  # The language that the account preferred for communications.
  preferredLanguageForComms: String

  # Properties linked to the account now and in the future
  properties(
    # Returns properties that have an effective period that ends at or after the given activeFrom datetime.
    activeFrom: DateTime
  ): [PropertyType]

  # Expected balance in a year's time
  projectedBalance: Int

  # Whether the account's payment should be adjusted.
  shouldReviewPayments: Boolean

  # Top up payment amount in pence that we recommend for an account.
  recommendedBalanceAdjustment: Int

  # The electricity agreements belonging to the account
  electricityAgreements(active: Boolean): [ElectricityAgreementType]

  # The gas agreements belonging to the account
  gasAgreements(active: Boolean): [GasAgreementType]

  # Get details about warm home discount applications and records
  warmHomeDiscount: WarmHomeDiscount

  # Whether the account is eligible to apply for Warm Home Discount as part of the Scottish Broader Group.
  eligibilityForWarmHomeDiscount: WarmHomeDiscountEligibility

  # The postcode of the billing address.
  billingPostcode: String

  # Whether the account is eligible for tariff renewal
  canRenewTariff: Boolean

  # Only relevant for Kraken instances that support daily tracker tariffs. Returns null if not applicable.
  trackerTariffDailyPricing: TrackerTariffDailyPricing

  # Results of the latest review of the account's payments.
  paymentAdequacy: PaymentAdequacyType

  # The interest of an account in procuring smart meters.
  smets2Interest: SmartMeterInterestChoices

  # The reason why the account holder is not interested in having a smart meter installed.
  smets2RefusalReason: SMETS2InterestReason

  # The green benefits achieved over the lifetime of an account.
  greenAccomplishments: GreenAccomplishmentsType

  # Whether an account can change their payment schedule.
  canChangePayments: Boolean

  # The number of days around a move out a final meter reading can be given for.
  cotReadingWindowDays: Int

  # Whether an account can be withdrawn.
  canBeWithdrawn: Boolean

  # The current estimated supply start day on an account.
  currentEstimatedSsd: Date

  # The earliest possible supply start day on an account.
  earliestPossibleSsd: Date

  # The latest possible supply start day on an account.
  latestPossibleSsd: Date

  # The operations team that the account belongs to.
  operationsTeam: OperationsTeamType

  # Whether on not the meter readings can be input via IVR.
  canInputMeterReadingsViaIvr: Boolean

  # Whether or not the account has an active Dunning process.
  hasActiveDunningProcess: Boolean

  # Whether or not the account has active collections proceedings.
  hasActiveCollectionsProceedings: Boolean

  # Whether or not an account is eligible for an electricity reading incentive.
  isEligibleForElectricityReadingIncentive: Boolean

  # Whether or not an account is eligible for a gas reading incentive.
  isEligibleForGasReadingIncentive: Boolean

  # Whether or not the account is a part of a migration for which we want to switch supplier without customer actions.
  isInBlockingMigration: Boolean
}

type WarmHomeDiscount {
  # Get the Warm Home Discount applications against this account. These are ordered to return the most recent first.
  applications(
    before: String
    after: String
    first: Int
    last: Int
  ): WarmHomeDiscountApplicationConnection

  # Get the Warm Home Discount records attached to this account. These are ordered to return the most recent first.
  records(
    before: String
    after: String
    first: Int
    last: Int
  ): WarmHomeDiscountRecordConnection
}

#
#
# This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
#
#
type WarmHomeDiscountApplicationConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [WarmHomeDiscountApplicationEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `WarmHomeDiscountApplication` and its cursor.
type WarmHomeDiscountApplicationEdge {
  # The item at the end of the edge
  node: WarmHomeDiscountApplication

  # A cursor for use in pagination
  cursor: String!
}

# Get details about a Warm Home Discount application.
type WarmHomeDiscountApplication {
  # Which criteria was chosen for the Warm Home Discount application
  qualifyingCriteria: QualifyingCriteriaOptions

  # Which component criteria was chosen for the Warm Home Discount application
  qualifyingComponent: QualifyingComponentOptions
  yearEnding: Int!

  # The status of the Warm Home Discount application
  status: Status

  # Reason for rejecting a Warm Home Discount application
  rejectionReason: BroaderGroupRejectionReason

  # The tax year for which the application was made.
  taxYear: String

  # The last date on which this application was updated.
  updatedAt: Date
}

# An enumeration.
enum QualifyingCriteriaOptions {
  # In receipt of the Savings Element of Pension Credit only
  SAVINGS_ELEMENT_OF_PENSION_CREDIT

  # In receipt of Council Tax Reduction (excludes the 25% single person’s discount)
  COUNCIL_TAX_REDUCTION

  # In receipt of Income Support
  INCOME_SUPPORT

  # In receipt of Income-based Job Seeker’s Allowance (JSA)
  JOB_SEEKERS_ALLOWANCE

  # In receipt of Income-related Employment & Support Allowance (ESA)
  EMPLOYMENT_AND_SUPPORT_ALLOWANCE

  # In receipt of Working Tax Credit with a total annual household income of £19,978 or less (before tax and National Insurance)
  WORKING_TAX_CREDIT

  # In receipt of Housing Benefit with a total annual household income of £19,978 or less (before tax and National Insurance)
  HOUSING_BENEFIT

  # In receipt of Child Tax Credit where the award statement shows a total annual household income of £19,978 or less (before tax and National Insurance)
  CHILD_TAX_CREDIT

  # In receipt of universal credit, and has an earned income of between zero and £1,665 in at least one of the twelve preceding assessment periods
  UNIVERSAL_CREDIT

  # A total annual household income of £19,978 or less (before tax and National Insurance)
  LOW_INCOME_THRESHOLD
}

#
#     A list of all current and historic WHD qualifying component options.
#
#     All label strings correspond to specific wording of the most recent scheme.
#
enum QualifyingComponentOptions {
  # In receipt of Personal Independence Payments (PIP)
  PERSONAL_INDEPENDENCE_PAYMENTS

  # In receipt of Disability Living Allowance (DLA), any disability premium (all rates) or disabled child element of Universal Credit
  DISABILITY_BENEFITS

  # In receipt of any Income-related benefit which includes: Carer’s Premium and Carer’s Allowance (for someone within the household) OR Attendance Allowance (for applicant or their partner) OR Industrial Injuries Benefit
  INCOME_RELATED_BENEFITS

  # Hold a Maternity Exemption Certificate (MATEX)
  MATERNITY_EXEMPTION_CERTIFICATE

  # Are aged 62 and over (OR in receipt of any pensioner premium)
  AGE_THRESHOLD

  # Have a medically dependant illness (disability or mobility issue)
  HAS_DISABILITY

  # In receipt of Adult Disability Payment (ADP)
  ADULT_DISABILITY_PAYMENT

  # Have a dependent child under 5 (dependent child who normally resides with the applicant)
  DEPENDENT_CHILD_UNDER_FIVE

  # Have a dependent child aged 5 – 16 or under 18 if in full time education (dependent child who normally resides with the applicant)
  DEPENDENT_CHILD_OVER_FIVE

  # In receipt of the limited capability for work element of Universal Credit
  LIMITED_CAPABILITY_FOR_WORK

  # Hold a Medical Exemption Certificate (MEDEX)
  MEDICAL_EXEMPTION_CERTIFICATE

  # Are exempt from prescription charges (only for customers in England) or hold a HC2 certificate
  PRESCRIPTION_CHARGES_EXEMPTION

  # Hold a valid war pension NHS exemption certificate and the prescription is for your disability
  WAR_PENSION_EXEMPTION_CERTIFICATE
}

# An enumeration.
enum Status {
  # Pending
  PENDING

  # Awaiting audit
  AWAITING_AUDIT

  # Awaiting customer evidence
  AWAITING_CUSTOMER_EVIDENCE

  # Approved
  APPROVED

  # Rejected
  REJECTED

  # Withdrawn
  WITHDRAWN

  # Approved (customer service gesture)
  APPROVED_CUSTOMER_SERVICE_GESTURE
}

# An enumeration.
enum BroaderGroupRejectionReason {
  APPLICATIONS_NOT_OPEN
  ALREADY_RECEIVED_DISCOUNT
  HAS_OPEN_APPLICATION
  HAS_CORE_GROUP_DISCOUNT
  INSUFFICIENT_EVIDENCE_PROVIDED
  NO_LONGER_ON_SUPPLY
  DUPLICATE
  NOT_IN_SCOTLAND
  BUSINESS_ACCOUNT
  NON_DOMESTIC_METER_POINT
}

#
#
# This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
#
#
type WarmHomeDiscountRecordConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [WarmHomeDiscountRecordEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `WarmHomeDiscountRecord` and its cursor.
type WarmHomeDiscountRecordEdge {
  # The item at the end of the edge
  node: WarmHomeDiscountRecord

  # A cursor for use in pagination
  cursor: String!
}

# Get details about a Warm Home Discount record.
type WarmHomeDiscountRecord {
  # Type of account receiving the discount. Either credit the account or payment via prepay cards
  accountType: WhdAccountType
  yearEnding: Int!

  # Which criteria was chosen for the Warm Home Discount.
  qualifyingCriteria: QualifyingCriteriaOptions

  # Which component criteria was chosen for the Warm Home Discount.
  qualifyingComponent: QualifyingComponentOptions

  # Amount in pence that was credited to the account as a result of the discount.
  credit: Int

  # The tax year for which the credit was given.
  taxYear: String
}

# An enumeration.
enum WhdAccountType {
  SMART_PREPAY
  TRADITIONAL_PREPAY
  CREDIT
}

type WarmHomeDiscountEligibility {
  # Is the customer eligible to apply for the Warm Home Discount as part of the Scottish Broader Group.
  isEligible: Boolean

  # Reason why the customer is unable to apply.
  rejectionReason: String
}

type TrackerTariffDailyPricing {
  # URL for tracker demo
  demoUrl: String

  # Today's electricity costs (in pence)
  electricity: Int

  # Today's gas costs (in pence)
  gas: Int
}

type PaymentAdequacyType {
  # The suggested monthly payment amount in pence following the payment adequacy review.
  suggestedDirectDebitAmount: Int
}

# An enumeration.
enum SmartMeterInterestChoices {
  # We have captured that this account is interested in a SMETS2 meter. This does not mean they've booked an appointment.
  INTERESTED

  # We have captured that this account could be interested in a SMETS2 meter in the future, so it is appropriate to follow up with them.
  NOT_AT_THE_MOMENT

  # We have captured that this account is not interested in a SMETS2 meter. We should use this to avoid advertising SMETS2 meters to them, or contacting them about installing a SMETS2 meter.
  NOT_INTERESTED
}

# An enumeration.
enum SMETS2InterestReason {
  # Doesn't own own home.
  SMETS2_INTEREST_REASON_DO_NOT_OWN_HOME

  # Sceptical of technology.
  SMETS2_INTEREST_REASON_TECHNOLOGY_SCEPTICAL

  # Worried about security.
  SMETS2_INTEREST_REASON_WORRIED_SECURITY

  # Worried about health & safety.
  SMETS2_INTEREST_REASON_WORRIED_HEALTH_SAFETY

  # Negative publicity about smart meters.
  SMETS2_INTEREST_REASON_NEGATIVE_PUBLICITY

  # Worried about energy usage cost increasing.
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_USAGE_COST

  # Already has or is about to have a smart meter installed.
  SMETS2_INTEREST_REASON_ALREADY_HAS_SMART_METER

  # About to move house.
  SMETS2_INTEREST_REASON_HOUSE_MOVE_IMMINENT

  # About to switch supplier.
  SMETS2_INTEREST_REASON_SWITCH_IMMINENT

  # More information about smart meters required.
  SMETS2_INTEREST_REASON_MORE_INFORMATION_REQUIRED

  # Is a landlord.
  SMETS2_INTEREST_REASON_IS_LANDLORD

  # Cannot see benefit.
  SMETS2_INTEREST_REASON_CANNOT_SEE_BENEFIT

  # Wants to wait until it's compulsory.
  SMETS2_INTEREST_REASON_WAIT_UNTIL_IT_IS_COMPULSORY

  # Has vulnerability.
  SMETS2_INTEREST_REASON_VULNERABILITY

  # Worried about smart meters.
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_SMART_METERS

  # Worried about installation.
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_INSTALLATION

  # Property rarely or never occupied.
  SMETS2_INTEREST_REASON_PROPERTY_NOT_OCCUPIED

  # Cannot attend appointment.
  SMETS2_INTEREST_REASON_CANNOT_ATTEND_APPOINTMENT
}

type GreenAccomplishmentsType {
  savedTrees: Int
  savedCo2InKgs: Int
}

# A single accout search hit
type AccountSearchItemType {
  # The account found.
  account: AccountType

  # How well the account matched the search terms.
  score: Decimal
}

input AccountSearchInputType {
  # The account number eg. A-FF15AE70.
  accountNumber: String

  # The portfolio number eg. P-A123B456.
  portfolioNumber: String

  # URN Number.
  urn: String

  # The Account User ID (not account number).
  user: String

  # Internal account id (not account number).
  account: String

  # Statements.
  statements: String

  # Meter Serial Number.
  meterSerialNumber: String

  # Location (Supply or Billing, full or partial, address or post code).
  location: String

  # Account or Billing name.
  billingName: String

  # Business name.
  businessName: String

  # Business identifier or number.
  businessNumber: String

  # Account Reference.
  accountReferences: String

  # MPAN of property.
  mpan: String

  # MPRN of property.
  mprn: String

  # Telephone.
  telephoneNumber: String
}

# The possible errors that can be raised are:
#
# - KT-CT-1111: Unauthorized.
# - KT-CT-4619: Quote with given code not found.
# - KT-CT-4624: Unable to accept the given product code.
# - KT-CT-4626: No product selected for the given quote code.
# - KT-CT-4719: No supply point found for identifier provided.
# - KT-CT-4922: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type InitiateProductSwitch {
  possibleErrors: [PossibleErrorType]

  # The selected product for a specific product switch.
  productCode: String!

  # The date at which the product switch becomes effective.
  switchDate: Date!
}

input InitiateProductSwitchInput {
  # Identification of the account that requesting the product switch.
  accountNumber: String!

  # ID of the selected quoted product, obtain from quoting that supply point.
  quotedProductId: ID!

  # The date at which the product switch becomes effective.
  switchDate: Date!
}

# Create a Lead instance.
#
# The possible errors that can be raised are:
#
# - KT-CT-8901: Unable to create lead.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateNewLead {
  possibleErrors: [PossibleErrorType]

  # Lead created.
  lead: NewLeadType
}

type NewLeadType {
  # ID of the lead.
  id: Int

  # The source where the lead comes from.
  source: String

  # Lead phone.
  phone: String

  # Lead email.
  email: String

  # Lead name.
  name: String

  # To know if the lead is domestic or business.
  leadType: String
}

input NewLeadInputType {
  # The source where the lead comes from.
  source: String

  # Lead phone.
  phone: String

  # Lead email.
  email: String

  # Lead name.
  name: String

  # To know if the lead is domestic or business.
  leadType: String

  # The product the lead is interested in.
  marketName: String
}

# Publish a trigger within the transactional messaging service.
#
# The possible errors that can be raised are:
#
# - KT-CT-9901: Invalid trigger type code.
# - KT-CT-9902: Invalid trigger type params.
# - KT-CT-9903: Trigger type cannot be published externally.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type PublishTransactionalMessagingTrigger {
  possibleErrors: [PossibleErrorType]

  # The trigger that has been published.
  trigger: TriggerType
}

type TriggerType {
  # The ID of the trigger.
  id: String!
}

input PublishTransactionalMessagingTriggerInput {
  # The code of the trigger type to be published.
  triggerTypeCode: String!

  # The params of the trigger type, as a JSON string. These are defined in the Params class for a trigger type.
  params: JSONString!
}

# The possible errors that can be raised are:
#
# - KT-CT-4123: Unauthorized.
# - KT-CT-9601: Invalid data.
# - KT-CT-9602: Unable to create contribution agreement.
# - KT-CT-9605: Contribution amount cannot be 0 or negative.
# - KT-CT-9606: Scheme is not accepting contributions at this time.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateContributionAgreement {
  possibleErrors: [PossibleErrorType]

  # The created contribution agreement.
  contributionAgreement: ContributionAgreementType
}

input CreateContributionAgreementInput {
  # The account number.
  accountNumber: String!

  # The code of the scheme to contribute to.
  schemeCode: String!

  # The frequency of contributions.
  interval: Interval!

  # The amount contributed per interval. Note, this is in the smallest domination that the currency supports. e.g. Pence, Cents, Yen, etc.
  amount: Int!

  # The start datetime of the agreement.
  activeFrom: DateTime!

  # The end datetime of the agreement, if any.
  activeTo: DateTime
}

# The possible errors that can be raised are:
#
# - KT-CT-9603: Unable to find contribution agreement.
# - KT-CT-4123: Unauthorized.
# - KT-CT-9604: Unable to end contribution agreement.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type EndContributionAgreement {
  possibleErrors: [PossibleErrorType]

  # The created contribution agreement.
  contributionAgreement: ContributionAgreementType
}

input EndContributionAgreementInput {
  # The ID of the Contribution Agreement to end.
  contributionAgreementId: ID!

  # The future end datetime of the agreement. If not given, terminate now.
  endAt: DateTime
}

# Redeem Loyalty Points as account credit.
#
# The possible errors that can be raised are:
#
# - KT-CT-1111: Unauthorized.
# - KT-CT-9201: No Loyalty Point ledger found for the user.
# - KT-CT-9202: Loyalty Points adapter not configured.
# - KT-CT-9203: No ledger entries for the ledger.
# - KT-CT-9205: Insufficient Loyalty Points.
# - KT-CT-9206: Indivisible points.
# - KT-CT-9204: Negative or zero points set.
# - KT-CT-9208: Invalid posted at datetime.
# - KT-CT-9209: Negative Loyalty Points balance.
# - KT-CT-9210: Unhandled Loyalty Points exception.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type RedeemLoyaltyPointsForAccountCredit {
  possibleErrors: [PossibleErrorType]

  # The number of OctoPoints that were redeemed.
  pointsRedeemed: Int
}

# The input type for redeeming Loyalty Points.
input RedeemLoyaltyPointsInput {
  # The account number.
  accountNumber: String!

  # The number of Loyalty Points to redeem.
  points: Int!
}

# Transfer Loyalty Points between users.
#
# The possible errors that can be raised are:
#
# - KT-CT-1111: Unauthorized.
# - KT-CT-9205: Insufficient Loyalty Points.
# - KT-CT-9204: Negative or zero points set.
# - KT-CT-9208: Invalid posted at datetime.
# - KT-CT-9209: Negative Loyalty Points balance.
# - KT-CT-9210: Unhandled Loyalty Points exception.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type TransferLoyaltyPointsBetweenUsers {
  possibleErrors: [PossibleErrorType]

  # The number of OctoPoints that were transferred.
  pointsTransferred: Int
}

# The input type for transferring Loyalty Points.
input TransferLoyaltyPointsBetweenUsersInput {
  # The account number.
  accountNumber: String!

  # The account user receiving the points.
  receivingUserId: String!

  # The number of Loyalty Points to transfer.
  points: Int!
}

# Set the Loyalty Points user for the account.
#
# The possible errors that can be raised are:
#
# - KT-CT-1111: Unauthorized.
# - KT-CT-1111: Unauthorized.
# - KT-CT-9210: Unhandled Loyalty Points exception.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SetLoyaltyPointsUser {
  possibleErrors: [PossibleErrorType]

  # ID of the new Loyalty Points user.
  newLoyaltyPointsUserId: String
}

# The input type for setting the Loyalty Points user.
input SetLoyaltyPointsUserInput {
  # The account number.
  accountNumber: String!

  # The account user receiving the points.
  newLoyaltyPointsUserId: String!
}

# Use a referral code to create a referral and trigger a referral reward.
#
# The possible errors that can be raised are:
#
# - KT-CT-6723: Unauthorized.
# - KT-CT-6710: Unable to create referral.
# - KT-CT-6711: Accounts may not self-refer.
# - KT-CT-6713: Referring and referred account brands do not match.
# - KT-CT-6712: Invalid reference.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateReferral {
  possibleErrors: [PossibleErrorType]

  # The reward amount to be issued to the referred account, in smallest currency subunits.
  referredAccountRewardAmount: Int
}

# Required information for creating a referral
input CreateReferralInput {
  # The account number for the referred account.
  accountNumber: String!

  # An email address, link or code, referencing the referring account.
  reference: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-6723: Unauthorized.
# - KT-CT-6724: Referral claim code not found.
# - KT-CT-6725: Referral claim code redeeming error.
# - KT-CT-6726: Referral claim code has already been redeemed.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type RedeemReferralClaimCode {
  possibleErrors: [PossibleErrorType]
}

# Required payload to redeem the benefit for partner reward referral scheme
input RedeemReferralClaimCodeInput {
  # The account number for the referred account.
  accountNumber: String!

  # Referral scheme claim code value.
  code: String!
}

# Create a new portfolio.
#
# The possible errors that can be raised are:
#
# - KT-CT-9402: Received an invalid brandCode.
# - KT-CT-9401: Received an invalid operationsTeamId.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreatePortfolio {
  possibleErrors: [PossibleErrorType]

  # The created portfolio.
  portfolio: PortfolioType
}

input CreatePortfolioInput {
  # The brand to associate with this portfolio, if not provided the default brand will be used.
  brandCode: String = "OCTOPUS_ENERGY"

  # The ID of the operations team to associate with this portfolio.If no team is provided, no team will be assigned to the portfolio.
  operationsTeamId: ID

  # Whether collective bills should be issued for the portfolio's accounts. The default value is False.
  collectiveBilling: Boolean = false
}

# Close the Open Print Batch if any.
#
# The possible errors that can be raised are:
#
# - KT-CT-9010: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CloseOpenPrintBatch {
  possibleErrors: [PossibleErrorType]
  printBatch: PrintBatchType
}

# Mark a closed print batch as Processed
#
# The possible errors that can be raised are:
#
# - KT-CT-9011: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type MarkPrintBatchAsProcessed {
  possibleErrors: [PossibleErrorType]
  printBatch: PrintBatchType
}

# Create a Loyalty Card for the given account user.
#
# The possible errors that can be raised are:
#
# - KT-CT-5412: No account user exists with the given id.
# - KT-CT-8610: Invalid data.
# - KT-CT-8611: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateOrUpdateLoyaltyCardMutation {
  possibleErrors: [PossibleErrorType]

  # Created or updated loyalty card.
  loyaltyCard: LoyaltyCardType
}

input CreateOrUpdateLoyaltyCardInput {
  # The id of the account user.
  accountUserId: String

  # The scheme of the loyalty card.
  scheme: String

  # The number of the loyalty card.
  number: String
}

union LinkUserToLineResponse =
    LineLinkRedirectResponse
  | LinkTokenNotFound
  | AlreadyLinkedError

# Link Successful. Complete link process with LINE.
type LineLinkRedirectResponse {
  redirectUrl: String!
}

# Returned when no LineAccountLink record matching the parameters exists.
type LinkTokenNotFound {
  # The type of error that occurred.
  type: LineLinkErrorType!
}

enum LineLinkErrorType {
  NO_MATCHING_LINE_LINK
  ALREADY_LINKED
}

# Returned when an account already has a LINE account linked to it.
type AlreadyLinkedError {
  # The type of error that occurred.
  type: LineLinkErrorType!
}

# Link an AccountUser to a LINE account.
input LinkUserToLineInput {
  linkToken: String!
}

union UnlinkUserFromLineResponse =
    LineUnlinkedResponse
  | LinkTokenNotFound
  | LineCommonError

type LineUnlinkedResponse {
  message: String!
}

# A base error type. Should be used for general application or lower level errors.
type LineCommonError {
  # The error message to display to the user.
  message: String!

  # The field that for which this error should be associated
  field: String
}

# Termination was successfully initiated.
type LeaveSupplierInstigated {
  # The ID of the newly created or existing leave supplier process.
  leaveSupplierProcessId: ID!

  # The message to display to the user on termination initiation.
  message: String!
}

input LeaveSupplierInput {
  # The Kraken account number.
  accountNumber: String!

  # The requested last day of supply.
  requestedSupplyEndDate: Date!
  marketData: LeaveSupplierMarketInputType

  # Future billing address.
  futureBillingAddress: RichAddressInput = null
}

input LeaveSupplierMarketInputType {
  # A list of supply points for initiating a leave supplier journey.
  supplyPointData: [_DefaultMarketTerminationInput]
}

# Default input required to initiate a LeaveSupplier journey for a given market.
# This type should only be used when there are no configured markets while building
# the LeaveSupplierMarketInputType.
input _DefaultMarketTerminationInput {
  # The market supply point identification number.
  supplyPointIdentifier: String!
}

#
# A postal address.
#
# This data model is based on the structure used by Google's
# [libaddressinput library](https://github.com/google/libaddressinput)&mdash;so
# you can use it, or other libraries that use its data model
# and reference data, to accept input.
#
# All fields can be blank, except for ``country`` which must
# always be supplied.
#
# This type is the input equivalent of `RichAddressType`; all
# the fields here are semantically equivalent to fields
# there, except where documented.
#
input RichAddressInput {
  # A personal name.
  name: String

  # The name of a business or organisation.
  organization: String

  #
  # At most one of this field and `structured_street_address`
  # can be supplied.
  #
  # This is a divergence from `RichAddressType.street_address`,
  # where the field is always supplied; if
  # `structured_street_address` is present, it's generated from
  # that.
  #
  streetAddress: String

  #
  # At most one of this field and `street_address` can be
  # supplied.
  #
  # ### `AU`: Australia
  #
  # The following keys may be present; all are optional. All
  # keys have string values, and their meaning is the same as
  # their aseXML counterparts. (Note that, unlike aseXML, all
  # keys are provided at the top level, rather than being
  # nested.)
  #
  # - `flat_or_unit_type`
  # - `flat_or_unit_number`
  # - `floor_or_level_type`
  # - `floor_or_level_number`
  # - `building_or_property_name`
  # - `location_descriptor`
  # - `lot_number`
  # - `house_number_1`
  # - `house_number_suffix_1`
  # - `house_number_2`
  # - `house_number_suffix_2`
  # - `street_name`
  # - `street_type`
  # - `street_suffix`
  # - `postal_delivery_type`
  # - `postal_delivery_number_prefix`
  # - `postal_delivery_number_value`
  # - `postal_delivery_number_suffix`
  #
  # ### `JP`: Japan
  #
  # The following keys may be present; all are optional.
  # If keys are empty, they may be omitted from the response entirely.
  #
  # - `chome`
  # - `banchi`
  # - `go`
  # - `edaban`
  # - `kana_building_name`
  # - `kanji_building_name`
  # - `building_number`
  # - `room_number`
  # - `address_code`
  # - `physical_location_identifier`
  #
  structuredStreetAddress: GenericScalar

  #
  # UK dependent localities, or neighbourhoods or boroughs in
  # some other locations.
  #
  dependentLocality: String

  #
  # City or town portion of an address, e.g. US city, AU
  # suburb/town, IT comune, UK post town.
  #
  locality: String

  #
  # Top-level administrative subdivision, e.g. US state, AU
  # state/territory, IT region, JP prefecture.
  #
  administrativeArea: String

  #
  # Postal code (ZIP code in the US).
  #
  postalCode: String

  #
  # Sorting code, e.g. FR CEDEX code. This field is not used in many countries.
  #
  sortingCode: String

  #
  # ISO 3166-1 alpha-2 code of the country this address belongs
  # to, e.g. `AU`, `GB`, `JP`.
  #
  country: String

  #
  # Identifier used by the local postal service for this
  # address, e.g. AU DPID, GB postcode + Delivery Point Suffix,
  # US Zip-9 + Delivery Point.
  #
  # This is the value that gets encoded in the barcode printed
  # on the envelope by large-volume bulk mail providers.
  #
  deliveryPointIdentifier: String
}

# Output of a LeaveSupplier journey cancellation.
type LeaveSupplierCancelled {
  # The message to display to the user on cancellation.
  message: String!
}

# Input required to cancel a LeaveSupplier journey.
input CancelLeaveSupplierInput {
  # The ID of the LeaveSupplier process to cancel.
  leaveSupplierProcessId: ID!

  # The reason for the cancellation.
  reason: String
}

type PrepareAccountResult {
  # Was a new account created.
  isNewAccount: Boolean

  # The account number of the newly created account or the existing account to be re-used.
  accountNumber: String

  # Was a new user created.
  isNewUser: Boolean

  # The ID of the newly created or existing account user.
  userId: ID
}

input PrepareAccountInput {
  # The type of account to create.
  accountType: AccountTypeChoices = DOMESTIC

  # The brand of the created account.
  brandCode: String!

  # The billing name.
  billingName: String!

  # The billing address.
  billingAddress: LifecycleAddressInput!

  # The customer's details.
  customerDetails: CustomerDetailsInput!

  # Sales information.
  salesInfo: SalesInformationInput!

  # The preferred supply start date.
  preferredSsd: Date

  # The date of sale, defaults to today if not provided.
  dateOfSale: Date

  # The chosen payment day.
  chosenPaymentDay: Int
}

input LifecycleAddressInput {
  # Line 1 of address.
  line1: String!

  # Postal code.
  postalCode: String!

  # Country code.
  countryCode: String

  # Line 2 of address.
  line2: String = ""

  # Line 3 of address.
  line3: String = ""

  # Line 4 of address.
  line4: String = ""

  # Line 5 of address.
  line5: String = ""
}

# Details about the customer.
input CustomerDetailsInput {
  # Given name.
  givenName: String!

  # Family name.
  familyName: String!

  # The customer's title.
  title: String

  # The customer's pronouns.
  pronouns: String

  # Account email.
  email: String

  # Account mobile phone number.
  mobile: String

  # Account landline number.
  landline: String

  # The customer's date of birth.
  dateOfBirth: Date

  # The customer's communication preferences.
  preferences: UpdateAccountUserCommsPreferencesInput = null
}

input UpdateAccountUserCommsPreferencesInput {
  isOptedInToClientMessages: Boolean
  isOptedInToOfferMessages: Boolean
  isOptedInToRecommendedMessages: Boolean
  isOptedInToUpdateMessages: Boolean
  isOptedInToThirdPartyMessages: Boolean
  emailFormat: EmailFormats
  isUsingInvertedEmailColours: Boolean
  fontSizeMultiplier: Float
  isOptedInMeterReadingConfirmations: Boolean
  isOptedInToSmsMessages: Boolean
  preferredHoldMusic: Songs
}

# Information about the sale to associate with the account.
input SalesInformationInput {
  # Sales channel.
  salesChannel: String!

  # Sales subchannel.
  salesSubchannel: String

  # Unique reference number.
  urn: String

  # Unique reference number.
  affiliateSubdomain: String

  # Unique reference number.
  affiliateParams: String
}

# Create an affiliate link for a new sales agent.
#
# The possible errors that can be raised are:
#
# - KT-CT-7711: Invalid data.
# - KT-CT-7713: Invalid data.
# - KT-CT-7714: Invalid data.
# - KT-CT-7715: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAffiliateLink {
  possibleErrors: [PossibleErrorType]
  affiliateLink: AffiliateLinkType
}

input CreateAffiliateLinkInputType {
  # The organisation for whom to create the affiliate link for.
  organisationId: ID!

  #
  # Will be validated as follows:
  #
  # - should be at least two characters
  # - should only contain (letters, numbers, and Hyphen)
  # - should not contain bad words
  # - should not contain any of the reserved words including:
  #  affiliates, api, business, click, consul, developer, friends, kraken, mail, sendgrid, tech, webhooks, www, www2
  subdomain: String!
  contactName: String!
  contactEmail: String!
}

# Update an affiliate link of an existing sales agent.
#
# The possible errors that can be raised are:
#
# - KT-CT-7711: Invalid data.
# - KT-CT-7713: Invalid data.
# - KT-CT-7714: Invalid data.
# - KT-CT-7715: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateAffiliateLink {
  possibleErrors: [PossibleErrorType]
  affiliateLink: AffiliateLinkType
}

input UpdateAffiliateLinkInputType {
  # The id of the affiliate link that is going to be edited.
  linkId: ID!

  # The organisation for whom to update the affiliate link for.
  organisationId: ID

  #
  # Will be validated as follows:
  #
  # - should be at least two characters
  # - should only contain (letters, numbers, and Hyphen)
  # - should not contain bad words
  # - should not contain any of the reserved words including:
  #  affiliates, api, business, click, consul, developer, friends, kraken, mail, sendgrid, tech, webhooks, www, www2
  subdomain: String
  contactName: String
  contactEmail: String
  isBusiness: Boolean
  landingUrl: String
  trainingStatus: String
}

# Create an affiliate organisation.
#
# The possible errors that can be raised are:
#
# - KT-CT-7716: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAffiliateOrganisation {
  possibleErrors: [PossibleErrorType]
  affiliateOrganisation: AffiliateOrganisationType
}

input CreateAffiliateOrganisationInputType {
  name: String!

  # Sales Channel
  salesChannel: SalesChannelChoices!

  # Default Account Type
  defaultAccountType: AccountTypeChoices!

  # Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  canRegisterBusinessMeterPoints: Boolean

  # Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  canRegisterPortfolioAccounts: Boolean

  # Allow registration requests with customers without an email address.
  canRegisterCustomersWithoutEmailAddress: Boolean

  # Allow this partner to skip validation that ensures all meter points belong to the same address
  skipMeterPointAddressValidation: Boolean

  # Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  allowAlternativePaymentMethods: Boolean

  # Allow performing tariff renewals via API.
  canRenewTariffs: Boolean

  # Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  canUseIvrSupportApi: Boolean

  # Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  isFieldSalesOnlyProduct: Boolean
}

# Update an affiliate organisation.
#
# The possible errors that can be raised are:
#
# - KT-CT-7717: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateAffiliateOrganisation {
  possibleErrors: [PossibleErrorType]
  affiliateOrganisation: AffiliateOrganisationType
}

input UpdateAffiliateOrganisationInputType {
  # The organisation that is going to be edited.
  organisationId: ID!
  name: String

  # Sales Channel
  salesChannel: SalesChannelChoices = null

  # Default Account Type
  defaultAccountType: AccountTypeChoices = null

  # Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  canRegisterBusinessMeterPoints: Boolean

  # Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  canRegisterPortfolioAccounts: Boolean

  # Allow registration requests with customers without an email address.
  canRegisterCustomersWithoutEmailAddress: Boolean

  # Allow this partner to skip validation that ensures all meter points belong to the same address
  skipMeterPointAddressValidation: Boolean

  # Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  allowAlternativePaymentMethods: Boolean

  # Allow performing tariff renewals via API.
  canRenewTariffs: Boolean

  # Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  canUseIvrSupportApi: Boolean

  # Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  isFieldSalesOnlyProduct: Boolean
}

# Create a session for an affiliate link.
type CreateAffiliateSession {
  affiliateSession: AffiliateSessionType
}

# A tracked session for the affiliate link.
type AffiliateSessionType {
  id: ID!
  ipAddress: String
  userAgent: String!
  queryParams: JSONString!
  link: AffiliateLinkType
}

input CreateAffiliateSessionInputType {
  # The affiliate link for whom to create the session for.
  linkId: ID!

  # The IP Address of the user.
  ipAddress: String

  # The HTTP user agent.
  userAgent: String

  # Additional query parameters to attach to this session.
  queryParams: JSONString

  # The quote share that led to this session.
  quoteShareId: ID
}

# Validate whether a user's email is a valid email via the Kickbox API.
type ValidateEmail {
  # Whether the email is valid or not.
  isValid: Boolean
}

# Input required to validate email address via Kickbox
input ValidateEmailInput {
  # The user's email address.
  email: String!

  # Check if an email is already in use.
  checkUniqueness: Boolean = false
}

# Validate whether a user's phone number is a valid phone number.
type ValidatePhone {
  # Whether the phone number is valid or not.
  isValid: Boolean
}

input ValidatePhoneNumberInput {
  # The user's phone number.
  phoneNumber: String!
}

# Returns an Action to perform, e.g. a screen to load.
#
# BackendScreenEvents are specific types of Action which trigger a mutation in the Kraken backend.
# They return an action (any type), such as a ScreenActionType (which is then used to load the next screen).
# Any action registered in the registry should really be an "event" with some side-effect in the backend.
#
# The possible errors that can be raised are:
#
# - KT-CT-1111: Unauthorized.
# - KT-CT-8002: No event found.
# - KT-CT-8003: Event has no execute function.
# - KT-CT-8004: Error executing event in the backend.
# - KT-CT-8007: Incorrect or missing parameters for backend screen event.
# - KT-GB-9310: Account ineligible for joining Octoplus.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type BackendScreenEvent {
  possibleErrors: [PossibleErrorType]

  # An action to perform.
  action: ActionType
}

# Input for a backend action.
input BackendScreenEventInput {
  # The ID of the action to perform.
  eventId: ID!

  # List of key-value pairs (strings) to pass as parameters to the mutation.
  params: [BackendScreenParamInputType]
}

# The possible errors that can be raised are:
#
# - KT-CT-5514: Unable to submit feedback.
# - KT-CT-5511: The feedback_id should be provided for feedback source.
# - KT-CT-5512: The feedback doesn't match the account.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type SubmitCustomerFeedback {
  possibleErrors: [PossibleErrorType]
  customerFeedback: CustomerFeedbackType
}

type CustomerFeedbackType {
  id: ID!

  # The value attached to the source
  rawScore: Int

  # The datetime the feedback was submitted
  submittedAt: DateTime
}

input CustomerFeedbackInputType {
  answer: String
  issueResolved: Boolean!
  formId: Int!
  feedbackId: Int!
  accountNumber: String!
}

# Mutation for executing the repayment request use case.
#
# The possible errors that can be raised are:
#
# - KT-CT-1132: Unauthorized.
# - KT-CT-3927: Invalid Amount.
# - KT-CT-3928: Idempotency key used for another repayment request.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SubmitRepaymentRequest {
  possibleErrors: [PossibleErrorType]

  # The newly created repayment request.
  repaymentRequest: RequestRepaymentOutputType
}

# Output for creating a repayment request.
type RequestRepaymentOutputType {
  # The ID of the repayment request.
  requestId: String

  # The current status of the repayment request.
  status: RepaymentRequestStatus
}

input RequestRepaymentInputType {
  # The account number for the requested ledger's account.
  accountNumber: String!

  # The ledger id from which the repayment will be requested.
  ledgerId: String!

  # The amount to be repaid.
  amountInMinorUnit: Int!

  # The method by which the money will be transferred to the customer.
  method: RequestableRepaymentMethod = null

  # Unique constraint to prevent duplicate requests.
  idempotencyKey: String!

  # The reason for the repayment.
  reason: String
}

# An enumeration.
enum RequestableRepaymentMethod {
  BANK_TRANSFER
  CHEQUE
}

# Cancel a repayment or refund request.
#
# The possible errors that can be raised are:
#
# - KT-CT-4231: Unauthorized.
# - KT-CT-3930: The repayment or refund request does not exist.
# - KT-CT-3931: This repayment or refund request cannot be cancelled.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type CancelRepaymentRequest {
  possibleErrors: [PossibleErrorType]

  # The cancelled repayment/refund request.
  repaymentRequest: CancelRepaymentRequestOutputType
}

# Output from cancelling a repayment or refund request.
type CancelRepaymentRequestOutputType {
  # The ID of the cancelled request.
  requestId: String

  # The current status of the cancelled request.
  status: RepaymentRequestStatus
}

input CancelRepaymentRequestInputType {
  # The id of the request to be cancelled.
  requestId: String!
}

# Allow a repayment to be submitted.
#
# The possible errors that can be raised are:
#
# - KT-CT-3944: Account repayment does not exist.
# - KT-CT-3945: Unable to allow a repayment to be submitted.
# - KT-CT-3950: The provided reason text is too long.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type AllowRepaymentSubmission {
  possibleErrors: [PossibleErrorType]

  # The repayment ID.
  repaymentId: ID

  # Resulting Repayment Intervention details.
  repaymentIntervention: RepaymentInterventionType
}

type RepaymentInterventionType {
  # The repayment intervention outcome.
  outcome: String

  # The repayment intervention reason.
  reason: String
}

# Input fields for Repayment Intervention.
input RepaymentInput {
  # The repayment ID.
  repaymentId: ID!

  # The Repayment Intervention reason.
  reason: String
}

# Block a repayment from being submitted.
#
# The possible errors that can be raised are:
#
# - KT-CT-3944: Account repayment does not exist.
# - KT-CT-3946: Unable to block a repayment from being submitted.
# - KT-CT-3950: The provided reason text is too long.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type BlockRepaymentSubmission {
  possibleErrors: [PossibleErrorType]

  # The repayment ID.
  repaymentId: ID

  # Resulting Repayment Intervention details.
  repaymentIntervention: RepaymentInterventionType
}

# The possible errors that can be raised are:
#
# - KT-CT-3934: Repayment request already approved.
# - KT-CT-3935: Repayment request cannot be paid.
# - KT-CT-3959: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type ApproveRepayment {
  possibleErrors: [PossibleErrorType]

  # The approved repayment.
  repayment: AccountRepaymentType
}

input ApproveRepaymentInput {
  # The account number for the requested repayment.
  accountNumber: ID!

  # The id of the account repayment to be approved.
  repaymentId: ID!
}

# Collect deposit for the given account.
#
# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-CT-5711: No collection is required.
# - KT-CT-5712: Deposit agreement does not exist or has not been accepted.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CollectDeposit {
  possibleErrors: [PossibleErrorType]
  payment: CollectDepositOutput
}

type CollectDepositOutput {
  status: CollectDepositStatusChoices
  paymentDate: Date
}

enum CollectDepositStatusChoices {
  APPROVED
  CLEARED
  CANCELLED
  HELD_FOR_REVIEW
  FAILED
  PENDING
  REQUESTED
  SCHEDULED
  NONE
}

input CollectDepositInput {
  accountNumber: String!
  depositKey: String!
  idempotencyKey: String!
}

# Record the customer's acceptance of a deposit agreement.
#
# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type RecordDepositAgreementAccepted {
  possibleErrors: [PossibleErrorType]
  isRecorded: Boolean
}

input DepositAgreementInput {
  accountNumber: String!
  depositKey: String!
}

# Create a new deposit agreement for the account if it needs one.
#
# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateDepositAgreement {
  possibleErrors: [PossibleErrorType]
  depositAgreement: CreateDepositAgreementOutput
}

type CreateDepositAgreementOutput {
  depositRequired: Boolean
  depositAmount: Int
}

input CreateDepositAgreementInput {
  accountNumber: String!
  depositKey: String!
  reason: String!
}

# Initiate a standalone payment and return the client secret required to complete it.
#
# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-CT-3943: Invalid ledger.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type InitiateStandalonePayment {
  possibleErrors: [PossibleErrorType]
  payment: InitiateStandalonePaymentOutput
}

# Tokens required to collect and retrieve a standalone payment.
type InitiateStandalonePaymentOutput {
  # The retrieval token for this standalone payment.
  retrievalToken: String!

  # The secret used to collect the payment.
  secretToken: String!
}

# Input fields for initiating a standalone payment.
#
# The amount should always be provided in the minor unit of currency (e.g., pence not pounds,
# cents not dollars, etc.).
#
# A standalone payment can be made against a specific ledger (e.g., a debt ledger) by
# providing the ledger id. Accounts have a default ledger that will be used if not provided.
input InitiateStandalonePaymentInput {
  # The account number.
  accountNumber: String!

  # The amount to be collected in the minor unit of currency.
  amount: Int!

  # A description of the purpose of the payment.
  description: String!

  # The method by which the payment is being collected.
  collectionMethod: CollectionMethod = null

  # The id of the specific ledger against which this payment should be applied.
  ledgerId: ID
}

enum CollectionMethod {
  CARD
  DIRECT_DEBIT
}

# Initiate a standalone payment and return the client secret required to complete it.
#
# The possible errors that can be raised are:
#
# - KT-CT-1128: Unauthorized.
# - KT-CT-3822: Unauthorized.
# - KT-CT-3943: Invalid ledger.
# - KT-CT-3957: No collection method provided.
# - KT-CT-3958: Provide either ledger ID or ledger number.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type InitiateHostedStandalonePayment {
  possibleErrors: [PossibleErrorType]

  # The details required to refer to and complete a hosted payment.
  payment: InitiateHostedStandalonePaymentOutput
}

# Tokens required to collect and retrieve a standalone payment.
type InitiateHostedStandalonePaymentOutput {
  # The retrieval token for this standalone payment.
  retrievalToken: String!

  # The url for the customer to complete the payment.
  url: String!
}

# Input fields for initiating a hosted standalone payment.
#
# The amount should always be provided in the minor unit of currency (e.g., pence not pounds,
# cents not dollars, etc.).
#
# A standalone payment can be made against a specific ledger (e.g., a debt ledger) by
# providing the ledger id. Accounts have a default ledger that will be used if not provided.
input InitiateHostedStandalonePaymentInput {
  # The account number.
  accountNumber: String!

  # The amount to be collected in the minor unit of currency.
  amount: Int!

  # A description of the purpose of the payment.
  description: String!

  # The method by which the payment is being collected.
  collectionMethod: CollectionMethod!

  # The number of the specific ledger against which this payment should be applied. Please provide either ledger number or ID.
  ledgerNumber: String

  # The id of the specific ledger against which this payment should be applied. Please provide either ledger number or ID.
  ledgerId: ID

  # The URL to redirect the user to after the action was completed successfuly.
  returnUrlSuccess: String

  # The URL to redirect the user to after the action was completed but the payment is still being processed.
  returnUrlPending: String

  # The URL to redirect the user to after the action resulted in a failure.
  returnUrlFailure: String

  # The URL to redirect the user to after the action resulted in an error.
  returnUrlError: String

  # The URL to redirect the user to after the action was cancelled.
  returnUrlCancel: String

  # The URL to redirect the user to if the url is not longer valid.
  returnUrlExpired: String
}

# Get the client secret needed to create a new payment instruction using an embedded form.
#
# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type GetEmbeddedSecretForNewPaymentInstruction {
  possibleErrors: [PossibleErrorType]
  secretKey: String
}

# The input for getting the client secret for an embedded new card payment method form.
input GetEmbeddedSecretForNewPaymentInstructionInput {
  # The account number.
  accountNumber: String!

  # The type of the new payment instruction.
  instructionType: PaymentType!

  # **WARNING: Will be mandatory in future versions**
  #
  #  The ledger ID.
  ledgerId: String
}

# Store a new payment instruction created through the embedded process.
#
# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type StorePaymentInstruction {
  possibleErrors: [PossibleErrorType]

  # The stored payment instruction.
  paymentInstruction: PaymentInstructionType
}

# The input for storing a new payment instruction created through the embedded process.
input StorePaymentInstructionInput {
  # The account number.
  accountNumber: String!

  # The type of the new payment instruction.
  instructionType: PaymentType!

  # The datetime from which the instruction is vaild.
  validFrom: DateTime!

  # The vendor's reference for this payment method.
  vendorReference: String!

  # **WARNING: Will be mandatory in future versions**
  #
  #  The ledger ID to which the instructions will be linked.
  ledgerId: String
}

# Get external URL where the user can set up a payment instruction.
#
# The possible errors that can be raised are:
#
# - KT-CT-1128: Unauthorized.
# - KT-CT-3822: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type GetHostedUrlForNewPaymentInstruction {
  possibleErrors: [PossibleErrorType]

  # URL at which payment instruction can be set up.
  url: String
}

# The input needed for getting the external URL for setting up a payment instruction.
input GetHostedUrlForNewPaymentInstructionInput {
  # The account number.
  accountNumber: String!

  # The ledger number.
  ledgerNumber: String!

  # The type of the new payment instruction.
  instructionType: PaymentType!

  # The URL to redirect the user to after the action was completed successfuly.
  returnUrlSuccess: String

  # The URL to redirect the user to after the action resulted in a failure.
  returnUrlFailure: String

  # The URL to redirect the user to after the action resulted in an error.
  returnUrlError: String

  # The URL to redirect the user to after the action was cancelled.
  returnUrlCancel: String
}

# Invalidates a payment instruction.
#
# The possible errors that can be raised are:
#
# - KT-CT-3926: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type InvalidatePaymentInstruction {
  possibleErrors: [PossibleErrorType]
  instruction: InvalidatePaymentInstructionOutput
}

# Output for invalidating an arbitrary payment instruction.
type InvalidatePaymentInstructionOutput {
  id: Int
}

# Input for invalidating an arbitrary payment instruction.
input InvalidatePaymentInstructionInput {
  accountNumber: String!

  # The id of the payment instruction to be invalidated.
  id: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-3940: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type SetUpDirectDebitInstruction {
  possibleErrors: [PossibleErrorType]
  paymentInstruction: DirectDebitInstructionType
}

input SetUpDirectDebitInstructionInput {
  accountNumber: String!
  ledgerId: ID!
  validFrom: DateTime!
  bankDetails: BankDetailsInput!
}

input BankDetailsInput {
  accountHolder: String
  iban: String
  accountNumber: String
  bankCode: String
  branchCode: String
  accountType: String
}

# The possible errors that can be raised are:
#
# - KT-CT-3932: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CollectPayment {
  possibleErrors: [PossibleErrorType]

  # Details about the collected payment. Note that we might not be able to collect the payment (e.g. if there is no usable payment instruction), in which case the status of the returned payment might be failed or cancelled.
  payment: AccountPaymentType
}

input CollectPaymentInput {
  # The account number.
  accountNumber: String!

  # The payment amount (in pence).
  amount: Int!

  # The date to attempt to take the payment. Cannot be a date in the past. Payment will be collected on the requested date or as soon as possible after that date.
  paymentDate: Date!

  # The reason a payment is being collected, for internal audit purposes
  description: String!
  idempotencyKey: String!

  # The type of the payment instruction.
  collectionMethod: PaymentType = null

  # The ID of the ledger on which to collect the payment.
  ledgerId: ID!
}

# The possible errors that can be raised are:
#
# - KT-CT-3924: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type AmendPayment {
  possibleErrors: [PossibleErrorType]
  payment: AccountPaymentType
}

input AmendPaymentInput {
  # The account number.
  accountNumber: String!

  # The ID of the payment to amend.
  paymentId: Int!

  # The new amount for the amended payment.
  amount: Int!

  # The new date to collect the payment.
  paymentDate: Date!

  # Reason for amending the payment.
  reason: String
}

# The possible errors that can be raised are:
#
# - KT-CT-3815: No active payment schedule found for this account.
# - KT-CT-3941: Invalid data.
# - KT-CT-3942: An unexpected error occurred.
# - KT-CT-3947: An unexpected error occurred.
# - KT-CT-3953: The payment schedule is not a balance triggered schedule.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateAutoTopUpAmount {
  possibleErrors: [PossibleErrorType]

  # The new schedule created.
  schedule: PaymentScheduleType
}

# Input type for updating the schedule auto top up amount for for an account. Requires an `account_number`, ledger_id and `payment_amount` to be provided.
input UpdateAutoTopUpAmountInput {
  # Account number to update the schedule auto top up amount for.
  accountNumber: String!

  # Specifies the ledger ID associated with the current schedule for updates.
  ledgerId: Int!

  # The new auto-top-up amount for the payment schedule.
  paymentAmount: Int!
}

# The possible errors that can be raised are:
#
# - KT-CT-1111: Unauthorized.
# - KT-CT-3815: No active payment schedule found for this account.
# - KT-CT-3822: Unauthorized.
# - KT-CT-3923: Unauthorized.
# - KT-CT-3941: Invalid data.
# - KT-CT-3942: An unexpected error occurred.
# - KT-CT-3947: An unexpected error occurred.
# - KT-CT-3960: Invalid value for payment day.
# - KT-CT-3961: Cannot update plan-associated payment schedule.
# - KT-CT-3962: No new value provided to update payment schedule.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAccountPaymentSchedule {
  possibleErrors: [PossibleErrorType]

  # New payment schedule.
  schedule: PaymentScheduleType!
}

# Input type for updating the payment schedule on a ledger. Requires an `account_number`, `ledger_id` and one of `payment_day` or `payment_amount` to be provided.
input CreateAccountPaymentScheduleInput {
  # Number of the account for which to update the schedule.
  accountNumber: String!

  # Number of the ledger associated with the current payment schedule.
  ledgerNumber: String!

  # The new day of the month at which to take payment; ranges from 1 to 28.
  paymentDay: Int

  # The new fixed payment amount.
  paymentAmount: Int
}

# The possible errors that can be raised are:
#
# - KT-CT-3924: Unauthorized.
# - KT-CT-3954: Payment cancellation failed.
# - KT-CT-3955: Payment cannot be cancelled.
# - KT-CT-3956: Temporary error occurred.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CancelPayment {
  possibleErrors: [PossibleErrorType]

  # The cancelled payment.
  payment: AccountPaymentType
}

input CancelPaymentInput {
  # The account number.
  accountNumber: ID!

  # The ID of the payment to cancel.
  paymentId: ID!

  # Reason for cancelling the payment.
  reason: String
}

# The possible errors that can be raised are:
#
# - KT-CT-3924: Unauthorized.
# - KT-CT-3928: Idempotency key used for another repayment request.
# - KT-CT-3929: The payment is not in a refundable state.
# - KT-CT-3933: Refund amount greater than payment amount.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type RefundPayment {
  possibleErrors: [PossibleErrorType]

  # The repayment for the requested refund.
  repayment: AccountRepaymentType
}

input RefundPaymentInput {
  # The account number.
  accountNumber: ID!

  # The ID of the payment to refund.
  paymentId: ID!

  # The amount to be repaid.
  amountInMinorUnit: Int!

  # Unique constraint to prevent duplicate requests.
  idempotencyKey: String!

  # Reason for refunding the payment.
  reason: String!
}

type AssignInkBucketPayload {
  # The conversation that will be assigned to the bucket.
  conversation: InkConversation!

  # The bucket that the conversation will be assigned to.
  bucket: InkBucket!
  clientMutationId: String
}

input AssignInkBucketInput {
  # The relay id of the conversation that will be assigned to the bucket.
  conversationRelayId: ID!

  # The name of the bucket to assign the conversation to.
  bucketName: String!
  clientMutationId: String
}

type UpdateMessageTagsPayload {
  # Confirmed tags.
  tags: [InkTag!]!
  clientMutationId: String
}

input UpdateMessageTagsInput {
  # The message to set the tags on.
  messageRelayId: ID!

  # The tag names to set on the message.
  tagNames: [String!]!

  # The tag code to set on the message.
  taggerCode: String!

  # The tag version to set on the message.
  taggerVersion: String!
  clientMutationId: String
}

# Register an Ink inbound message.
type CreateInkInboundMessagePayload {
  # The Ink message that was created.
  message: InkMessage!
  clientMutationId: String
}

input CreateInkInboundMessageInput {
  channel: InkCommunicationChannel!

  #
  # An arbitrary, unique ID for this message.
  #
  # This must be unique for each message that is supplied
  # using the same organisation; collisions between messages
  # provided by different organisations are tolerated.
  #
  # Stored as vendor_id.
  #
  messageId: String!
  newMessage: InkMessageInput!

  #
  # An optional vendor value to denote which system it originated from.
  #
  # If no vendor is passed, we will get the default generic vendor from
  # the setting called INK_DEFAULT_GENERIC_MESSAGE_API_VENDOR.
  #
  vendor: String

  #
  # An optional parameter where we can pass the generic message headers if it has one
  #
  # Email channel tries to get the value `conversation-relay-id` from this
  # parameter
  #
  messageHeaders: JSONString

  # When the message occurred in the system of origin.
  occurredAt: DateTime
  clientMutationId: String
}

# An Ink message used as an input.
#
# This is intended to be morally equivalent to a tagged union; exactly
# one of the properties provided here is expected to be provided.
#
# At current, only the generic message type is provided, because only
# the generic message type is currently supported as an input type.
# This is intended to be a backwards-compatible extension point to
# allow other message input types to be added in the future.
input InkMessageInput {
  generic: InkGenericMessageInput
  email: InkEmailMessageInput
  post: InkPostMessageInput
}

# This type is used to create an generic message.
input InkGenericMessageInput {
  # The content of the message, as plain text.
  plainTextContent: String!

  # Message attachments.
  attachments: [InkGenericMessageAttachmentInput!]

  # The identity the message was sent from.
  fromHandle: String!

  # The identity the message was sent to.
  toHandle: String!
}

input InkGenericMessageAttachmentInput {
  # The S3 key of the attachment.
  s3Key: String!

  # The S3 bucket of the attachment.
  s3Bucket: String!
}

# This type is used to create an inbound email.
input InkEmailMessageInput {
  # The content of the message, as plain text.
  plainTextContent: String!

  # Message attachments.
  attachments: [InkGenericMessageAttachmentInput!]

  # The email subject/title.
  subject: String!

  # The email address the message was sent from.
  fromAddress: Email!

  # The email addresses the message was sent to.
  toAddresses: [Email!]!

  # The carbon copy (cc) email addresses the message was sent to.
  ccAddresses: [Email!]

  # The S3 bucket in which the original email is stored.
  s3Bucket: String

  # The S3 key of the original email.
  s3Key: String
}

scalar Email

# This type is used to create an inbound post.
input InkPostMessageInput {
  # The content of the message, as plain text.
  plainTextContent: String!

  # Message attachments.
  attachments: [InkGenericMessageAttachmentInput!]

  # The account number that the letter was sent from.
  accountNumber: String

  # Notes on the letter.
  notes: String
}

# The possible errors that can be raised are:
#
# - KT-CT-7620: Channel not supported.
# - KT-CT-7618: Unable to process message.
# - KT-CT-7624: Error when generating the presigned URL.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type GenerateInkPresignedUrl {
  possibleErrors: [PossibleErrorType]

  # A presigned URL for the user to upload to the quarantine bucket.
  uploadUrl: String!

  # Presigned post fields; key, awsAccessKeyId, xAmzSecurityToken, policy, signature.
  presignedPostFields: PresignedPostFields
    @deprecated(reason: "Replaced in favor of fields.")

  # The key for the item.
  key: String!

  # Presigned post fields required to upload the file.
  fields: JSONString!
}

# Fields returned by generate_presigned_post.
type PresignedPostFields {
  # The S3 bucket key.
  key: String!

  # The AWS access key ID.
  awsAccessKeyId: String!

  # The AMZ security token.
  xAmzSecurityToken: String!

  # The S3 policy.
  policy: String!

  # AWS Signature Version 4 Authentication.
  signature: String!
}

input GenerateInkPresignedUrlInput {
  # The channel of the contact.
  channel: InkCommunicationChannel!

  # The name of the file.
  filename: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-8202: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateGoodsQuote {
  possibleErrors: [PossibleErrorType]

  # Goods quote created for the customer.
  goodsQuote: GoodsQuote
}

input CreateGoodsQuoteInput {
  # The account number.
  accountNumber: String!

  # Products to get a quote for.
  productsToQuote: [ProductToQuoteInput]!

  # A JSON object containing client parameters to store on the quote.
  clientParams: GenericScalar
}

# Represents a product and the quantity to quote for a customer.
input ProductToQuoteInput {
  # ID of the product to quote.
  productId: Int!

  # Number of units.
  numberOfUnits: Int!

  # Price per unit in smallest sub-unit of the currency.
  pricePerUnit: Int

  # Currency.
  currency: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-8202: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateGoodsQuoteWithoutAccount {
  possibleErrors: [PossibleErrorType]

  # Goods quote created for the customer.
  goodsQuote: GoodsQuote
}

input CreateGoodsQuoteWithoutAccountInput {
  # Customer profile.
  customerProfile: CustomerProfileInput!

  # Products to get a quote for.
  productsToQuote: [ProductToQuoteInput]!

  # A JSON object containing client parameters to store on the quote.
  clientParams: GenericScalar
}

input CustomerProfileInput {
  # Customer's given name.
  givenName: String!

  # Customer's family name.
  familyName: String!

  # Customer's email.
  email: String!

  # Customer's phone number.
  phoneNumber: String!

  # Customer's postcode.
  postcode: String!

  # Line 1 of customer's address.
  addressLine1: String!

  # Line 2 of customer's address.
  addressLine2: String

  # Line 3 of customer's address.
  addressLine3: String

  # Line 4 of customer's address.
  addressLine4: String

  # Line 5 of customer's address.
  addressLine5: String
}

# The possible errors that can be raised are:
#
# - KT-CT-8223: Unauthorized.
# - KT-CT-8201: Received an invalid quoteId.
# - KT-CT-8224: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type AcceptGoodsQuote {
  possibleErrors: [PossibleErrorType]

  # Goods purchase created.
  goodsPurchase: GoodsPurchase
}

input AcceptGoodsQuoteInput {
  # The account number.
  accountNumber: String!

  # ID of the accepted quote.
  quoteId: Int!

  # A JSON object containing client parameters to store on the quote.
  clientParams: JSONString

  # A JSON object containing market parameters to store on the purchase.
  marketParams: JSONString
}

# The possible errors that can be raised are:
#
# - KT-CT-4122: Invalid email.
# - KT-CT-8203: Received an invalid quote code.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type ShareGoodsQuote {
  possibleErrors: [PossibleErrorType]

  # Goods quote shared.
  share: GoodsQuoteShare
}

type GoodsQuoteShare {
  # The ID of the quote share.
  id: Int
}

input ShareGoodsQuoteInput {
  # The quote to share.
  quoteCode: String!

  # The email to share the quote with.
  email: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-8206: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateGoodsPurchase {
  possibleErrors: [PossibleErrorType]

  # Goods purchase created.
  goodsPurchase: GoodsPurchase
}

input CreatePurchaseInput {
  # The account number.
  accountNumber: String!

  # Products being purchased.
  saleItems: [ProductToPurchaseInput]!

  # A JSON object containing client parameters to store on the quote.
  clientParams: JSONString

  # A JSON object containing client parameters to store on the purchase.
  marketParams: JSONString
}

input ProductToPurchaseInput {
  # Products code to purchase.
  productCode: String!

  # Number of units.
  numberOfUnits: Int!
}

# The possible errors that can be raised are:
#
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type VerifyEmail {
  possibleErrors: [PossibleErrorType]

  # Whether the email is verified.
  isVerified: Boolean
}

input VerifyEmailInput {
  # Token string that will be used to verify the email.
  token: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-1401: Invalid data.
# - KT-CT-1402: Unable to create account reminder.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAccountReminder {
  possibleErrors: [PossibleErrorType]

  # Account reminder.
  accountReminder: AccountReminder
}

type AccountReminder {
  # The reminder type.
  reminderType: AccountReminderTypes

  # Reminder content.
  content: String

  # When the reminder is due.
  dueAt: DateTime
}

# Contains reminder type choices for all territories.
enum AccountReminderTypes {
  AD_HOC
  DUNNING_REMINDER
  WITHDRAWAL_RECEIVED
  CHURN_PREVENTION
  PLANNED_INTERRUPTION
  PLANNED_INTERRUPTION_MEDICAL_DEPENDENCY
  MOVE_IN_MOVE_OUT_MANUAL_PROCESS
  MOVE_IN_CES_LIFE_SUPPORT_REQUIRED
  MOVE_IN_DEFAULT_PAYMENT_SCHEDULE_FAILED
  CANCEL_MOVE_OUT_UNABLE_TO_REINSTATE_FUTURE_AGREEMENTS
  SMETS2_DATA_REQUEST_FOLLOWUP
  COS_GAIN
  COS_LOSS
  MOVE_IN
  MOVE_OUT
  AMPERAGE_CHANGE
  CUSTOMER_DETAILS_CHANGE
  BILLING
  INDUSTRY_CUSTOMER_TRANSFER_DELAYED
  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_REJECTED
  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_CANCELLED
  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_OBJECTED
  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_CONFLICTING_PERIOD
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_REJECTED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_CANCELLED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTION_MISSING_ACK
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_WITHDRAWAL_REJECTED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTION_REJECTED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTION_WITHDRAWAL_REJECTED
  INDUSTRY_EXCEPTION_UNABLE_TO_PROCESS_ROLR
  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_GAIN_COMPLETION_OVERDUE
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_COMPLETED
  INDUSTRY_EXCEPTION_CHANGE_REQUEST_CANCELLATION_FAILED
  INDUSTRY_EXCEPTION_SITE_ACCESS_DETAILS_NOTIFICATION_REJECTED
  INDUSTRY_EXCEPTION_SITE_ACCESS_DETAILS_NOTIFICATION_MISSING_BUSINESS_ACCEPTANCE
  INDUSTRY_MANUAL_CUSTOMER_DETAILS_NOTIFICATION_REQUIRED
  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_MISSING_BUSINESS_ACCEPTANCE
  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_MISSING_MANDATORY_FIELDS
  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_INVALID_BILLING_ADDRESS
  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_REQUEST_SPECIAL_REASON
  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_REJECTED
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_MULTIPLE_ACCOUNTS_MATCHES
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_MULTIPLE_LIFE_SUPPORT_CONTACT_MATCHES
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_FAILED_TO_SEND
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_UNKNOWN_CONTACT
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_INVALID_PHONE
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_INVALID_CONTACT_METHOD
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_RECEIVED_FROM_NON_REGISTRATION_OWNER
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_CONTAINS_UNEXPECTED_DATA
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_REQUEST_REJECTED
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_REJECTED
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_REQUEST_MISSING_BUSINESS_ACCEPTANCE
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_MISSING_BUSINESS_ACCEPTANCE
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_REQUEST_MISSING_LIFE_SUPPORT_NOTIFICATION
  INDUSTRY_EXCEPTION_LIFE_SUPPORT_CONTACT_USER_REMOVED_FROM_ACCOUNT
  INDUSTRY_MANUAL_ACTION_REQUIRED
  INDUSTRY_MANUAL_LIFE_SUPPORT_NOTIFICATION_REQUIRED
  INDUSTRY_VIC_DRO_MANUAL_LIFE_SUPPORT_EXTENSION_REQUEST
  INDUSTRY_EXCEPTION_HOUSE_MOVE_ENROLMENT_SERVICE_ORDER_ALREADY_IN_PROGRESS
  INDUSTRY_EXCEPTION_HOUSE_MOVE_ENROLMENT_UNABLE_TO_COPY_LAST_METER_READING
  INDUSTRY_EXCEPTION_HOUSE_MOVE_ENROLMENT_CANNOT_CALCULATE_MOVE_IN_READING
  INDUSTRY_EXCEPTION_METER_POINT_ENROLMENT_INCOMPLETE_COULD_NOT_SEND_SERVICE_ORDER
  INDUSTRY_EXCEPTION_UNABLE_TO_ENROL_METER_POINT_INCOMPLETE_COULD_NOT_SEND_CHANGE_REQUEST
  INDUSTRY_EXCEPTION_UNABLE_TO_ENROL_METER_POINT_NEXT_SCHEDULED_READ_DATE_PAST
  INDUSTRY_EXCEPTION_RELINKING_OCCURRED_DURING_SDR_SYNC
  INDUSTRY_SEND_LIFE_SUPPORT_DE_REGISTRATION_FORM
  INDUSTRY_LIFE_SUPPORT_MANUAL_BEST_ENDEAVOUR_REQUIRED
  INDUSTRY_LIFE_SUPPORT_REVIEW_DEREGISTRATION
  INDUSTRY_LIFE_SUPPORT_REVIEW_POST_DEREGISTRATION_COMMS
  INDUSTRY_LIFE_SUPPORT_REVIEW_POST_DEREGISTRATION
  INDUSTRY_LIFE_SUPPORT_CANCEL_DEREGISTRATION_FAILED
  INDUSTRY_LIFE_SUPPORT_REGISTRATION_FOLLOW_UP_REQUIRED
  INDUSTRY_LIFE_SUPPORT_REVIEW_AFTER_CANCELLED_MOVE_OUT_FOR_NEXT_ACCOUNT
  INDUSTRY_LIFE_SUPPORT_REVIEW_ATTEMPTED_CANCELLED_MOVE_OUT_FOR_NEXT_ACCOUNT
  INDUSTRY_UNABLE_TO_CREATE_RECORD
  INDUSTRY_CHANGE_OF_SUPPLIER_DOUBLE_GAIN
  INDUSTRY_METER_POINT_MISSING_CUSTOMER_CLASSIFICATION
  INDUSTRY_READINGS_NOT_SENT
  INDUSTRY_WARNING_MESSAGE_RECEIVED
  SERVICE_ORDER_ACKNOWLEDGEMENT_OVERDUE
  SERVICE_ORDER_INITIAL_RESPONSE_OVERDUE
  SERVICE_ORDER_NOT_COMPLETED
  SERVICE_ORDER_CANCELLATION_REQUEST_REJECTED
  SERVICE_ORDER_PARTIALLY_COMPLETED
  SERVICE_ORDER_UNABLE_TO_CHARGE
  SERVICE_ORDER_REQUEST_REJECTED
  SERVICE_ORDER_UNSOLICITED_RECEIVED
  SERVICE_ORDER_UNSOLICITED_RECEIVED_DEENERGISED_METER_POINT
  SERVICE_ORDER_FAILED
  SERVICE_ORDER_CANCELLATION_FAILED
  SERVICE_ORDER_OTHER_JOB_ENQUIRY_CODE
  SMARTFLEX_DEVICE_INTEGRATION_POSTPONED
  SPECIAL_READ_FAILED
  SPECIAL_READ_CANCELLATION_FAILED
  SPECIAL_READ_OUTSTANDING
  SPECIAL_READ_WITH_ESTIMATE_READ_RECEIVED
  NETWORK_TARIFF_ONE_WAY_NOTIFICATION
  METER_EXCHANGE_ONE_WAY_NOTIFICATION
  METER_FAULT_AND_ISSUE_ONE_WAY_NOTIFICATION_ACCEPTED
  METER_FAULT_AND_ISSUE_ONE_WAY_NOTIFICATION_REJECTED
  NOTICE_OF_METERING_WORKS_ONE_WAY_NOTIFICATION
  SMETS2_HEALTH_CHECK
  SMETS2_IHD_HEALTH_CHECK
  CUSTOMER_REPORTED_SMART_METER_ISSUES
  D0010_CREATION_FAILURE
  ACCOUNT_COOL_OFF
  D0052_CREATION_FAILURE
  D0205_CREATION_FAILURE
  PLANNED_INTERRUPTION_ONE_WAY_NOTIFICATION
  PLANNED_INTERRUPTION_ONE_WAY_NOTIFICATION_REJECTED
  PLANNED_INTERRUPTION_NOTIFICATION_SENT_TO_LIFE_SUPPORT_CUSTOMER
  FIELDWORKS_ALLOCATE_NMI_MARKET_PARTICIPANTS_NOT_SET
  FIELDWORKS_BULK_DEPLOYMENT_JOURNEY_AUTO_CANCELLED
  FIELDWORKS_METER_FAULT_JOURNEY_AUTO_CANCELLED
  FIELDWORKS_MULTIPLE_OPEN_JOURNEYS_FOR_METER_POINT
  FIELDWORKS_UPLOAD_ATTACHMENT_TO_JEMENA_PORTAL
  FIELDWORKS_OBTAIN_SUPPLY_ABOLISHMENT_APPROVAL
  FIELDWORKS_JOURNEY_CANCELLED_DUE_TO_LIFE_SUPPORT_REGISTRATION
  FIELDWORKS_METER_FAULT_RECEIVED
  FIELDWORKS_MIRN_DISCOVERY_FAILED
  FIELDWORKS_CHANGE_RETAILER_FAILED
  FIELDWORKS_SERVICE_ORDER_PARTIALLY_COMPLETED
  FIELDWORKS_SERVICE_ORDER_FAILED
  COS_GAIN_REL_RETRIEVAL_FAILURE
  INDUSTRY_EXCEPTION_UNABLE_TO_ENROL_METER_POINT_INVALID_NMI_METER_STATUS
  FIELDWORKS_JOURNEY_ATTACHMENTS
  FIELDWORKS_SERVICE_ORDER_ATTACHMENTS
  FIELDWORKS_SERVICE_ORDER_STATUS_UPDATED
  FIELDWORKS_SERVICE_ORDER_COMPLETED
  FIELDWORKS_SERVICE_ORDER_UNABLE_TO_ACCESS_WITH_CUSTOMER_CONSULTATION
  FIELDWORKS_METER_FAULT_NCOM_COMMS_FAILED
  FIELDWORKS_MOVE_OUT_CANCELLED_WHILE_SUPPLY_ABOLISHMENT_IN_PROGRESS
  FIELDWORKS_SUPPLY_PERIOD_DOES_NOT_EXIST_FOR_METERPOINT
  FIELDWORKS_METERPOINT_IS_NOT_ACTIVE
  FIELDWORKS_EXPECTED_METER_POINT_NOT_CREATED
  FIELDWORKS_NEW_CONNECTION_DATA_NOT_VALID
  FIELDWORKS_NEW_CONNECTION_COMPLETION_REVIEW
  FIELDWORKS_EXPECTED_METER_READ_NOT_RECEIVED
  FIELDWORKS_EXPECTED_NTCS_NOT_RECEIVED
  FIELDWORKS_CONTACT_SO_RECIPIENT_TO_UPDATE_THE_SO_DETAILS
  FIELDWORKS_INVESTIGATE_WHETHER_JOURNEY_NEEDS_CONTINUATION
  FIELDWORKS_ASSIGN_METERING_COORDINATOR_STEP_FAILED
  FIELDWORKS_ASSIGN_METERING_PROVIDER_STEP_FAILED
  FIELDWORKS_OBTAIN_CUSTOMER_APPROVAL_BEFORE_PROGRESSING
  FIELDWORKS_MANUALLY_COMPLETE_CUSTOMER_MOVE_IN
  FIELDWORKS_ACCOUNT_CREATED_WITH_NO_EMAIL_ADDRESS
  FIELDWORKS_MAINTAIN_REGISTER_BILLABLE_OVERRIDE_FOR_UNSOLICITED_METER_CHANGES
  AUS_EMBEDDED_WATER_READING_FAILURE
  AUS_EMBEDDED_WATER_ESTIMATION_REQUIRED_FOR_SKIPPED_READING
  AUS_VIC_SHAREDFUSE_NOTIFICATION
  AUS_INDUSTRY_CUSTOMER_OWN_READING_NOT_SENT
  JPN_SUPPLY_DETAILS_UPDATE_CONFIRMATION
  JPN_READINGS_NOT_RECEIVED
  JPN_FINAL_READING_OUTSIDE_AGREEMENT
  JPN_CONFIRMATION_OF_RELOCATION
  JPN_SHORT_TERM_MOVE_IN_REJECTION
  JPN_SUPPLY_POINT_FAILS_CAN_SUPPLY_CHECK
  JPN_CALL_FOR_DUNNING_CAMPAIGN
  JPN_CONFIRM_PAYMENT_FOR_DUNNING_CAMPAIGN
  JPN_BILLING_FIX_INVALID_CHARGE_DATA
  NZ_SOLAR_METER_CHANGE
  NZ_DUNNING
  NZ_SWITCHING_WITHDRAWAL
  NZ_BILLING_QUERY
  NZ_VACANT_PROPERTY
  NZ_METERING_QUERY
  DUNNING_OUTBOUND_REMINDER_CALL
  DUNNING_BEST_ENDEAVOURS_CALL
  DUNNING_DISCONNECTION_OUTBOUND_REMINDER_CALL
  DUNNING_DISCONNECTION_DE_ENERGISATION_ASSESSMENT
  DUNNING_MANDATORY_NOTICE_EMAIL_FAILURE
  DUNNING_DISCONNECTION_MANDATORY_NOTICE_EMAIL_FAILURE
  DUNNING_VACANT_CONSUMPTION_DE_ENERGISATION_ASSESSMENT
  DUNNING_REMINDER_CALL
  DUNNING_REMINDER_DISCONNECTION_APPLICATION
  DUNNING_REMINDER_PAYMENT_MADE
  DUNNING_REMINDER_FUTURE_PAYMENT
  NON_ENERGY_PAYMENT_CALL_REMINDER
  PAYMENTS_FAILED_REPAYMENT
  PAYMENT_PLAN
  PAYMENT_PLAN_MISSED_INSTALMENT
  ACTIVATE_PAYMENT_CANCELLATION_STOPPED
  POST_HARDSHIP_CANCELLATION
  PAYMENT_PLAN_HARDSHIP_COMPLETION
  PAYMENT_PLAN_HARDSHIP_COMPLETION_WORKFLOW_CANCELLED
  HARDSHIP_GRADUATION_ASSESSMENT
  HARDSHIP_REMOVAL_ASSESSMENT
  PAYMENT_INSTRUCTION_FAILED
  HARDSHIP_NO_PAYMENT_PLAN
  DISCONNECTION_MANDATORY_NOTICE_EMAIL_FAILURE
  DISCONNECTION_MANDATORY_NOTICE_SMS_FAILURE
  INDUSTRY_EXCEPTION_STANDING_DATA_PROPERTIES_ADDRESS_FAILED_TO_UPDATE
  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_TERMINATE
  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_CREATE
  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_UPDATE
  MARKET_SUPPLY_EXCEPTION_MISSING_ACCOUNT_QUOTED_PRODUCT
  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_REVERSE_TERMINATION
  GAS_EXCEPTION_SITE_ACCESS_DETAILS_RECEIVED_FOR_NON_EXISTENT_METER
  GAS_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_FAILED
  GAS_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_FAILED
  GAS_EXCEPTION_SITE_ACCESS_DETAILS_NOTIFICATION_FAILED
  GAS_EXCEPTION_SITE_ADDRESS_DETAILS_NOTIFICATION_FAILED
  GAS_EXCEPTION_METER_DATA_VERIFY_REQUEST_FAILED
  GAS_EXCEPTION_METER_DATA_VERIFY_RESPONSE_OVERDUE
  GAS_EXCEPTION_METER_DATA_VERIFY_RESPONSE_NO_CHANGE_WITH_EXPLANATION
  GAS_EXCEPTION_METER_DATA_VERIFY_RESPONSE_WITHOUT_REVISED_READ
  GAS_NOTIFICATION_CHANGE_OF_SITE_ADDRESS
  INDUSTRY_EXCEPTION_NEXT_SCHEDULED_READ_DATE_TOO_FAR_IN_FUTURE
  GAS_EXCEPTION_CUSTOMER_TRANSFER_CANCELLED
  GAS_EXCEPTION_CUSTOMER_TRANSFER_REJECTED
  GAS_MANUAL_SERVICE_ORDER_REQUIRED_FOR_ENROLMENT
  GAS_READING_REMOVED_INSTALLED_RECEIVED
  GAS_UNKNOWN_CUSTOMER_CLASSIFICATION_CODE_RECEIVED
  BILLING_AMENDED_METER_READ_BASIC
  BILLING_AMENDED_METER_READ_GAS
  BILLING_AMENDED_METER_READ_INTERVAL_LEGACY
  BILLING_AMENDED_METER_READ_INTERVAL
  BILLING_AMENDED_METER_READ_PRE_MIGRATION
  BILLING_AMENDED_METER_READ_CES_ELEC_BASIC
  BILLING_AMENDED_METER_READ_CES_ELEC_INTERVAL
  BILLING_REGISTER_REPLACED_OR_REMOVED
  OBSOLETE_BILLING_AMENDED_STANDING_DATA_REGISTER_DELETED
  OBSOLETE_BILLING_AMENDED_STANDING_DATA_REGISTER_CHANGED
  BILLING_CUSTOMER_SELF_READ_RECEIVED
  BILLING_MISSING_READ
  SA_CONCESSION_STATEMENT_CLOSED
  BILLING_BACKDATED_CONCESSION_RECEIVED
  BILLING_BACKDATED_UMS_RECORD_RECEIVED
  BILLING_AMENDED_INTERVAL_DATA_RECEIVED_CAUSING_OVERCHARGE
  BILLING_QUOTED_NTC_DOES_NOT_ALIGN
  FINAL_BILLING_UNABLE_TO_BILL
  MANDATORY_COMMS_NOT_DELIVERED
  CONTRACT_COMMS_NOT_DELIVERED
  MOVE_IN_COMMS_NOT_DELIVERED
  SMART_PREPAY_TOP_UP_UTRN
  SMART_PREPAY_TOP_UP_MULTIPLE_ACTIVE_PROCESSES
  SMART_PREPAY_TOP_UP_FAILURE
  SMART_PREPAY_ADD_DEBT_FAILURE
  SMART_PREPAY_NEED_TO_ADJUST_DEBT
  SMART_METER_MODE_CHANGE_UNSUPPORTED
  HELD_STATEMENT
  AUTOMATED_BILLING_DISABLED
  SOLAR_EXPORT_CREDITS_EXCESS
  ASSIGNED_TO_CREDIT_TEAM
  WORKFLOW_STEP_FAILED
  WORKFLOW_STEP_ERRORED
  WORKFLOW_CANCELLATION_FAILED
  KMT
  SOLR_FINAL_BILL_REMINDER
  COS_GAIN_MIGRATION_ECOES_METER_MISMATCH
  ACCOUNT_MIGRATION_SYNC_XOSERVE_METER_MISMATCH
  SMART_CHANGE_OF_TENANCY_REQUEST_FAILED
  SMART_CHANGE_OF_TENANCY_IN_PROGRESS
  AGREEMENT_REVOKED
  UNSUPPORTED_PAYMENT_DAY
  UNSUPPORTED_FEATURE
  EMBEDDED_NETWORK_EXCEPTION_PARENT_METER_POINT_LOST_OR_LOSING
  EMBEDDED_NETWORK_EXCEPTION_PARENT_METER_POINT_RECEIVED_LIFE_SUPPORT_NOTIFICATION
  EMBEDDED_NETWORK_EXCEPTION_PARENT_METER_POINT_RECEIVED_DANGEROUS_LIFE_SUPPORT_NOTIFICATION
  EMBEDDED_NETWORK_EXCEPTION_DISTRIBUTOR_OWNED_PARENT_LIFE_SUPPORT_RECORD
  EMBEDDED_NETWORK_ALL_CHILD_LIFE_SUPPORT_RECORDS_ARE_DEREGISTERED
  SCHEDULED_BILLING_ADDRESS_UPDATE
  SCHEDULED_OCCUPIER_PACK_SEND
  PROPERTY_ADDRESS_NEEDS_UPDATE
  FRA_ACTIVATION_PROCESS_INCEPTION_CHECKS
  FRA_ACTIVATION_PROCESS_SCHEDULE_SITEWORKS
  FRA_ACTIVATION_PROCESS_GAS_PROVIDER_CHANGE_REQUEST
  FRA_ACTIVATION_PROCESS_PRM_ELIGIBILITY
  FRA_ACTIVATION_PROCESS_AWAITING_SWITCH_READINGS
  FRA_ELEC_ACTIVATION_PROCESS_WRONG_SWITCH_READINGS_FOR_PROVIDER_CALENDAR_TEMPORAL_CLASSES
  FRA_ACTIVATION_PROCESS_COMMANDER_SOUSCRIPTION
  FRA_ACTIVATION_PROCESS_AWAITING_SWITCH_IN_CONFIRMATION
  FRA_TERMINATION_REQUEST_ERRORED
  FRA_ENERGY_CHEQUE_UNKNOWN
  FRA_FSL
  COMMS_TO_BE_PRINTED
  FLOW_FILE_ERROR
  NEW_PSR_ADDED_TO_PREPAY_ACCOUNT
  PSR_IMPORT_COULD_NOT_IDENTIFY_ACCOUNT_USER
  MAIL_RETURNED
  MAIL_FAILED
  DUPLICATE_CARD_FINGERPRINTs
  WATER_METER_READING_ISSUE
  WATER_ACCOUNT_REVERSION
  DEU_SWICHTING_PROCESS_FAILED
  DEU_METER_READINGS
  DEU_MASTER_DATA_SYNCHRONISATION
  DEU_MASTER_DATA_UPDATE
}

input CreateAccountReminderInput {
  # The account number.
  accountNumber: String!

  # The reminder type.
  reminderType: AccountReminderTypes!

  # Reminder content.
  content: String!

  # When the reminder is due.
  dueAt: DateTime!
}

# Create an account reference.
#
# The possible errors that can be raised are:
#
# - KT-CT-4123: Unauthorized.
# - KT-CT-8310: Invalid data.
# - KT-CT-8311: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAccountReference {
  possibleErrors: [PossibleErrorType]
  accountReference: AccountReferenceType
}

# The input type for the account reference.
input AccountReferenceInput {
  # The account number.
  accountNumber: String!

  # The namespace for the reference.
  namespace: String!

  # The reference value.
  value: String!
}

# Update a reference for a particular account and namespace.
#
# The possible errors that can be raised are:
#
# - KT-CT-4123: Unauthorized.
# - KT-CT-8310: Invalid data.
# - KT-CT-8311: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateAccountReference {
  possibleErrors: [PossibleErrorType]
  accountReference: AccountReferenceType
}

# Delete a reference for a particular account and namespace.
#
# The possible errors that can be raised are:
#
# - KT-CT-4123: Unauthorized.
# - KT-CT-8310: Invalid data.
# - KT-CT-8312: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type DeleteAccountReference {
  possibleErrors: [PossibleErrorType]
  accountReference: DeleteAccountReferenceType
}

type DeleteAccountReferenceType {
  # The namespace associated with the removed AccountReference
  namespace: String!
}

input DeleteAccountReferenceInput {
  # The account number associated with the removed AccountReference.
  accountNumber: String!

  # The namespace associated with the removed AccountReference
  namespace: String!
}

# Create an external account event.
#
# The possible errors that can be raised are:
#
# - KT-CT-7123: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateExternalAccountEvent {
  possibleErrors: [PossibleErrorType]

  # The new event data.
  event: ExternalAccountEvent
}

type ExternalAccountEvent {
  id: ID!
  eventType: String!
  category: String!
  subcategory: String!
  description: String
  content: JSONString
}

input CreateExternalAccountEventInput {
  # The number of the account that the event should be created for.
  accountNumber: String!

  # The category of the event.
  category: ExternalAccountEventCategory!

  # The subcategory of the event.
  subcategory: ExternalAccountEventSubCategory

  # A human-readable description of the event.
  description: String

  # An array of content data associated with the event.
  content: [ExternalAccountEventContent]!
}

# Enum of allowable event type categories for external account events.
enum ExternalAccountEventCategory {
  COMMUNICATIONS
  WEB
  MOBILE
  MESSAGING
  DEBT
}

# Enum of allowable event type subcategories for external account events.
enum ExternalAccountEventSubCategory {
  TELEPHONE
  EMAIL
  SMS
  PRINT
  PUSH_NOTIFICATION
  SOCIAL_MEDIA
  FEEDBACK
  WHATSAPP
  CLICK_TO_CALL
  DUNNING
}

# A piece of content associated with an external account event.
input ExternalAccountEventContent {
  # A human-readable description of the content.
  description: String!

  # The content type of the content.
  contentType: ExternalAccountEventContentType!

  # The value of the content.
  value: String!
}

# Enum of allowable content types for external account events.
#
# The content type field is used to determine how to display the content in the account event
# description.
enum ExternalAccountEventContentType {
  PLAINTEXT
  LINK
  HTML
  S3
}

# Add credits to an account.
#
# The possible errors that can be raised are:
#
# - KT-CT-5315: Invalid data.
# - KT-CT-5314: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAccountCredit {
  possibleErrors: [PossibleErrorType]
  accountCredit: AccountCreditType
}

# The input type for the account credit.
input CreateAccountCreditInput {
  # The account number.
  accountNumber: String!

  # The net amount of the credit to be created.
  netAmount: Int!

  # The gross amount of the credit to be created.
  grossAmount: Int!

  # The sales tax amount of the credit to be created.
  salesTaxAmount: Int!

  # Any extra data that will be associated with account credit.
  metadata: JSONString

  # Optional short note about account credit.
  note: String

  # The reason why the credit is added to the account.
  reason: AccountCreditReasonType!
}

# The possible errors that can be raised are:
#
# - KT-CT-5316: Invalid data.
# - KT-CT-5311: The credit reason with the requested code is deprecated.
# - KT-CT-5312: The credit reason with the requested code does not exist.
# - KT-CT-5313: An error occurred whilst posting the credit.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type PostCredit {
  possibleErrors: [PossibleErrorType]

  # Posted account credit.
  credit: Credit
}

input PostCreditInput {
  # The account number.
  accountNumber: String!

  # The net amount of the credit to be posted. Amount should be posted in the smallest unit of currency.
  netAmount: Int!

  # The tax amount of the credit to be posted. Amount should be posted in the smallest unit of currency.
  taxAmount: Int!

  # Optional short note about the credit, to be displayed to the user.
  displayNote: String

  # Optional short note about the credit, to be displayed to internal systems.
  note: String

  # The reason why the credit is posted. This should be a valid credit reason code.
  reason: String!

  # The ID of the ledger where the credit will be posted.
  ledgerId: ID!
}

# Add charges to an account.
#
# The possible errors that can be raised are:
#
# - KT-CT-5211: The charge reason with the requested code is deprecated.
# - KT-CT-5212: The charge reason with the requested code does not exist.
# - KT-CT-5213: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAccountCharge {
  possibleErrors: [PossibleErrorType]
  accountCharge: AccountChargeType
}

# The input type for the account charge.
input CreateAccountChargeInput {
  # The account number.
  accountNumber: String!

  # The gross amount of the charge to be added.
  grossAmount: Int!

  # Any extra data that will be associated with account charge.
  metadata: JSONString

  # Optional short note about account charge for internal use.
  note: String

  # Optional short note about account charge for customer display.
  displayNote: String

  # The reason why the charge is added to the account. This should be a valid charge reason code.
  reason: String!
}

# Trigger balance transfer between accounts.
#
# The possible errors that can be raised are:
#
# - KT-CT-3822: Unauthorized.
# - KT-CT-3823: Unauthorized.
# - KT-CT-9701: Balance transfer to same account is not allowed.
# - KT-CT-9702: Balance transfer is not support for debit account with Zero balance.
# - KT-CT-9703: Balance transfer is not supported for debit account.
# - KT-CT-9704: Balance transfer amount should be non-zero.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type TransferLedgerBalance {
  possibleErrors: [PossibleErrorType]

  # Balance transfer details.
  balanceTransfer: AccountBalanceTransferType
}

type AccountBalanceTransferType {
  # Balance transfer ID.
  id: ID

  # Debit details.
  accountCharge: AccountChargeType

  # Credit details.
  accountCredit: AccountCreditType

  # The reason for the balance transfer.
  reason: String
}

input TransferLedgerBalanceInputType {
  # Account's ledger from which the requested amount is debited.
  sourceAccountLedger: AccountLedgerInput!

  # Account's ledger to which the requested amount is credited.
  targetAccountLedger: AccountLedgerInput!

  # The amount ( in lowest unit ) to transfer. If the amount is negative,the effect is reversed  (the source ledger's balance increases and the destination ledger's balance decreases).
  amount: Int!

  # Optional short note about transfer reason.
  note: String
}

input AccountLedgerInput {
  # The account number.
  accountNumber: ID!

  # The ledger id for the account.
  ledgerId: ID!
}

type FormSubmissionOuput {
  id: Int
  content: JSONString
  errors: [SerializerFieldErrorsType]
}

type SerializerFieldErrorsType {
  field: String
  errors: [ErrorTypeUnion!]
}

union ErrorTypeUnion = SerializerErrorType | SerializerFieldErrorsType

type SerializerErrorType {
  message: String
  code: String
}

input FormSubmissionInput {
  #
  accountNumber: String!

  # Form type
  formType: FormType = null

  # Form content
  content: JSONString!
}

# An enumeration.
enum FormType {
  # Covid-19 Financial Energy Assessment
  COVID_19_FINANCIAL_ENERGY_ASSESSMENT

  # Covid-19 Gas Prices Financial Energy Assessment
  COVID_19_GAS_PRICES_FINANCIAL_ENERGY_ASSESSMENT
}

type MasqueradeAuthentication {
  # A Kraken Token that can be used to authenticate to the API, masquerading as the desired user.
  token: String

  # A list of any errors that occurred while running this mutation.
  errors: [ErrorType]
}

# Mutation to generate a pre-signed token.
#
# The pre-signed, expiring and opaque tokens will be swapped
# for a limited scope JWT (Kraken Token).
#
# The possible errors that can be raised are:
#
# - KT-CT-1128: Unauthorized.
# - KT-CT-1120: The Kraken Token has expired.
# - KT-CT-1131: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type GeneratePreSignedToken {
  possibleErrors: [PossibleErrorType]
  token: String
  tokenExpiryDatetime: DateTime
  scope: PreSignedTokenScope
}

#
#     Choices class for the pre-signed expiring tokens.
#
#     These choices must have a certain format:
#
#     {ACTION-VERB}_{DEFINING-NOUN}
#
#     They should start with an action verb. It should be a single word.
#     The action verb enables the account user to do the thing (defining noun)
#     that comes after the action verb. Together they represent a task.
#
#     The defining noun could be longer than a single word.
#     Preferably, it should be kept short and simple as much as possible.
#
enum PreSignedTokenScope {
  # Scope that enables account user to submit meter readings.
  SUBMIT_METER_READINGS

  # Scope that enables account user to submit customer feedback.
  SUBMIT_CUSTOMER_FEEDBACK

  # Scope that enables account user to book smart meter appointments.
  BOOK_SMART_METER_APPOINTMENTS

  # Edit Customer Marketing Preference
  EDIT_CUSTOMER_MARKETING_PREFERENCE

  # Scope that enables account user to join campaigns.
  JOIN_CAMPAIGNS

  # Scope that enables account user to join campaign events.
  JOIN_CAMPAIGN_EVENTS

  # Scope that enables account user to visit campaign dashboard.
  VIEW_CAMPAIGN_DASHBOARDS

  # Scope that enables account user to visit detailed property usage pages.
  VIEW_DETAILED_USAGE

  # Scope that enables account user to redeem loyalty points
  REDEEM_LOYALTY_POINTS

  # Scope that enables account user to generate a renewal quote and renew agreements.
  MANAGE_ACCOUNT_RENEWALS

  # Scope that enables account user to checkout a quote (validate terms & conds and provide a payment detail).
  CHECKOUT_QUOTE

  # Scope that enables account user to update their blackhole email address.
  UPDATE_BLACKHOLE_EMAIL

  # Update Sensitive Customer Information
  UPDATE_SENSITIVE_CUSTOMER_INFORMATION

  # Scope that enables account user to accept goods quotes and process goods purchases.
  MANAGE_GOODS_PURCHASES

  # Scope that enables account user to report a property move-out.
  REPORT_MOVE_OUT

  # Scope that enables account user to accept the terms and conditions for a product.
  ACCEPT_TERMS_AND_CONDITIONS

  # Scope that enables account user to do a self-serve product switch through the Dashboard.
  MANAGE_PRODUCT_SWITCH

  # Scope that enables account user to manage security deposit payments for business accounts.
  MANAGE_BUSINESS_SECURITY_DEPOSIT
}

# Invalidate a previously issued expiring/pre-signed token.
#
# This mutation can be used to invalidate the token itself.
#
# To invalidate tokens issued to a particular user, use
# InvalidatePreSignedTokensForUser mutation.
#
# The possible errors that can be raised are:
#
# - KT-CT-1129: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type InvalidatePreSignedToken {
  possibleErrors: [PossibleErrorType]
  token: PreSignedToken
}

# A pre-signed, expiring and opaque tokens that can be swapped for a limited scope JWT (Kraken Token).
type PreSignedToken {
  key: String!

  # The scope that the token will grant to the account user.
  scope: ExpiringTokenScope!
  isValid: Boolean
}

# An enumeration.
enum ExpiringTokenScope {
  # Scope that enables account user to submit meter readings.
  SUBMIT_METER_READINGS

  # Scope that enables account user to submit customer feedback.
  SUBMIT_CUSTOMER_FEEDBACK

  # Scope that enables account user to book smart meter appointments.
  BOOK_SMART_METER_APPOINTMENTS

  # Edit Customer Marketing Preference
  EDIT_CUSTOMER_MARKETING_PREFERENCE

  # Scope that enables account user to join campaigns.
  JOIN_CAMPAIGNS

  # Scope that enables account user to join campaign events.
  JOIN_CAMPAIGN_EVENTS

  # Scope that enables account user to visit campaign dashboard.
  VIEW_CAMPAIGN_DASHBOARDS

  # Scope that enables account user to visit detailed property usage pages.
  VIEW_DETAILED_USAGE

  # Scope that enables account user to redeem loyalty points
  REDEEM_LOYALTY_POINTS

  # Scope that enables account user to generate a renewal quote and renew agreements.
  MANAGE_ACCOUNT_RENEWALS

  # Scope that enables account user to checkout a quote (validate terms & conds and provide a payment detail).
  CHECKOUT_QUOTE

  # Scope that enables account user to update their blackhole email address.
  UPDATE_BLACKHOLE_EMAIL

  # Update Sensitive Customer Information
  UPDATE_SENSITIVE_CUSTOMER_INFORMATION

  # Scope that enables account user to accept goods quotes and process goods purchases.
  MANAGE_GOODS_PURCHASES

  # Scope that enables account user to report a property move-out.
  REPORT_MOVE_OUT

  # Scope that enables account user to accept the terms and conditions for a product.
  ACCEPT_TERMS_AND_CONDITIONS

  # Scope that enables account user to do a self-serve product switch through the Dashboard.
  MANAGE_PRODUCT_SWITCH

  # Scope that enables account user to manage security deposit payments for business accounts.
  MANAGE_BUSINESS_SECURITY_DEPOSIT
}

# Input type for the InvalidatePreSignedToken mutation.
input InvalidatePreSignedTokenInput {
  token: String!
}

# Invalidate pre-signed tokens previously issued to a particular user.
#
# This mutation can invalidate all pre-signed tokens issued to a
# customer, or only tokens of a given scope.
#
# The possible errors that can be raised are:
#
# - KT-CT-1129: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type InvalidatePreSignedTokensForUser {
  possibleErrors: [PossibleErrorType]
  tokens: [PreSignedToken]
}

# Input type for the InvalidatePreSignedTokensForUser mutation.
input InvalidatePreSignedTokensForUserInput {
  # The email address of the user whose tokens should be invalidated.
  email: String!

  # The scope of the token to invalidate.  If this argument is not specified, all pre-signed tokens issued to the user are invalidated.
  scope: PreSignedTokenScope = null
}

type RequestPasswordResetOutputType {
  # The email that requested a password reset email.
  email: String
}

# Input type for the RequestPasswordReset mutation.
input RequestPasswordResetInput {
  # The email requesting a password reset email.
  email: String!
}

type ResetPasswordMutationPayload {
  errors: [SerializerFieldErrorsType]
  clientMutationId: String
}

input ResetPasswordMutationInput {
  password: String!
  userId: String!
  token: String!
  clientMutationId: String
}

type ResetUserPasswordOutput {
  # True if the password update was successful, false otherwise.
  passwordUpdated: Boolean

  # A list of which password validations the new password failed against if applicable.
  failureReasons: [String]
}

input ResetUserPasswordInput {
  # The new password.
  newPassword: String!

  # A base64 bytestring representing the user's unique id.
  userId: String!

  # The token from the presigned url.
  token: String!
}

# The unifying approach used to get a Kraken token (JWT: JSON Web Token) with
# different types of input.
#
# The currently supported inputs are:
# - account user email/password combination
# - account user API key
# - organization live secret key
# - pre-signed key
# - refresh token
#
# The possible errors that can be raised are:
#
# - KT-CT-1135: Invalid data.
# - KT-CT-1134: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type ObtainKrakenJSONWebToken {
  possibleErrors: [PossibleErrorType]

  # The Kraken Token.  Can be used in the `Authorization` header for subsequent calls to the API to access protected resources.
  token: String!

  # The body payload of the Kraken Token.  The same information can be obtained by using JWT decoding tools on the value of the `token` field.
  payload: GenericScalar!

  # A token that can be used in a subsequent call to `obtainKrakenToken` to get a new Kraken Token with the same access conditions after the previous one has expired.
  refreshToken: String

  # A Unix timestamp representing the point in time at which the refresh token will expire.
  refreshExpiresIn: Int
}

# The input type for obtaining a Kraken Token (JWT).
input ObtainJSONWebTokenInput {
  # Email address of the account user. Use with 'password' field.
  email: String

  # Password of the account user. Use with 'email' field.
  password: String

  # API key of the account user. Use standalone, don't provide a second input field.
  APIKey: String

  # Live secret key of an third-party organization. Use standalone, don't provide a second input field.
  organizationSecretKey: String

  # Short-lived, temporary key (that's pre-signed). Use standalone, don't provide a second input field.
  preSignedKey: String

  # The refresh token that can be used to extend the expiry claim of a Kraken token. Use standalone, don't provide a second input field.
  refreshToken: String
}

type ForceReauthentication {
  # Reports whether the mutation applied successfully.  Should always be 'true'.
  tokensInvalidated: Boolean!

  # The time at which forced reauthentication is effective.  Kraken and refresh tokens issued before this time will be invalid.
  effectiveAt: DateTime!
}

# The input type for repudiating previously issued Kraken Tokens and refresh tokens.
input ForceReauthenticationInput {
  # Also force third-party applications you have authorized to use your account to reauthenticate.
  includeThirdParties: Boolean!
}

# Obtain a long-lived refresh token.
#
# This mutation is limited to authorized third-party organizations only.
#
# Account users can only generate short-lived refresh tokens.
#
# The short-lived refresh tokens (for account users) can be obtained from
# the 'refreshToken' field in 'obtainKrakenToken' mutation.
#
# The possible errors that can be raised are:
#
# - KT-CT-1120: The Kraken Token has expired.
# - KT-CT-1121: Please use Kraken Token to issue long-lived refresh tokens.
# - KT-CT-1132: Unauthorized.
# - KT-CT-1122: Long-lived refresh tokens can only be issued for account users.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type ObtainLongLivedRefreshToken {
  possibleErrors: [PossibleErrorType]
  refreshToken: String
  refreshExpiresIn: Int!
}

# The input type for obtaining a long-lived refresh token.
input ObtainLongLivedRefreshTokenInput {
  # The Kraken Token that will be used to generate the long-lived refresh token.
  krakenToken: String!
}

# Invalidate a previously issued refresh token.
#
# This mutation can be used to invalidate the token itself.  To
# invalidate tokens issued to a particular user, use
# InvalidateRefreshTokensForUser.
#
# The possible errors that can be raised are:
#
# - KT-CT-1130: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type InvalidateRefreshToken {
  possibleErrors: [PossibleErrorType]
  token: RefreshToken
}

# An opaque token that can be used to renew a Kraken Token.
type RefreshToken {
  key: String!

  # The datetime when the token will expire.
  expiryDt: DateTime!
  isValid: Boolean
}

# Input type for the InvalidateRefreshToken mutation.
input InvalidateRefreshTokenInput {
  refreshToken: String!
}

# Invalidate refresh tokens previously issued to a particular user.
#
# This mutation will invalidate all refresh tokens issued to a
# customer.
#
# The possible errors that can be raised are:
#
# - KT-CT-1128: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type InvalidateRefreshTokensForUser {
  possibleErrors: [PossibleErrorType]
  tokens: [RefreshToken]
}

# Input type for the InvalidateRefreshTokensForUser mutation.
input InvalidateRefreshTokensForUserInput {
  # The email address of the user whose tokens should be invalidated.
  email: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-1145: Account/user details do not match.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type VerifyIdentity {
  possibleErrors: [PossibleErrorType]

  # An expiring token that can be used to request to update the user's email address.
  token: String!
}

input VerifyIdentityInput {
  # The number of the account belonging to the user (e.g. A-12345678).
  accountNumber: String!

  # The user's full name.
  fullName: String!

  # The first line of the user's address (this could be the energy supply property address or the billing address on the account).
  firstLineOfAddress: String!

  # The user's postcode (this could be the postcode of the energy supply property address or of the billing address on the account).
  postcode: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-7801: Received an invalid operationsTeamId.
# - KT-CT-7802: The external identifier already exists.
# - KT-CT-7805: Too many tags associated with this API Exception.
# - KT-CT-7806: Cannot create duplicate tags for the same API exception.
# - KT-CT-7811: Received an invalid assignedUserId.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAPIException {
  possibleErrors: [PossibleErrorType]

  # The created APIException.
  apiException: APIExceptionType
}

input CreateAPIExceptionInput {
  # External identifier mapping an entity on the client's database.
  externalIdentifier: String!

  # The resolution status. Defaults to UNASSIGNED if not provided.
  resolutionStatus: APIExceptionResolutionStatus = null

  # The resolution type. Defaults to UNASSIGNED if not provided.
  resolutionType: APIExceptionResolutionType = null

  # The priority. Defaults to LOW if not provided.
  priority: APIExceptionPriority = null

  # Contextual information about the exception, if any.
  context: JSONString

  # The API client channel where the exception was triggered from.
  channel: String!

  # The ID of the user assigned to handle this exception.If no user is provided, no user will be assigned to the exception.
  assignedUserId: Int

  # The ID of an operations team to handle this exception. If no team is provided, no team will be assigned to the exception.
  operationsTeamId: Int

  # Tags associated with this exception if any.
  tags: [APIExceptionTags]

  # Category associated with this exception. Uses the default category if not provided.
  category: APIExceptionCategories = UNKNOWN

  # The account number associated with the exception, if available.
  accountNumber: ID

  # The user ID associated with the exception, if available.
  userId: Int

  # The customer contact associated with the exception, if available.
  customerContact: String

  # The supply point identifier associated with the exception, if available.
  supplyPointIdentifier: String

  # The key date associated with the exception, if available.
  keyDate: Date
}

# The possible errors that can be raised are:
#
# - KT-CT-7804: No fields present in the input for updating the APIException.
# - KT-CT-7803: Received an invalid apiExceptionId.
# - KT-CT-7809: Update results in no changes to API Exception.
# - KT-CT-7805: Too many tags associated with this API Exception.
# - KT-CT-7806: Cannot create duplicate tags for the same API exception.
# - KT-CT-7801: Received an invalid operationsTeamId.
# - KT-CT-7811: Received an invalid assignedUserId.
# - KT-CT-7812: Support user is inactive.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateAPIException {
  possibleErrors: [PossibleErrorType]

  # The updated APIException.
  apiException: APIExceptionType
}

input UpdateAPIExceptionInput {
  # The ID of the API Exception that will be updated.
  id: Int!

  # The new resolution status. If none is provided, the field won't be updated.
  resolutionStatus: APIExceptionResolutionStatus = null

  # The new resolution type. If none is provided, the field won't be updated.
  resolutionType: APIExceptionResolutionType = null

  # The new priority. If none is provided, the field won't be updated.
  priority: APIExceptionPriority = null

  # The new context. If none is provided, the field won't be updated. This will completely replace the existing context by the new one.
  context: JSONString

  # The new category. If none is provided, the field won't be updated.
  category: APIExceptionCategories = null

  # The updated list of tags. If none is provided, the field won't be updated.
  tags: [APIExceptionTags]

  # The new key date. If none is provided, the field won't be updated.
  keyDate: Date

  # The ID of the user assigned to handle this exception.If no user is provided, no user will be assigned to the exception.
  assignedUserId: Int

  # The ID of an operations team to handle this exception. If no team is provided, no team will be assigned to the exception.
  operationsTeamId: Int
}

# The possible errors that can be raised are:
#
# - KT-CT-7803: Received an invalid apiExceptionId.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAPICall {
  possibleErrors: [PossibleErrorType]

  # The created APICall.
  apiCall: APICallType
}

input CreateAPICallInput {
  # The correlation id header from the HTTP request.
  correlationId: String!

  # The name of the operation associated with this call.
  operationName: String!

  # The input data provided to the API, if any.
  inputData: JSONString

  # The response returned by the API.
  response: JSONString!

  # Any optional useful context involved in the API call.
  context: JSONString

  # The ID of the associated API exception, if any.
  apiExceptionId: Int
}

# The possible errors that can be raised are:
#
# - KT-CT-7803: Received an invalid apiExceptionId.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAPIExceptionEvent {
  possibleErrors: [PossibleErrorType]

  # The created APIExceptionEvent.
  apiExceptionEvent: APIExceptionEventType
}

input CreateAPIExceptionEventInput {
  # The event type.
  eventType: String!

  # The event category.
  category: String!

  # Any useful event description.
  description: String!

  # Any optional useful context involved in the event.
  context: JSONString

  # The ID of the associated API exception, if any.
  apiExceptionId: Int
}

# The possible errors that can be raised are:
#
# - KT-CT-7803: Received an invalid apiExceptionId.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAPIExceptionNote {
  possibleErrors: [PossibleErrorType]

  # The created APIExceptionNote.
  apiException: APIExceptionType
}

input CreateAPIExceptionNoteInput {
  # The body of the note.
  body: String!

  # The ID of the associated API exception.
  apiExceptionId: ID!
}

# The possible errors that can be raised are:
#
# - KT-CT-7807: Received an invalid apiExceptionNoteId.
# - KT-CT-7808: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateAPIExceptionNote {
  possibleErrors: [PossibleErrorType]

  # The updates APIExceptionNote.
  apiException: APIExceptionType
}

input UpdateAPIExceptionNoteInput {
  # The body of the note.
  body: String!

  # The ID of the API Exception note being updated.
  apiExceptionNoteId: ID!
}

type UpdateAccountUserMutationPayload {
  givenName: String
  familyName: String
  pronouns: String
  mobile: String
  email: String
  dateOfBirth: Date
  landline: String
  errors: [ErrorType]
  clientMutationId: String
}

input UpdateAccountUserMutationInput {
  givenName: String
  familyName: String
  pronouns: String
  mobile: String
  email: String
  dateOfBirth: Date
  landline: String
  clientMutationId: String
}

# Update the account user comms preferences.
type UpdateAccountUserCommsPreferencesMutationPayload {
  isOptedInToClientMessages: Boolean
  isOptedInToOfferMessages: Boolean
  isOptedInToRecommendedMessages: Boolean
  isOptedInToUpdateMessages: Boolean
  isOptedInToThirdPartyMessages: Boolean
  isOptedInMeterReadingConfirmations: Boolean
  isOptedInToSmsMessages: Boolean
  isUsingInvertedEmailColours: Boolean
  fontSizeMultiplier: Float
  emailFormat: String
  preferredHoldMusic: String
  errors: [ErrorType]
  commsPreferences: AccountUserCommsPreferences
  clientMutationId: String
}

input UpdateAccountUserCommsPreferencesMutationInput {
  isOptedInToClientMessages: Boolean
  isOptedInToOfferMessages: Boolean
  isOptedInToRecommendedMessages: Boolean
  isOptedInToUpdateMessages: Boolean
  isOptedInToThirdPartyMessages: Boolean
  isOptedInMeterReadingConfirmations: Boolean
  isOptedInToSmsMessages: Boolean
  isUsingInvertedEmailColours: Boolean
  fontSizeMultiplier: Float
  emailFormat: String
  preferredHoldMusic: String
  clientMutationId: String
}

# Update user's password.
type UpdatePassword {
  #  The currently authenticated user.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  viewer: AccountUserType
}

input UpdatePasswordInput {
  # Old password
  oldPassword: String!

  # New password
  newPassword: String!

  # Confirm new password
  newPasswordConfirmed: String!
}

# Regenerate the user's live secret key.
type RegenerateSecretKey {
  #  The currently authenticated user.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  viewer: AccountUserType
}

# The possible errors that can be raised are:
#
# - KT-CT-5413: Invalid data.
# - KT-CT-5414: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateUserMutation {
  possibleErrors: [PossibleErrorType]
  viewer: AccountUserType
}

input UpdateUserInput {
  givenName: String
  familyName: String

  # How the user would like us to address them (e.g. 'she/her', 'they/them'). Because this field is clearable, null and the empty string are treated differently; passing null or omitting the field leaves the value as-is, but explicitly passing an empty string clears this value.
  pronouns: String
  email: String

  # Because this field is clearable, null and the empty string are treated differently; passing null or omitting the field leaves the value as-is, but explicitly passing an empty string clears this value.
  mobile: String
  dateOfBirth: Date

  # Because this field is clearable, null and the empty string are treated differently; passing null or omitting the field leaves the value as-is, but explicitly passing an empty string clears this value.
  landline: String

  # The user for whom to perform the update. This is only needed when using an Organisation role
  userId: String

  # The user's title.
  title: String
}

type RegisterPushNotificationBinding {
  pushNotificationBinding: PushNotificationBindingType
}

# Represents a pairing of a single app installation to an account user.
type PushNotificationBindingType {
  id: ID!
  messages(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): PrintMessageTypeConnection!
  user: AccountUserType!
  token: String!
  application: NotifiableApplicationType!
  registeredAt: DateTime!
  expiresAt: DateTime!
}

# Represents an application that can receive push notifications.
type NotifiableApplicationType {
  id: ID!

  # Human readable name for the app.
  name: String!

  # Bundle ID or package name of the app.
  bundleId: String!
  service: NotifiableApplicationService!
  externalProvider: NotifiableApplicationExternalProvider!

  # Project ID used in push notification delivery service. (Currently: AWS Pinpoint)
  externalProjectId: String!
  description: String!
  pushNotificationBindings: [PushNotificationBindingType!]!
}

# An enumeration.
enum NotifiableApplicationService {
  # Android (GCM)
  GCM

  # iOS (APNs)
  APNS

  # iOS Sandbox (APNs Sandbox)
  APNS_SANDBOX
}

# An enumeration.
enum NotifiableApplicationExternalProvider {
  # AWS Pinpoint
  PINPOINT
}

input RegisterPushNotificationBindingInput {
  # Device push notification token.
  token: String!

  # Register a push notification binding. A push notification binding connects an account user to a specific application running on a specific device through a 'registration token' (Android) or 'device token' (iOS). Using this binding we can send push notifications to the account user's devices.
  bundleId: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-5411: Invalid token or no push notification binding found for the given account user.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type DeletePushNotificationBinding {
  possibleErrors: [PossibleErrorType]
  status: DeletePushNotificationBindingOutput
}

enum DeletePushNotificationBindingOutput {
  SUCCESSFUL
  FAILED
}

input DeletePushNotificationBindingInput {
  # Device push notification token.
  token: String!
}

# Create metadata on an object.
#
# The possible errors that can be raised are:
#
# - KT-CT-8412: Invalid data.
# - KT-CT-8414: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateMetadata {
  possibleErrors: [PossibleErrorType]
  metadata: Metadata
}

# Update existing metadata on an object.
#
# The possible errors that can be raised are:
#
# - KT-CT-8413: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateMetadata {
  possibleErrors: [PossibleErrorType]
  metadata: Metadata
}

type MeasurementType implements MeasurementInterface {
  source: String!

  # This type will return more granular data about the measurement.
  metaData: MeasurementsMetadataOutput
  value: Decimal!
  unit: String!
  readAt: DateTime!
}

interface MeasurementInterface {
  source: String!

  # This type will return more granular data about the measurement.
  metaData: MeasurementsMetadataOutput
  value: Decimal!
  unit: String!
  readAt: DateTime!
}

type MeasurementsMetadataOutput {
  # The source information relating to the parent measurement node.
  typedSource: TypedSourceOutput
    @deprecated(
      reason: "The 'typedSource' type is deprecated.\n\n\nPlease use 'utilityFilters' and the corresponding filter output instead.\n\n\n- Marked as deprecated on 2024-06-17.\n- Will be removed on 2026-01-30."
    )

  # The source information relating to the parent measurement node.
  utilityFilters: UtilityFiltersOutput

  # Statistics relating to the parent measurement node.
  statistics: [StatisticOutput]
}

# Note this is deprecated and will be removed in the future.
# Please use the `UtilityFiltersOutput` type instead.
type TypedSourceOutput {
  utility: UtilityType
  sourceIdentifier: String
  readingFrequencyType: ReadingFrequencyType
  readingDirection: ReadingDirectionType
  readingQuality: ReadingQualityType
}

enum UtilityType {
  ELECTRICITY
  EMBEDDED_ELECTRICITY
  GAS
}

# The frequency of the reading.
enum ReadingFrequencyType {
  # Interval Readings as provided, may be variable in length.
  RAW_INTERVAL

  # Readings taken in every 5 minute intervals.
  FIVE_MIN_INTERVAL

  # Readings taken in every 15 minute intervals.
  FIFTEEN_MIN_INTERVAL

  # Readings taken in every 30 minute intervals.
  THIRTY_MIN_INTERVAL
  HOUR_INTERVAL
  DAY_INTERVAL
  WEEK_INTERVAL
  MONTH_INTERVAL
  QUARTER_INTERVAL

  # Readings taken on a day to day basis.
  DAILY

  # Readings taken at a point in time.
  POINT_IN_TIME
}

# Reading direction is based on the utility generated or consumed by the customer.
enum ReadingDirectionType {
  # Reading is based on the customer's usage of the utility.
  CONSUMPTION

  #
  # Reading is based on the utility generated by the customer.
  #
  # For example: This will return solar readings if a customer has solar panels installed at their location.
  #
  GENERATION
}

enum ReadingQualityType {
  ACTUAL
  ESTIMATE
  COMBINED
}

union UtilityFiltersOutput =
    ElectricityFiltersOutput
  | EmbeddedElectricityFiltersOutput
  | GasFiltersOutput

type ElectricityFiltersOutput {
  readingDirection: ReadingDirectionType
  registerId: String
  readingQuality: ReadingQualityType
  readingFrequencyType: ReadingFrequencyType
  marketSupplyPointId: String
  deviceId: String
}

type EmbeddedElectricityFiltersOutput {
  readingDirection: ReadingDirectionType
  registerId: String
  readingQuality: ReadingQualityType
  readingFrequencyType: ReadingFrequencyType
  marketSupplyPointId: String
  deviceId: String
}

#
# Filter measurements by gas parameters.
#
type GasFiltersOutput {
  registerId: String
  readingFrequencyType: ReadingFrequencyType
  marketSupplyPointId: String
  deviceId: String
}

type StatisticOutput {
  # The type of statistic being measured for the parent node.
  type: ReadingStatisticTypeEnum

  # Display label of the statistic for the parent node.
  label: String

  # Description of the statistic for the parent node.
  description: String

  # Monetary cost of the statistic (excluding tax), if applicable.
  costExclTax: EstimatedMoneyType

  # Monetary cost of the statistic (including tax), if applicable.
  costInclTax: EstimatedMoneyType

  # Consumption / generation value of the statistic, if applicable.
  value: Decimal
}

# The type of statistic for the reading interval.
enum ReadingStatisticTypeEnum {
  # The calculated cost of standing charges for the interval.
  STANDING_CHARGE_COST

  # The calculated cost of consumption for the interval.
  CONSUMPTION_COST

  # The calculated monetary value of generation for the interval
  GENERATION_VALUE

  # The apportion cost of a time of use bucket for the interval.
  TOU_BUCKET_COST

  # The estimated carbon cost of the interval.
  CARBON_COST
}

type EstimatedMoneyType {
  #
  #             Monetary cost of the statistic. This is the smallest unit of currency,
  #             e.g. cents for USD or yen for JPY. Because electricity is priced as a commodity, we must
  #             account for fractional cents and this field must be a Decimal. Values from this field should
  #             likely not be used for accounting purposes.
  #
  estimatedAmount: Decimal!

  # Monetary currency of the statistic in ISO-4217 format.
  costCurrency: String!

  # Net price per unit of the statistic if applicable.
  pricePerUnit: PricePerUnit
}

type PricePerUnit {
  #
  #             Monetary value of a single unit of the measurement.
  #             This is the smallest unit of currency e.g. cents for USD or yen for JPY.
  #
  amount: Decimal!

  # Unit that monetary amount relates to eg. 27 cents per kwh.
  unit: Unit
}

# An enumeration.
enum Unit {
  KILOWATT_HOURS
  METERS_CUBED
}

type IntervalMeasurementType implements MeasurementInterface {
  source: String!

  # This type will return more granular data about the measurement.
  metaData: MeasurementsMetadataOutput
  value: Decimal!
  unit: String!
  readAt: DateTime!
  startAt: DateTime!
  endAt: DateTime!
  durationInSeconds: Int!
  accumulation: Decimal
}

# Represents a property. Conceptually, it collects supply points under an address.
type PropertyType implements PropertyInterface {
  id: String
  postcode: String!

  # The address of the property, formatted into a single string
  address: String

  # Property rich address.
  richAddress: PropertyRichAddressType

  # List of address lines.
  splitAddress: [String]

  # Time periods during which the property is associated with an account. Useful to display information about house-moves, as performing a move out of a property will set the end date for the occupancy period.
  occupancyPeriods: [OccupancyPeriodType]

  # Coordinates for the property, useful for displaying the property on a map.
  coordinates: CoordinatesType

  # The embedded network this property belongs to, if any.
  embeddedNetwork: EmbeddedNetworkType

  # Measurements at a property
  measurements(
    # Defaults to the far past which will return the oldest readings.
    startAt: DateTime = "0001-01-03T00:00:00-00:01:15"

    # Defaults to the far future which will return the most recent readings.
    endAt: DateTime = "9999-12-29T23:59:59.999999+00:00"

    # Earliest date to return measurements from.
    startOn: Date

    # Latest date to return measurements for (inclusive).
    endOn: Date

    # Timezone to use for grouping. Defaults to Kraken localtime.
    timezone: String = "Europe/London"

    # Filters for each utility being measured
    utilityFilters: [UtilityFiltersInput] = []
    before: String
    after: String
    first: Int
    last: Int
  ): MeasurementConnection

  # Retrieve any smartmeter devices connected to the property.
  smartDeviceNetworks: [SmartMeterDeviceNetworkType]
  isChangeOfTenancyOngoing: Boolean

  # Indicates if the property meets smart meter install preconditions.
  isSmets2InstallationAllowed: Boolean

  # Retrieve the details of an electricity meter-point.
  electricityMeterPoints: [ElectricityMeterPointType]

  # Retrieve the details of a gas meter-point.
  gasMeterPoints: [GasMeterPointType]

  # Likelihood that a smart meter at the given postcode will get a stable network connection.
  wanCoverage: WANCoverageStrengths

  # Timeslots for which the property has the possibility to book a smart-meter installation.
  availableSmets2InstallationTimeslots: [Smets2InstallationTimeslotType]
}

interface PropertyInterface {
  id: String

  # The address of the property, formatted into a single string
  address: String

  # Property rich address.
  richAddress: PropertyRichAddressType

  # List of address lines.
  splitAddress: [String]

  # Time periods during which the property is associated with an account. Useful to display information about house-moves, as performing a move out of a property will set the end date for the occupancy period.
  occupancyPeriods: [OccupancyPeriodType]

  # Coordinates for the property, useful for displaying the property on a map.
  coordinates: CoordinatesType

  # The embedded network this property belongs to, if any.
  embeddedNetwork: EmbeddedNetworkType

  # Measurements at a property
  measurements(
    # Defaults to the far past which will return the oldest readings.
    startAt: DateTime = "0001-01-03T00:00:00-00:01:15"

    # Defaults to the far future which will return the most recent readings.
    endAt: DateTime = "9999-12-29T23:59:59.999999+00:00"

    # Earliest date to return measurements from.
    startOn: Date

    # Latest date to return measurements for (inclusive).
    endOn: Date

    # Timezone to use for grouping. Defaults to Kraken localtime.
    timezone: String = "Europe/London"

    # Filters for each utility being measured
    utilityFilters: [UtilityFiltersInput] = []
    before: String
    after: String
    first: Int
    last: Int
  ): MeasurementConnection
}

type PropertyRichAddressType {
  # A personal name.
  name: String

  # The name of a business or organisation.
  organization: String

  #
  # The 'street address' component.
  #
  # This value can (and often will) contain newline characters
  # when appropriate.
  #
  # In some cases, data may appear in this field instead of the
  # below fields; e.g. a UK post town name may appear here
  # instead of in the `dependent_locality` field. This happens
  # when data has been migrated from a legacy format, and that
  # format had insufficient metadata to determine the
  # appropriate field.
  #
  # If `structured_street_address` is also set, the value of
  # this field will be a string generated from that value.
  #
  streetAddress: String

  #
  # The 'street address' component, in a structured format.
  #
  # This field stores the same value as `street_address`, but
  # with more detail; for instance, instead of `123 Example
  # Street` it might be `{'street_number': '123',
  # 'street_name': 'Example', 'street_type': 'Street'}`. In
  # many cases this will be blank; we only use this field for
  # Krakens where we need to supply this level of granularity
  # to some third-party service, like a bulk mail provider.
  #
  # The exact structure of this value depends on the country _of
  # the address_, which is not necessarily the same as the
  # country this Kraken is configured to serve. For addresses
  # outside of the countries listed below, this field will be
  # left blank.
  #
  # ### `AU`: Australia
  #
  # The following keys may be present; all are optional. All
  # keys have string values, and their meaning is the same as
  # their aseXML counterparts. (Note that, unlike aseXML, all
  # keys are provided at the top level, rather than being
  # nested.)
  #
  # - `flat_or_unit_type`
  # - `flat_or_unit_number`
  # - `floor_or_level_type`
  # - `floor_or_level_number`
  # - `building_or_property_name`
  # - `location_descriptor`
  # - `lot_number`
  # - `house_number_1`
  # - `house_number_suffix_1`
  # - `house_number_2`
  # - `house_number_suffix_2`
  # - `street_name`
  # - `street_type`
  # - `street_suffix`
  # - `postal_delivery_type`
  # - `postal_delivery_number_prefix`
  # - `postal_delivery_number_value`
  # - `postal_delivery_number_suffix`
  #
  # ### `JP`: Japan
  #
  # The following keys may be present; all are optional.
  # If keys are empty, they may be omitted from the response entirely.
  #
  # - `chome`
  # - `banchi`
  # - `go`
  # - `edaban`
  # - `kana_building_name`
  # - `kanji_building_name`
  # - `building_number`
  # - `room_number`
  # - `address_code`
  # - `physical_location_identifier`
  #
  structuredStreetAddress: GenericScalar

  #
  # UK dependent localities, or neighbourhoods or boroughs in
  # some other locations.
  #
  dependentLocality: String

  #
  # City or town portion of an address, e.g. US city, AU
  # suburb/town, IT comune, UK post town.
  #
  locality: String

  #
  # Top-level administrative subdivision, e.g. US state, AU
  # state/territory, IT region, JP prefecture.
  #
  # ### `AU`: Australia
  #
  # This must be one of `NSW`, `VIC`, `QLD`, `TAS`, `ACT`, `SA`,
  # `NT`, `WA`. For addresses not within these locations, use
  # the value that Australia Post uses, e.g. `ACT` for the
  # Jervis Bay Territory or `WA` for Christmas Island.
  #
  administrativeArea: String

  #
  # Postal code (ZIP code in the US).
  #
  postalCode: String

  #
  # Sorting code, e.g. FR CEDEX code. This field is not used in many countries.
  #
  sortingCode: String

  #
  # ISO 3166-1 alpha-2 code of the country this address belongs
  # to, e.g. `AU`, `GB`.
  #
  country: String

  #
  # Identifier used by the local postal service for this
  # address, e.g. AU DPID, GB postcode + Delivery Point Suffix,
  # US Zip-9 + Delivery Point.
  #
  # This is the value that gets encoded in the barcode printed
  # on the envelope by large-volume bulk mail providers.
  #
  deliveryPointIdentifier: String
}

# An occupancy period for a property.
type OccupancyPeriodType {
  id: ID

  # Date the occupancy period is effective from.
  effectiveFrom: DateTime

  # Date the occupancy period is effective to.
  effectiveTo: DateTime

  # Whether the account associated with the occupancy period is an occupier account type.
  isOccupier: Boolean
}

type CoordinatesType {
  latitude: Float
  longitude: Float
}

# Represents an embedded network that holds multiple embedded properties.
type EmbeddedNetworkType {
  id: ID!

  # A unique name/code for the network
  name: String!

  # Get details about properties in an embedded network.
  embeddedProperties: [EmbeddedPropertyType]
}

# Represents an embedded property in an embedded network.
type EmbeddedPropertyType {
  id: ID!
  embeddedNetwork: EmbeddedNetworkType!

  # The id of the physical property related to this embedded property type.
  propertyId: ID
}

# Pagination for measurements.
type MeasurementConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [MeasurementEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `Measurement` and its cursor.
type MeasurementEdge {
  # The item at the end of the edge
  node: MeasurementInterface

  # A cursor for use in pagination
  cursor: String!
}

#
# Provide a typed source to filter measurements.
# If a typed_source and a raw source is given, preference is given to the raw source.
# To get better results, make sure none of the input fields are empty.
#
input TypedSourceInputType {
  utility: UtilityType = ELECTRICITY
  readingFrequencyType: ReadingFrequencyType = RAW_INTERVAL
  readingDirection: ReadingDirectionType = CONSUMPTION
  sourceIdentifier: String
  readingQuality: ReadingQualityType = COMBINED
}

#
# Filter measurements by the given utility parameters.
#
input UtilityFiltersInput {
  electricityFilters: ElectricityFiltersInput = null
  gasFilters: GasFiltersInput = null
}

#
# Filter measurements by electricity parameters.
#
input ElectricityFiltersInput {
  readingFrequencyType: ReadingFrequencyType = RAW_INTERVAL
  marketSupplyPointId: String
  deviceId: String
  readingDirection: ReadingDirectionType = CONSUMPTION
  registerId: String
  readingQuality: ReadingQualityType = COMBINED
}

#
# Filter measurements by gas parameters.
#
input GasFiltersInput {
  readingFrequencyType: ReadingFrequencyType = RAW_INTERVAL
  marketSupplyPointId: String
  deviceId: String
  registerId: String
}

# This is the network through which a set of SMETS2 devices communicates.
type SmartMeterDeviceNetworkType {
  id: ID!

  # A list of devices attached to one network.
  smartDevices(
    # Filter the devices by status.
    statuses: [DeviceStatuses]
  ): [SmartMeterDeviceType]
}

# A smart meter device.
type SmartMeterDeviceType {
  id: ID!
  importElectricityMeter: ElectricityMeterType
  exportElectricityMeter: ElectricityMeterType
  gasMeter: GasMeterType
  deviceNetwork: SmartMeterDeviceNetworkType
  serialNumber: String!
  deviceId: String!
  type: DeviceType
  status: DeviceStatus!
  manufacturer: String!
  model: String!
  firmwareVersion: String!

  # The payment mode (e.g. credit or prepayment) that the device is currently operating in.
  paymentMode: PaymentMode

  # The rate, in pence per week, that debt is being recovered from this device.
  weeklyDebtRecoveryRateInPence: Int
}

# An electricity meter is a collection of registers which store readings. Eco7 meters are an example of a meter with multiple registers (for day and night).
type ElectricityMeterType implements Node & Meter {
  id: ID!
  serialNumber: String!
  requiresAccess: Boolean
  isDigital: Boolean
  installationDate: Date
  lastInspectionDate: Date
  createdAt: DateTime!
  updatedAt: DateTime
  activeFrom: Date!
  activeTo: Date
  meterPoint: ElectricityMeterPointType!
  location: String
  currentRating: Int
  makeAndType: String
  meterType: ElectricityMeterMeterType
  certificationDate: Date
  certifiedUntil: Date
  retrievalMethod: String
  importMeter: ElectricityMeterType
  exportMeters(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): ElectricityMeterTypeConnection!
  prepayLedgers: PrepayLedgersType
  smartImportElectricityMeter: SmartMeterDeviceType
  smartExportElectricityMeter: SmartMeterDeviceType

  # The units of consumption for a smart meter.
  consumptionUnits: String

  # Whether this meter requires a final change of tenancy (COT) reading.
  requiresCotFinalReading: Boolean

  # The type of fuel this meter uses.
  fuelType: String

  # Energy consumption recorded by the meter.
  consumption(
    # Earliest consumption reading to return. Must specify a timezone.
    startAt: DateTime!

    # Aggregate consumption according to this grouping.
    grouping: ConsumptionGroupings!

    # Timezone to use for grouping.
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection

  # This lets us get around the fact that we already use the field id as a primary key. We will migrate the id field over to be this id eventually.
  nodeId: ID!
  readings(
    before: String
    after: String
    first: Int
    last: Int
  ): ElectricityMeterReadingConnectionTypeConnection
  registers: [ElectricityMeterRegisterType]

  # Returns if the meter has and allows half hourly readings
  hasAndAllowsHhReadings: Boolean
  smartDevices: [SmartMeterDeviceType]

  # Returns if the meter is a traditional prepay meter.
  isTradPrepay: Boolean

  # Returns if the meter is ready for top up.
  isReadyForTopup: Boolean
}

interface Meter {
  id: ID!
  serialNumber: String!

  # The units of consumption for a smart meter.
  consumptionUnits: String

  # Whether this meter requires a final change of tenancy (COT) reading.
  requiresCotFinalReading: Boolean

  # The type of fuel this meter uses.
  fuelType: String

  # Energy consumption recorded by the meter.
  consumption(
    # Earliest consumption reading to return. Must specify a timezone.
    startAt: DateTime!

    # Aggregate consumption according to this grouping.
    grouping: ConsumptionGroupings!

    # Timezone to use for grouping.
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection
}

# Pagination for energy consumption readings.
type ConsumptionConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [ConsumptionEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `Consumption` and its cursor.
type ConsumptionEdge {
  # The item at the end of the edge
  node: ConsumptionType

  # A cursor for use in pagination
  cursor: String!
}

# Energy consumption between two points in time.
type ConsumptionType {
  value: Decimal
  startAt: DateTime
  endAt: DateTime
}

# An enumeration.
enum ConsumptionGroupings {
  QUARTER_HOUR
  HALF_HOUR
  HOUR
  DAY
  WEEK
  MONTH
  QUARTER
}

# An electricity meterpoint is a collection of meters. Meters can be changed over time, so it is convenient to keep an invariant reference. Sometimes there are multiple active meters on a meterpoint at a time (eg ECO10), but expect that to be an edge case.
type ElectricityMeterPointType implements MeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mpan: String!

  # Standard settlement configuration
  ssc: String!
  energisationStatus: String!
  dccServiceFlag: String!
  statusUpdatedAt: DateTime
  oldSupplierId: String
  newSupplierId: String
  smartStartDate: Date
  requiresEnrolment: Boolean!
  targetSsd: Date
  requiresWithdrawal: Boolean!
  hasOpenOpeningReadDispute: Boolean!
  hasOpenClosingReadDispute: Boolean!

  # The profile class of the electricity meter point.
  profileClass: Int

  # Line loss factor class
  llf: String

  # Meter timeswitch code
  mtc: Int
  measurementClass: String!
  lastValidatedReadingDate: Date

  # Smart Metering System Operator
  smsOperator: String!
  smsOperatorEffectiveFrom: Date
  ihdStatus: String!
  ihdEffectiveFrom: Date
  dccEffectiveFrom: Date
  meters(id: Int, includeInactive: Boolean): [ElectricityMeterType]
  status: String

  # Details of an ongoing enrolment process.
  enrolment: EnrolmentType

  # The distribution network the grid supply point falls under
  gspGroupId: String

  # A list of agents responsible for management of the meterpoint.
  agentContracts(
    # Filter the contracts by status.
    statuses: [AgentContractStatusType]
  ): [ElectricityAgentContractType]

  # The ID of the meter point in Junifer.
  juniferMeterPointId: Int
    @deprecated(
      reason: "The 'juniferMeterPointId' field is deprecated.\n\nIt is no longer populated.\n\n- Marked as deprecated on 2023-03-13.\n- Will be removed on 2023-09-13."
    )

  # A list of electricity agreements belonging to an account that is linked to the viewer. Filters out expired agreements by default.
  agreements(
    validAfter: DateTime
    includeInactive: Boolean

    # Exclude agreements starting in the future.
    excludeFuture: Boolean
  ): [ElectricityAgreementType]
  smartTariffOnboarding: SmartTariffOnboardingType

  # A list of unbilled electricity readings for the meterpoint.
  unbilledReadings: [ElectricityMeterReadingType]

  # The current MPID for this meter point.
  currentSupplierMpid: String
}

interface MeterPointInterface {
  status: String

  # Returns active meters by default, but can be filtered by meter id and active status.
  meters(id: Int, includeInactive: Boolean): [Meter]

  # Details of an ongoing enrolment process.
  enrolment: EnrolmentType
}

# Details of an ongoing enrolment process.
type EnrolmentType {
  # Date the switch started.
  switchStartDate: Date

  # Target date for supply to start.
  supplyStartDate: Date

  # The last company to supply this meter point.
  previousSupplier: String

  # The enrolment status on a meter point.
  status: EnrolmentStatusOptions
}

# An enumeration.
enum EnrolmentStatusOptions {
  # The previous supplier objects to the switch. The have not has cancelled the switch yet, but in 99% cases, they will cancel the switch.
  OBJECTION_RECEIVED

  # The previous supplier cancelled the switch. This is a terminal state, and we will have to reapply before this can start again.
  REGISTRATION_OBJECTED

  # The overseeing industry body has objected to the switch
  REJECTED

  # The request to bring the meter point on supply has been withdrawn.
  WITHDRAWN

  # The meterpoint has been created but the enrolment process has not started yet.
  PRE_REGISTRATION

  # Enrolment has been requested. This is the default catch-all status, which is returned when no other defined process is happening.
  REQUESTED

  # Enrolment has been completed.
  COMPLETED

  # Enrolment has been disputed. This could be that the meter point details that have been provided have been disputed.
  DISPUTED

  # Enrolment has been accepted by the industry, which means that it has all the information needed to switch supplier and if that information is correct (to it's knowledge)
  ACCEPTED
}

# An organization who manages a given meterpoint.
type ElectricityAgentContractType {
  contractType: ElectricityAgentContractContractType!
  effectiveFrom: Date!
  agentId: String
  contractStatus: AgentContractStatusType
}

# An enumeration.
enum ElectricityAgentContractContractType {
  # Meter Operator
  MOP

  # Data Aggregator
  DA

  # Data Collector
  DC

  # Advanced Metering Service
  MSA

  # Smart Metering Service
  MSS

  # Advanced Data Service
  ADS

  # Smart Data Service
  SDS

  # Unmetered Data Service
  UMSDS

  # Unmetered Supplies Operator
  UMSO
}

# An enumeration.
enum AgentContractStatusType {
  # The contracts that have been accepted by the agent.
  ACCEPTED

  # The contracts that have been rejected by the agent.
  REJECTED

  # The contracts that have been requested by the supplier.
  REQUESTED

  # The contracts for which termination has been requested by the supplier.
  TERMINATION_REQUESTED

  # The contracts that have been terminated.
  TERMINATED
}

type ElectricityAgreementType implements AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  account: AccountType!
  meterPoint: ElectricityMeterPointType!
  tariff: ElectricityTariffType
  isRevoked: Boolean

  # A collection of charges and associated consumption data.
  lineItems(
    startAt: DateTime!

    # Aggregate line items according to this grouping. Note that this doesn't guarantee that the returned items will cover a particular length of time, as it will depend on how the items have been stored, whether the period had daylight savings time changes (and therefore potentially 25 hours) etc.
    grouping: LineItemGroupingOptions!
    itemType: LineItemTypeOptions!

    # Timezone used for grouping.
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): LineItemConnection

  # List of contracted unit rate uplifts applicable during this agreement's duration. This is only applicable to business accounts where we may pay commission to a third-party intermediary.
  unitRateUplifts: [ElectricityContractUnitRateUplift]
}

interface AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  isRevoked: Boolean
}

union ElectricityTariffType =
    StandardTariff
  | DayNightTariff
  | ThreeRateTariff
  | HalfHourlyTariff
  | PrepayTariff

type StandardTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  # Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  tariffCode: String
  unitRate: Float

  # Is EPG applied to the unit rate.
  unitRateEpgApplied: Boolean
  preVatUnitRate: Float
}

interface TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  # Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  tariffCode: String
}

type DayNightTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  # Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  tariffCode: String
  dayRate: Float

  # Is EPG applied to the unit rate.
  dayRateEpgApplied: Boolean
  nightRate: Float

  # Is EPG applied to the unit rate.
  nightRateEpgApplied: Boolean
  preVatDayRate: Float
  preVatNightRate: Float
}

type ThreeRateTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  # Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  tariffCode: String
  dayRate: Float

  # Is EPG applied to the unit rate.
  dayRateEpgApplied: Boolean
  nightRate: Float

  # Is EPG applied to the unit rate.
  nightRateEpgApplied: Boolean
  offPeakRate: Float

  # Is EPG applied to the unit rate.
  offPeakRateEpgApplied: Boolean
  preVatDayRate: Float
  preVatNightRate: Float
  preVatOffPeakRate: Float
}

type HalfHourlyTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  # Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  tariffCode: String
  unitRates: [UnitRate]

  # Information on how agile unit rates have been calculated.
  agileCalculationInfo: AgileCalculationInfo
}

type UnitRate {
  validFrom: DateTime
  validTo: DateTime

  # Price in pence (inc VAT).
  value: Float

  # Price in pence (not including VAT).
  preVatValue: Float
}

type AgileCalculationInfo {
  # The maximum value/cap for the unit rate.
  priceCap: Float

  # The peak offset for the unit rate.
  peakOffset: Float

  # The price multiplier/coefficient used to calculate the unit rate.
  gspCoefficient: Float
}

type PrepayTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  # Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  tariffCode: String
  unitRate: Float
  preVatUnitRate: Float
}

#
#
# This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
#
#
type LineItemConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [LineItemEdge]!
}

# A Relay edge containing a `LineItem` and its cursor.
type LineItemEdge {
  # The item at the end of the edge
  node: LineItemType

  # A cursor for use in pagination
  cursor: String!
}

# A record of spend on consumption between two points in time.
type LineItemType {
  startAt: DateTime
  endAt: DateTime
  netAmount: Decimal
  numberOfUnits: Decimal
  itemType: String
  settlementUnit: String
}

# An enumeration.
enum LineItemGroupingOptions {
  NONE
  HALF_HOUR
  HOUR
  DAY
  WEEK
  MONTH
  QUARTER
}

# An enumeration.
enum LineItemTypeOptions {
  STANDING_CHARGE
  CONSUMPTION_CHARGE
}

type ElectricityContractUnitRateUplift {
  # When this contract is valid from.
  validFrom: DateTime!

  # When this contract is valid until.
  validTo: DateTime!

  # The amount to add to the unit rate when billing, in pence/kWh.
  unitRateUplift: Decimal!
}

# The smart tariff onboarding process. Only relevant for Kraken instances that support half hourly tariffs. Returns null if not applicable.
type SmartTariffOnboardingType {
  id: ID!
  latestStatus: SmartOnboardingEventType
  latestTermsStatus: SmartOnboardingTermsStatuses
  smartTariffCode: SmartOnboardingTariffCodes
  lastUpdated: String
}

# An enumeration.
enum SmartOnboardingEventType {
  # Onboarding started.
  STARTED

  # Onboarding completed.
  COMPLETED

  # Onboarding cancelled.
  CANCELLED

  # Note Added.
  NOTE_ADDED

  # Email sent to book meter exchange.
  METER_EXCHANGE_EMAIL_SENT

  # Meter exchange date agreed.
  METER_EXCHANGE_BOOKED

  # Meter Installed.
  METER_INSTALLED

  # Meter Readings Available.
  METER_READINGS_AVAILABLE

  # Email sent to request terms acceptance.
  TERMS_EMAIL_SENT

  # Customer accepted terms and conditions.
  TERMS_ACCEPTED

  # Agreements Updated.
  AGREEMENTS_UPDATED

  # Email sent to confirm tariff switch.
  TARIFF_SWITCH_CONFIRMATION_EMAIL_SENT

  # Tariff Changed On Meter.
  TARIFF_CHANGED_ON_METER

  # Unable To Proceed.
  UNABLE_TO_PROCEED

  # Previous Agreement Billing Gap Filled.
  PREVIOUS_AGREEMENT_BILLING_GAP_FILLED

  # Email to install Intelligent Octopus app installed.
  INTELLIGENT_OCTOPUS_INSTALL_APP_EMAIL_SENT

  # Test dispatch in app complete.
  INTELLIGENT_OCTOPUS_TEST_DISPATCH_COMPLETE

  # Documents Checked.
  DOCUMENTS_CHECKED

  # FIT resolution.
  FIT_RESOLUTION

  # Export MPAN applied for.
  EXPORT_MPAN_APPLIED_FOR

  # Export MPAN created.
  EXPORT_MPAN_CREATED

  # Export Mpan Not Found.
  EXPORT_MPAN_NOT_FOUND

  # MTDs updated.
  MTD_UPDATED

  # Export Enabled In Kraken.
  EXPORT_ENABLED_IN_KRAKEN

  # Export Meter Reading Available.
  EXPORT_METER_READING_AVAILABLE

  # Export MPAN is on supply.
  EXPORT_MPAN_ON_SUPPLY

  # First Credit Applied.
  FIRST_CREDIT_APPLIED
}

# An enumeration.
enum SmartOnboardingTermsStatuses {
  # Customer acceptance of T&Cs required
  TERMS_ACCEPTANCE_REQUIRED

  # Awaiting customer acceptance of T&Cs
  TERMS_EMAIL_SENT

  # T&Cs accepted
  TERMS_ACCEPTED
}

# An enumeration.
enum SmartOnboardingTariffCodes {
  # Octopus Energy's Agile Octopus tariff
  AGILE_OCTOPUS

  # Octopus Energy's Octopus Go tariff
  OCTOPUS_GO

  # Octopus Energy's Octopus Go Faster tariff
  OCTOPUS_GO_FASTER

  # Octopus Energy's Octopus Go Green tariff
  OCTOPUS_GO_GREEN

  # Octopus Energy's Tesla Energy Plan import tariff
  TESLA_IMPORT

  # Octopus Energy's Intelligent Octopus Go tariff
  INTELLIGENT_OCTOPUS

  # Octopus Energy's Intelligent Octopus Flux tariff
  INTELLIGENT_FLUX

  # Octopus Energy's Outgoing Fixed tariff
  OUTGOING_FIXED

  # Octopus Energy's Octopus Agile tariff
  OUTGOING_AGILE

  # Octopus Energy's Cosy Octopus tariff
  COSY_OCTOPUS

  # Octopus Energy's Flux tariff
  OCTOPUS_FLUX

  # Octopus Energy's Powerloop tariff
  POWERLOOP
}

# A electricity meter reading. A reading can in fact contain multiple values for each register (for example for ECO7). They are collected under a common read_at datetime and have a common fuel type.
type ElectricityMeterReadingType implements MeterReading {
  id: ID!
  readAt: DateTime
  readingSource: String
  registers: [RegisterReading]
  source: String
}

interface MeterReading {
  readAt: DateTime
  readingSource: String
  registers: [RegisterReading]
  source: String
}

type RegisterReading {
  identifier: String
  name: String
  value: String
  digits: Int
  isQuarantined: Boolean
}

# An enumeration.
enum ElectricityMeterMeterType {
  # Check
  CHECK

  # Half Hourly
  H

  # Key
  K

  # Lag
  LAG_

  # Lead
  LEAD_

  # Main
  MAIN_

  # Non-Half Hourly
  N

  # Non-remotely Configurable Automated Meter Reading
  NCAMR

  # A meter that meets the definition of an ADM but is not compliant with any version of SMETS
  NSS

  # Remotely Configurable Automated Meter Reading without remote enable/disable capability
  RCAMR

  # Remotely Configurable Automated Meter Reading with remote enable/disable capability
  RCAMY

  # Smartcard Prepayment
  S

  # A meter that is compliant with the Smart Metering Equipment Technical Specifications 1 (SMETS1)
  S1

  # A single element meter that is compliant with SMETS2
  S2A

  # A twin element meter that is compliant with SMETS2
  S2B

  # A polyphase meter that is compliant with SMETS2
  S2C

  # A single element meter with one or more ALCS that is compliant with SMETS2
  S2AD

  # A twin element meter with one or more ALCS that is compliant with SMETS2
  S2BD

  # A polyphase meter with one or more ALCS that is compliant with SMETS2
  S2CD

  # Single element meter with one or more ALCS and Boost Function that is compliant with SMETS2
  S2ADE

  # A twin element meter with one or more ALCS and Boost Function that is compliant with SMETS2
  S2BDE

  # A polyphase meter with one or more ALCS and Boost Function that is compliant with SMETS2
  S2CDE

  # Special
  SPECL

  # Token
  T

  # Single Element with APC that is compliant with SMETS2
  A_2AF

  # Single Element with ALCS and APC that is compliant with SMETS2
  A_2ADF

  # Single Element with Boost Function and APC that is compliant with SMETS2
  A_2AEF

  # Single Element with ALCS, Boost Function and APC that is compliant with SMETS2
  A_2ADEF

  # Twin Element  with APC that is compliant with SMETS2
  A_2BF

  # Twin Element with ALCS and APC that is compliant with SMETS2
  A_2BDF

  # Twin Element with Boost Function and APC that is compliant with SMETS2
  A_2BEF

  # Twin Element with ALCS, Boost Function and APC that is compliant with SMETS2
  A_2BDEF

  # Polyphase with APC that is compliant with SMETS2
  A_2CF

  # Polyphase with ALCS and APC that is compliant with SMETS2
  A_2CDF

  # Polyphase with Boost Function and APC that is compliant with SMETS2
  A_2CEF

  # Polyphase with ALCS, Boost Function and APC that is compliant with SMETS2
  A_2CDEF
}

type ElectricityMeterTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [ElectricityMeterTypeEdge]!
}

# A Relay edge containing a `ElectricityMeterType` and its cursor.
type ElectricityMeterTypeEdge {
  # The item at the end of the edge
  node: ElectricityMeterType

  # A cursor for use in pagination
  cursor: String!
}

# The ledgers associated to a prepayment meter. There are three types: a credit ledger for mirroring the meter's credit balance, a debt ledger for mirroring the meter's debt balance and payment ledger which is the inflight payments that we have not yet managed to resolve on the other two ledgers.
type PrepayLedgersType {
  creditLedger: SupplementaryLedgerType
  debtLedger: SupplementaryLedgerType
  paymentLedger: PrepayPaymentLedgerType
}

# The in-flight payment ledger tracks the status of payments made to a prepay meter.
type PrepayPaymentLedgerType implements SupplementaryLedgerInterface {
  id: ID

  # The display name of the ledger.
  name: String
  ledgerType: String

  # The current final balance of the ledger in pence.
  currentBalance: Int
  paymentAdequacy: PaymentAdequacyDetailsType

  # Payments made to add credit to a smart prepay meter.
  payments: [PrepayPaymentType]

  # Transfers of credit from the account ledger to a smart prepay meter.
  creditTransfers: [PrepayCreditTransferType]
}

type PrepayPaymentType {
  id: ID!

  # Amount of payment in pence
  amount: BigInt!

  # The date this payment is scheduled to be debited
  paymentDate: Date!
  smartPrepayStatus: SmartPrepayPaymentStatusChoices
    @deprecated(
      reason: "The 'smartPrepayStatus' field is deprecated.\n\n\nPlease use the 'smartPrepayProcessStatus' type instead for a more granular status.\n\n\n- Marked as deprecated on 2023-09-05.\n- Will be removed on 2024-01-01."
    )
  smartPrepayProcessStatus: SmartPrepayProcessStatusChoices
  utrn: String!
  meter: Meter
}

enum SmartPrepayPaymentStatusChoices {
  UTRN_REQUESTED
  UTRN_RECEIVED
  ACCEPTED_BY_METER
  RESOLVED
}

enum SmartPrepayProcessStatusChoices {
  NOT_STARTED
  INITIATED
  PENDING
  COMPLETED
  FAILED
  UTRN_MUST_BE_APPLIED_MANUALLY
}

type PrepayCreditTransferType {
  id: ID!

  #
  netAmount: BigInt!
  createdDate: Date!
  smartPrepayStatus: SmartPrepayPaymentStatusChoices
    @deprecated(
      reason: "The 'smartPrepayStatus' field is deprecated.\n\n\nPlease use the 'smartPrepayProcessStatus' type instead for a more granular status.\n\n\n- Marked as deprecated on 2023-09-05.\n- Will be removed on 2024-01-01."
    )
  smartPrepayProcessStatus: SmartPrepayProcessStatusChoices
  utrn: String
}

#
#
# This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
#
#
type ElectricityMeterReadingConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [ElectricityMeterReadingConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `ElectricityMeterReadingConnectionType` and its cursor.
type ElectricityMeterReadingConnectionTypeEdge {
  # The item at the end of the edge
  node: ElectricityMeterReadingType

  # A cursor for use in pagination
  cursor: String!
}

# Electricity registers measure consumption.
type ElectricityMeterRegisterType {
  id: ID!
  identifier: String
  digits: Int
  decimalPlaces: Int
  name: String
  expectedReadingRanges: [[Int]]
  timePatternRegime: String
  unitRateType: String
  eac: Decimal
  multiplier: Float
}

# A gas meter has a register which holds readings. We would expect this to be a one-to-one relationship between meter and register.
type GasMeterType implements Node & Meter {
  id: ID!
  serialNumber: String!
  requiresAccess: Boolean
  isDigital: Boolean
  installationDate: Date
  lastInspectionDate: Date
  createdAt: DateTime!
  updatedAt: DateTime
  activeFrom: Date!
  activeTo: Date
  meterPoint: GasMeterPointType!
  manufacturerCode: String!
  modelName: String!
  manufacturedYear: Int
  meterType: String!
  imperial: Boolean
  units: Int!
  location: String!
  mechanism: GasMeterMechanism
  correction: Float
  locationDescription: String!
  readingFactor: Decimal
  instructions: String!
  pulseValue: Decimal
  linkCode: String!
  collarFitted: String!
  bypassFitted: String!
  measuringCapacity: Decimal
  status: GasMeterStatus
  operationalStatusDate: Date
  owner: String!
  currentMeterAssetManager: String!
  prepayLedgers: PrepayLedgersType
  smartGasMeter: SmartMeterDeviceType

  # The units of consumption for a smart meter.
  consumptionUnits: String

  # Whether this meter requires a final change of tenancy (COT) reading.
  requiresCotFinalReading: Boolean

  # The type of fuel this meter uses.
  fuelType: String

  # Energy consumption recorded by the meter.
  consumption(
    # Earliest consumption reading to return. Must specify a timezone.
    startAt: DateTime!

    # Aggregate consumption according to this grouping.
    grouping: ConsumptionGroupings!

    # Timezone to use for grouping.
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection

  # This lets us get around the fact that we already use the field id as a primary key. We will migrate the id field over to be this id eventually.
  nodeId: ID!
  readings(
    before: String
    after: String
    first: Int
    last: Int
  ): GasMeterReadingConnectionTypeConnection
  registers: [GasMeterRegisterType]

  # Returns if the meter has and allows half hourly readings
  hasAndAllowsHhReadings: Boolean
  smartDevices: [SmartMeterDeviceType]

  # Returns if the meter is a traditional prepay meter.
  isTradPrepay: Boolean

  # Returns if the meter is ready for top up.
  isReadyForTopup: Boolean
}

# A gas meterpoint is a collection of meters. Meters are changed over time, so it is convenient to keep an invariant reference. We would not expect there to be multiple active meters at a time on a gas meterpoint.
type GasMeterPointType implements MeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mprn: String
  statusUpdatedAt: DateTime
  oldSupplierId: String
  newSupplierId: String
  smartStartDate: Date
  requiresEnrolment: Boolean!
  targetSsd: Date
  requiresWithdrawal: Boolean!
  hasOpenOpeningReadDispute: Boolean!
  hasOpenClosingReadDispute: Boolean!
  marketSectorCode: GasMeterPointMarketSectorCode
  marketCategory: GasMeterPointMarketCategory
  meterOwnershipType: GasMeterPointMeterOwnershipType
  confirmationReference: Int
  nominationType: String!
  supplyClass: Int!
  nominationShipperReference: String!

  # Industry status code
  xoserveStatus: String
  exitCapacityChargeRate: Decimal
  ldzCapacityChargeRate: Decimal
  ldzCommodityChargeRate: Decimal
  ldzCustomerChargeRate: Decimal
  ntsExitCommodityChargeRate: Decimal
  mrfType: String!
  meterReadBatchFrequency: String!

  # SOQ fixed for year
  formulaYearSmpSoq: Int

  # AQ fixed for year
  formulaYearSmpAq: Int

  # Rolling SOQ
  currentDmSoq: Int

  # Rolling SOQ
  currentNdmSoq: Int
  exitZone: String!

  # Local distribution zone - Distribution charges are based upon this
  ldz: String!
  supplyPointCategory: String!
  endUserCategory: Int
  eucIdentifier: String
  igtIdentifier: String!
  igtCheckedAt: DateTime
  meters(id: Int, includeInactive: Boolean): [GasMeterType]
  status: String

  # Details of an ongoing enrolment process.
  enrolment: EnrolmentType

  # A list of agents responsible for management of the meterpoint.
  agentContracts(
    # Filter the contracts by status.
    statuses: [AgentContractStatusType]
  ): [GasAgentContractType]

  # A list of gas agreements belonging to an account that is linked to the viewer. Filters out expired agreements by default.
  agreements(
    validAfter: DateTime
    includeInactive: Boolean

    # Exclude agreements starting in the future.
    excludeFuture: Boolean
  ): [GasAgreementType]

  # A list of unbilled gas readings for the meterpoint.
  unbilledReadings: [GasMeterReadingType]

  # The current MPID for this meter point.
  currentSupplierMpid: String
}

# An enumeration.
enum GasMeterPointMarketSectorCode {
  # Domestic
  D

  # Industrial
  I
}

# An enumeration.
enum GasMeterPointMarketCategory {
  # SSP
  SSP

  # LSP
  LSP
}

# An enumeration.
enum GasMeterPointMeterOwnershipType {
  # Transporter
  T

  # Supplier
  S

  # Customer
  C
}

# An organization who manages a given meterpoint.
type GasAgentContractType {
  contractType: MamAgentContractContractType!
  agentId: String
  contractStatus: AgentContractStatusType
  effectiveFrom: Date
}

# An enumeration.
enum MamAgentContractContractType {
  # Meter Asset Manager
  MAM
}

type GasAgreementType implements AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  account: AccountType!
  meterPoint: GasMeterPointType!
  tariff: GasTariffType
  isRevoked: Boolean

  # A collection of charges and associated consumption data.
  lineItems(
    startAt: DateTime!

    # Aggregate line items according to this grouping. Note that this doesn't guarantee that the returned items will cover a particular length of time, as it will depend on how the items have been stored, whether the period had daylight savings time changes (and therefore potentially 25 hours) etc.
    grouping: LineItemGroupingOptions!
    itemType: LineItemTypeOptions!

    # Timezone used for grouping.
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): LineItemConnection

  # List of contracted unit rate uplifts applicable during this agreement's duration. This is only applicable to business accounts where we may pay commission to a third-party intermediary.
  unitRateUplifts: [GasContractUnitRateUplift]
}

type GasTariffType implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float

  # Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  tariffCode: String
  unitRate: Float

  # Is EPG applied to the unit rate.
  unitRateEpgApplied: Boolean
  preVatUnitRate: Float
}

type GasContractUnitRateUplift {
  # When this contract is valid from.
  validFrom: DateTime!

  # When this contract is valid until.
  validTo: DateTime!

  # The amount to add to the unit rate when billing, in pence/kWh.
  unitRateUplift: Decimal!
}

# A gas meter reading. The reading value is under the register collection to be consistent with electricity readings. We expect a single register and reading value for gas.
type GasMeterReadingType implements MeterReading {
  id: ID!
  readAt: DateTime
  readingSource: String
  registers: [RegisterReading]
  source: String
}

# An enumeration.
enum GasMeterMechanism {
  # Credit
  CR

  # Electronic Token Meter
  ET

  # Prepayment
  PP

  # Mechanical Token Meter
  MT

  # Coin Meter
  CM

  # Thrift
  TH

  # Non Compliant SMETS Smart Meter
  NS

  # SMETS 1 compliant Smart Meter
  S1

  # SMETS 2 compliant Smart Meter
  S2

  # Unknown
  U
}

# An enumeration.
enum GasMeterStatus {
  # Live
  LI

  # Faulty
  FA

  # Inactive
  IN

  # Cut off
  CU

  # Clamped
  CL

  # Capped
  CA

  # Spin Cap
  SP

  # Removed
  RE

  # Other
  OT

  # Unknown
  UN

  # Not Installed
  NI
}

#
#
# This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
#
#
type GasMeterReadingConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [GasMeterReadingConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `GasMeterReadingConnectionType` and its cursor.
type GasMeterReadingConnectionTypeEdge {
  # The item at the end of the edge
  node: GasMeterReadingType

  # A cursor for use in pagination
  cursor: String!
}

# Gas registers measure consumption.
type GasMeterRegisterType {
  id: ID!
  identifier: String
  digits: Int
  decimalPlaces: Int
  name: String
  expectedReadingRanges: [[Int]]
  unitRateType: String
}

# An enumeration.
enum DeviceType {
  # Electricity Smart Meter (ESME)
  ESME

  # Gas Smart Meter (GSME)
  GSME

  # Gas Proxy Function (GPF)
  GPF

  # Communications Hub Function (CHF)
  CHF

  # HAN Connected Auxiliary Load Control Switch (HCALCS)
  HCALCS

  # Prepayment Interface Device (PPMID)
  PPMID

  # In-House Display (IHD)
  IHD

  # Consumer Access Device (CAD)
  CAD

  # IHD or CAD (a type 2 device)
  IHD_OR_CAD
}

# An enumeration.
enum DeviceStatus {
  # Pending
  PENDING

  # Whitelisted
  WHITELISTED

  # Installed but not commissioned
  INSTALLED_NOT_COMMISSIONED

  # Commissioned
  COMMISSIONED

  # Decommissioned
  DECOMMISSIONED

  # Withdrawn
  WITHDRAWN

  # Suspended
  SUSPENDED

  # In recovery
  RECOVERY

  # Recovered
  RECOVERED

  # Not Applicable
  NOT_APPLICABLE
}

#
#     The mode used by a SMETS2 meter to charge for energy consumed.
#
#     Energy consumption can either be paid for in advance (i.e. prepay / pay-as-you-go)
#     or at some time later (i.e. credit).
#
enum PaymentMode {
  # Prepayment.
  PREPAY

  # Credit.
  CREDIT
}

# An enumeration.
enum DeviceStatuses {
  # Pending
  PENDING

  # Device has been whitelisted
  WHITELISTED

  # Installed but not commissioned
  INSTALLED_NOT_COMMISSIONED

  # Device has been commissioned
  COMMISSIONED

  # Device has been decommissioned
  DECOMMISSIONED

  # Device has been withdrawn
  WITHDRAWN

  # Decice suspended
  SUSPENDED

  # Device is in recovery mode
  RECOVERY

  # Device recovered
  RECOVERED

  # Not applicable
  NOT_APPLICABLE
}

# An enumeration.
enum WANCoverageStrengths {
  # WAN coverage for this postcode is high quality.
  HIGH

  # WAN coverage for this postcode is medium quality.
  MEDIUM

  # WAN coverage for this postcode is low quality.
  LOW
}

# A timeslot for which a property can make an appointment for installation of a smart-meter.
type Smets2InstallationTimeslotType {
  appointmentDate: Date
  startTime: Time
  endTime: Time
}

type PropertySearchResult {
  # A score representing the degree of confidence for a match.
  score: Decimal!

  # The matched property.
  property: PropertyType!
}

# The possible errors that can be raised are:
#
# - KT-CT-9403: Received an invalid portfolioId.
# - KT-CT-9404: Received an invalid accountUserId.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreatePortfolioUserRole {
  possibleErrors: [PossibleErrorType]

  # The created role for a user in association with a portfolio.
  portfolioUserRole: PortfolioUserRoleType
}

# The role a user has in association with one portfolio.
type PortfolioUserRoleType {
  id: ID!
  user: AccountUserType!

  # The portfolio role.
  role: PortfolioUserRoleEnum

  # Portfolio object.
  portfolio: PortfolioType!
}

# User objects are the core of the authentication system. They typically represent a customer who manages a portfolio of one or more accounts.
type AccountUserType {
  id: ID!

  # List of accounts that the user is linked to either via portfolio role or account role.
  accounts(
    # Optionally filter the user's accounts to only return those linked to portfolios on the specified brands.
    allowedBrandCodes: [BrandChoices]

    # Optionally restrict user accounts to only return those linked to portfolios on public facing brands.
    restrictToPublicFacingBrands: Boolean

    # Optionally restrict user accounts to only return those with the specified account numbers.
    restrictToAccountNumbers: [String]

    # Optionally exclude accounts with any of the given account types.
    excludeAccountTypes: [AccountTypeChoices]

    # Optionally exclude accounts that have never had an agreement.
    excludeAccountsWithoutAgreements: Boolean
  ): [AccountInterface]
  givenName: String!
  familyName: String!
  email: String!
  mobile: String!
  landline: String!
  title: String

  # The user's pronouns e.g. 'she/her', 'he/him', 'they/them'.
  pronouns: String

  # Designates whether this user is deceased.
  isDeceased: Boolean!

  # The user's secret key to access the Developer API.
  liveSecretKey: String

  # List of portfolios that the user is linked to via their portfolio roles.
  portfolios(
    # Optionally filter the user's portfolios to only return those linked to specified brands.
    allowedBrandCodes: [BrandChoices]

    # Optionally restrict the user portfolios to only return those linked to public facing brands.
    restrictToPublicFacingBrands: Boolean
    before: String
    after: String
    first: Int
    last: Int
  ): PortfolioConnectionTypeConnection

  # AccountUser's date of birth.
  dateOfBirth: Date

  # List of details linked to this user.
  details: [AccountUserDetailType]

  # We recommend you use fullName instead of this field.
  displayName: String
    @deprecated(
      reason: "The 'displayName' field is deprecated.\n\nPlease use fullName instead of this field.\n\n- Marked as deprecated on 2019-12-11.\n- Will be removed on 2024-01-01."
    )

  # We recommend you use preferredName or fullName instead of this field.
  firstName: String
    @deprecated(
      reason: "The 'firstName' field is deprecated.\n\nUse 'givenName' instead.\n\n- Marked as deprecated on 2020-09-23.\n- Will be removed on 2023-06-05."
    )

  # We recommend you use preferredName or fullName instead of this field.
  lastName: String
    @deprecated(
      reason: "The 'lastName' field is deprecated.\n\nUse 'familyName' instead.\n\n- Marked as deprecated on 2020-09-23.\n- Will be removed on 2023-06-05."
    )

  # The user's full name.
  fullName: String

  # The user's preferred name.
  preferredName: String

  # We recommend you use portfolioIds instead of this field.
  portfolioId: ID
    @deprecated(
      reason: "The 'portfolioId' field is deprecated.\n\nPlease use 'portfolioIds' instead.\n\n- Marked as deprecated on 2022-08-04.\n- Will be removed on 2024-01-01."
    )

  # List of portfolio ids that the user is linked to via their portfolio roles.
  portfolioIds(
    # Optionally filter the user's portfolios to only return those linked to specified brands.
    allowedBrandCodes: [BrandChoices]

    # Optionally restrict the user portfolios to only return those linked to public facing brands.
    restrictToPublicFacingBrands: Boolean
  ): [ID]
  specialCircumstances: SpecialCircumstancesType
  preferences: AccountUserCommsPreferences

  # The user's landline phone number.
  landlinePhoneNumber: String
    @deprecated(
      reason: "The 'landlinePhoneNumber' field is deprecated.\n\nUse 'landline' instead.\n\n- Marked as deprecated on 2021-03-22.\n- Will be removed on 2024-01-01."
    )

  # List of alternative phone numbers for the account user.
  alternativePhoneNumbers: [String]

  # Whether there are family issues.
  hasFamilyIssues: Boolean

  # True if user is linked to an account with an active hardship agreement.
  isInHardship: Boolean

  # List of roles a user has for each account they're linked to.
  accountUserRoles(
    # Optionally filter the user's account roles to only return those linked to specific accounts.
    accountNumber: String
  ): [AccountUserRoleType]

  # List of roles a user has for each portfolio they're linked to.
  portfolioUserRoles(
    # Optionally filter the portfolio's user roles to only return those linked to a specific portfolio.
    portfolioNumber: String

    # Return the user portfolio roles for this account's portfolio.
    accountNumber: String
  ): [PortfolioUserRoleType]

  # List of hold music options.
  holdMusicChoices: [TrackOptionType]
  isOptedInToWof: Boolean
}

# An enumeration.
enum BrandChoices {
  # Octopus Energy.
  OCTOPUS_ENERGY

  # Affect Energy.
  AFFECT_ENERGY

  # Bulb.
  BULB

  # Coop Energy.
  COOP_ENERGY

  # Ebico Living.
  EBICO_LIVING

  # London Power.
  LONDON_POWER
}

# Paginator of Operations Team
type PortfolioConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [PortfolioConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `PortfolioConnectionType` and its cursor.
type PortfolioConnectionTypeEdge {
  # The item at the end of the edge
  node: PortfolioType

  # A cursor for use in pagination
  cursor: String!
}

type AccountUserDetailType {
  # The namespace for the property.
  namespace: String

  # The property value.
  value: String
}

# Information about the special circumstances that relate to a user.
type SpecialCircumstancesType {
  # Whether the user has consented for their data to be given to the appropriate industry or regulatory bodies. We typically only ask for this once, so this field can be used to decide whether to ask the user for their initial consent.
  isSharingConsentGiven: Boolean
  records: [SpecialCircumstanceRecordUnion]
}

union SpecialCircumstanceRecordUnion =
    SpecialCircumstanceRecordType
  | TemporarySpecialCircumstanceRecordType

# Any special circumstances that the user has notified us about, which may entitle them to some specialist services.
type SpecialCircumstanceRecordType {
  id: ID
  summary: String
  internalCode: String
  gasPSRCode: String
  electricityPSRCode: String
}

# Any special circumstances that the user has notified us about, which may entitle them to some specialist services. These circumstances have an end date, after which they will not longer apply. Having young children is an example of this in the UK.
type TemporarySpecialCircumstanceRecordType {
  id: ID
  summary: String
  internalCode: String
  gasPSRCode: String
  electricityPSRCode: String
  expiryDate: Date
}

# Information about the preferences set up for a user.
type AccountUserCommsPreferences {
  # Whether a user has opted in to receive messages from the client or client group. For example, for Octopus Energy this describes whether a user is opted in to offers from Octopus Investments.
  isOptedInToClientMessages: Boolean

  # Whether a user has opted in to receive messages offering discounts or other services not directly related to the services the client provides.
  isOptedInToOfferMessages: Boolean

  # Whether a user has opted in to receive messages we recommend they read, but are not vital to the utilities the client provides. For example, these could be reminders that the client will take a payment.
  isOptedInToRecommendedMessages: Boolean

  # Whether a user has opted in to receive messages updating them on client activities.
  isOptedInToUpdateMessages: Boolean

  # Whether a user has opted in to receive messages from the client's preferred third parties.
  isOptedInToThirdPartyMessages: Boolean

  # What format the user would like to receive their emails in.
  emailFormat: EmailFormats

  # Whether a user has opted to have inverted colours in their emails. This is currently only relevant to the Octopus Energy brand, whose emails have a dark background by default.
  isUsingInvertedEmailColours: Boolean

  # This setting allows the user to adjust the default font size of the communications sent to them.
  fontSizeMultiplier: Float

  # Whether the user has opted in to receive meter reading confirmation emails.
  isOptedInMeterReadingConfirmations: Boolean

  # Whether the user has opted in to receive SMS messages.
  isOptedInToSmsMessages: Boolean

  # Song which will be used as hold music for the user.
  preferredHoldMusic: Songs
}

# An enumeration.
enum EmailFormats {
  TEXT
  HTML
}

# An enumeration.
enum Songs {
  # .
  NO_SONG_PREFERRED

  # Silence.
  SONG_hold_music_4_33_silence

  # Relaxing: Holding Firm by Dan Phillipson.
  SONG_hold_music_holding_firm

  # "Auf Wiederseh’n Sweetheart" by Vera Lynn.
  SONG_1938

  # "I Believe" by Frankie Laine.
  SONG_1939

  # "Secret Love" by Doris Day.
  SONG_1940

  # "Rose Marie" by Slim Whitman.
  SONG_1941

  # "I’ll Be Home" by Pat Boone.
  SONG_1942

  # "Diana" by Paul Anka.
  SONG_1943

  # "Jailhouse Rock" by Elvis Presley.
  SONG_1944

  # "Living Doll" by Cliff Richard.
  SONG_1945

  # "It’s Now or Never" by Elvis Presley.
  SONG_1946

  # "Wooden Heart" by Elvis Presley.
  SONG_1947

  # "I Remember You" by Frank Ifield.
  SONG_1948

  # "She Loves You" by The Beatles.
  SONG_1949

  # "Can’t Buy Me Love" by The Beatles.
  SONG_1950

  # "Tears" by Ken Dodd.
  SONG_1951

  # "Green, Green Grass of Home" by Tom Jones.
  SONG_1952

  # "Release Me" by Engelbert Humperdinck.
  SONG_1953

  # "Hey Jude" by The Beatles.
  SONG_1954

  # "Sugar, Sugar" by The Archies.
  SONG_1955

  # "The Wonder of You" by Elvis Presley.
  SONG_1956

  # "My Sweet Lord" by George Harrison.
  SONG_1957

  # "Amazing Grace" by The Royal Scots Dragoon Guards Band.
  SONG_1958

  # "Tie a Yellow Ribbon Round the Ole Oak Tree" by Dawn.
  SONG_1959

  # "Tiger Feet" by Mud.
  SONG_1960

  # "Bye Bye Baby" by Bay City Rollers.
  SONG_1961

  # "Save Your Kisses for Me" by Brotherhood of Man.
  SONG_1962

  # "Mull of Kintyre" / "Girls’ School" by Wings.
  SONG_1963

  # "Rivers of Babylon" / "Brown Girl in the Ring" by Boney M.
  SONG_1964

  # "Bright Eyes" by Art Garfunkel.
  SONG_1965

  # "Don’t Stand So Close to Me" by The Police.
  SONG_1966

  # "Don’t You Want Me" by The Human League.
  SONG_1967

  # "Come On Eileen" by Dexys Midnight Runners.
  SONG_1968

  # "Karma Chameleon" by Culture Club.
  SONG_1969

  # "I Just Called To Say I Love You" by Stevie Wonder.
  SONG_1970

  # "The Power of Love" by Jennifer Rush.
  SONG_1971

  # "Don’t Leave Me This Way" by The Communards.
  SONG_1972

  # "Never Gonna Give You Up" by Rick Astley.
  SONG_1973

  # "The Only Way Is Up" by Yazz.
  SONG_1974

  # "Ride On Time" by Black Box.
  SONG_1975

  # "Unchained Melody" by The Righteous Brothers.
  SONG_1976

  # "Everything I Do I Do It for You" by Bryan Adams.
  SONG_1977

  # "I Will Always Love You" by Whitney Houston.
  SONG_1978

  # "I’d Do Anything for Love (But I Won’t Do That)" by Meat Loaf.
  SONG_1979

  # "Love Is All Around" by Wet Wet Wet.
  SONG_1980

  # "Unchained Melody" by Robson & Jerome.
  SONG_1981

  # "Killing Me Softly" by Fugees.
  SONG_1982

  # "Candle in the Wind 1997" / "Something About the Way You Look Tonight" by Elton John.
  SONG_1983

  # "Believe" by Cher.
  SONG_1984

  # "...Baby One More Time" by Britney Spears.
  SONG_1985

  # "Pure Shores" by All Saints.
  SONG_1986

  # "It Wasn’t Me" by Shaggy featuring Rikrok.
  SONG_1987

  # "Anything Is Possible" / "Evergreen" by Will Young.
  SONG_1988

  # "Where Is the Love?" by The Black Eyed Peas.
  SONG_1989

  # "Call On Me" by Eric Prydz.
  SONG_1990

  # "Is This the Way to Amarillo" by Tony Christie featuring Peter Kay.
  SONG_1991

  # "Crazy" by Gnarls Barkley.
  SONG_1992

  # "Bleeding Love" by Leona Lewis.
  SONG_1993

  # "Hallelujah" by Alexandra Burke.
  SONG_1994

  # "Poker Face" by Lady Gaga.
  SONG_1995

  # "Just The Way You Are" by Bruno Mars.
  SONG_1996

  # "Someone Like You" by Adele.
  SONG_1997

  # "Somebody That I Used to Know" by Gotye featuring Kimbra.
  SONG_1998

  # "Get Lucky" by Daft Punk.
  SONG_1999

  # "Happy" by Pharrell Williams.
  SONG_2000

  # "Uptown Funk" by Mark Ronson featuring Bruno Mars.
  SONG_2001

  # "7 Years" by Lukas Graham.
  SONG_2002

  # "Shape of You" by Ed Sheeran.
  SONG_2003
}

# The role a user has in association with one account.
type AccountUserRoleType {
  id: ID!
  user: AccountUserType!
  account: AccountType!

  # The account role.
  role: AccountUserRoleEnum
}

# An enumeration.
enum AccountUserRoleEnum {
  LOYALTY_POINT_USER
  ADMIN
  CARER
  TRACED
}

# Key value pair for the choice of tracks.
type TrackOptionType {
  # The title of the track.
  trackTitle: String

  # The value save for the user to indicate their choice of track.
  trackCode: String
}

# An enumeration.
enum PortfolioUserRoleEnum {
  LOYALTY_POINT_USER
  ADMIN
  CARER
  TRACED
}

input CreatePortfolioUserRoleInput {
  # The portfolio to associate the user with.
  portfolioId: ID!

  # The user to associate with the portfolio.
  accountUserId: ID!

  # The role to assign to the user. If not provided the default role will be used.
  role: PortfolioUserRoleEnum = null
}

type TaskResult {
  # The status of the task.
  status: TaskStatusEnum

  # The result of the task.
  result: JSONString

  # The error message if the task failed.
  error: String
}

# An enumeration.
enum TaskStatusEnum {
  STARTED
  FAILED
  FINISHED
}

type WeeklyUsageInsightsType {
  # The account identifier.
  accountId: Int

  # The meter point identifier.
  meterPointId: Int

  # The Monday of the week in question.
  weekStart: DateTime

  # The account number of the customer.
  accountNumber: String

  # The property identifier.
  propertyId: Int

  # Corresponding MPAN.
  mpan: String

  # The GSP.
  gspGroupId: String

  # The name given to the GSP as per NG API.
  apiGspGroupName: String

  # The total consumption over that week period.
  consumptionKwh: String

  # The corresponding total grams of C02 over that week period.
  carbonGrams: Float

  # Achieved unit rate over that week period.
  achievedCarbonRate: Float

  # The corresponding index (very-low, low, moderate, high, very-high).
  achievedCarbonIndex: AchievedCarbonIndexChoices

  # The first meter reading we have for this customer within week period.
  periodStart: DateTime

  # The last meter reading we have for this customer within week period.
  periodEnd: DateTime

  # The number of smart meter readings we have within the week period (should be 336).
  numberPeriods: String

  # Whether or not the customer has full readings within the week period.
  hasFullReadings: String

  # If the week is the latest week i.e if the date is 2024-03-06 (Wed) then the latest full week should be 2024-02-26 (Mon).
  isLatestWeek: String

  # Where the customer ranks for carbon intensity within their region. (1=Greenest, 100=Dirtiest).
  achievedCarbonRank: String
}

# An enumeration.
enum AchievedCarbonIndexChoices {
  VERY_LOW
  LOW
  MODERATE
  HIGH
  VERY_HIGH
}

# A greenness forecast entry for a single period of time.
type GreennessForecastPeriod {
  # The start of the forecast period (inclusive).
  validFrom: DateTime

  # The end of the forecast period (exclusive).
  validTo: DateTime

  # The greenness score 0-100 (higher is greener).
  greennessScore: Int

  # The greenness index LOW/MEDIUM/HIGH (higher is greener) to map to a localised value.
  greennessIndex: GreennessForecastIndex

  # Indicates that this is one of the best periods in the forecast (there may be more than one). This may not consider the entire forecast and can be ignored or calculated client-side from the score.
  highlightFlag: Boolean
}

# The greenness index LOW/MEDIUM/HIGH (higher is greener).
enum GreennessForecastIndex {
  LOW
  MEDIUM
  HIGH
}

type FanClubStatus {
  # The source for the discount, e.g. 'Fan 1' for a wind turbine in UK, or an ERCOT Load Zone for US.
  discountSource: String!

  # The name of the discount source.
  name: String!

  # The location of the discount source.
  location: String

  # The wind farm that the discount source is part of.
  windFarm: String

  # The list of account numbers for the source and account user.
  accountNumbers: [String]!

  # The list of property IDs for the source and account user.
  propertyIds: [Int]!

  # The list of catchments that this discount source applies to.
  catchments: [String]!

  # The details of Fan Club thresholds for the discount source.
  thresholds: [Threshold]!

  # The current or 'live' status of discounts for this source.
  current: DiscountData!

  # The historic discounts for this source.
  historic: [DiscountData]!

  # The forecasted discount probabilities for this source.
  forecast: DiscountForecast
}

type Threshold {
  # The power (kW) that must be surpassed to achieve the corresponding discount.
  power: Decimal

  # The discount that is rewarded when the power crosses the corresponding threshold. Ranges from 0.0 - 1.0.
  discount: Decimal

  # The wind speed (m/s) that corresponds to the power cut-off for this threshold.
  windSpeed: Decimal
}

type DiscountData {
  # Timestamp for the discount.
  startAt: DateTime!

  # The discount as a decimal between 0 and 1.
  discount: Decimal!

  # This type will return additional market specific information.
  #     For example, some markets support wind direction, fan speed, wind speed, etc.
  #     while others do not.
  metaData: FanClubMetadataOutput
}

type FanClubMetadataOutput {
  # The instantaneous turbine output power in kW.
  power: Decimal

  # The wind speed in m/s.
  windSpeed: Decimal

  # A decimal in degrees representing the direction from which the wind is blowing.
  #     360.0 degrees indicates the wind blows from the north.
  #     Read more here: https://confluence.ecmwf.int/pages/viewpage.action?pageId=133262398
  #
  windDirection: Decimal

  # The turbine's rotor speed in revolutions per minute.
  rotorSpeed: Decimal

  # The total amount of electricity grid-wide from wind in megawatts.
  windPowerOnGrid: Decimal

  # The total amount of electricity grid-wide from all sources in megawatts.
  totalPowerOnGrid: Decimal

  # The proportion of electricity on the grid coming from wind. Ranges from 0.0 - 1.0.
  windPowerProportion: Decimal
}

type DiscountForecast {
  # The start time that the ensemble forecast simulation.
  baseTime: DateTime!

  # Discount forecast data-points.
  data: [ForecastData]!
}

type ForecastData {
  # Timestamp for the data-point.
  validTime: DateTime!

  # Projected discount based on ensemble forecast data.
  projectedDiscount: Decimal!

  # The best guess for forecasted power (kW).
  powerMedian: Decimal!

  # Lower confidence interval bound for forecasted power (kW).
  powerLowerBound: Decimal!

  # Upper confidence interval bound for forecasted power (kW).
  powerUpperBound: Decimal!
}

# Try to enroll an account onto Fan Club.
#
# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-CT-8104: Account already enrolled.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type EnrollFanClubAccount {
  possibleErrors: [PossibleErrorType]

  # Result of the Fan Club enrollment.
  enrollmentOutput: EnrollFanClubAccountOutputType
}

type EnrollFanClubAccountOutputType {
  status: Eligibility
}

# An enumeration.
enum Eligibility {
  ELIGIBLE
  BUSINESS_ACCOUNT
  NO_ACTIVE_AGREEMENTS
  HAS_SMART_TARIFF
  ONBOARDING_TO_SMART_TARIFF
  INVALID_CATCHMENT
  CAPPED_CATCHMENT
  NO_SMART_METER
  INCORRECT_READ_PERMISSION
  NO_RECENT_READING
}

# The input type for signing an account up to Fan Club.
input JoinFanClubInput {
  # The account number.
  accountNumber: String!

  # The list of valid catchment areas.
  catchments: [String]!

  # The list of catchments that have exceeded the member cap.
  cappedCatchments: [String]

  # User's email address.
  email: String!
}

# Send a push notification of there being a high likelihood of getting a Fan Club discount.
#
# The possible errors that can be raised are:
#
# - KT-CT-8106: No catchments provided.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type FanClubDiscountNotification {
  possibleErrors: [PossibleErrorType]

  # Boolean indicating if Fan Club notifications were triggered.
  success: Boolean!
}

# The input type for sending Fan Club push notifications for discounts.
input FanClubDiscountNotificationInput {
  # The list of valid catchment areas.
  catchments: [String]!

  # The start time of the likely Fan Club discount.
  startAt: DateTime!

  # The end time of the likely Fan Club discount.
  endAt: DateTime!
}

# The possible errors that can be raised are:
#
# - KT-CT-8107: Invalid eligibility status.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type FanClubNonOctopusCustomerComms {
  possibleErrors: [PossibleErrorType]

  # Flag for whether Fan Club comms for non-Octopus customer were sent.
  success: Boolean!
}

input FanClubNonOctopusCustomerCommsInput {
  # Email address for the customer
  email: String!

  # The eligibility status of the customer
  eligibility: String!
}

type AvailableSpinsType {
  # Spin information for an electricity agreement.
  electricity: SupplyTypeSpecificSpinsType

  # Spin information for a gas agreement.
  gas: SupplyTypeSpecificSpinsType
}

type SupplyTypeSpecificSpinsType {
  # The maximum number of spins per month, per fuel type.
  maxSpinsPerMonth: Int

  # The number of spins remaining for this month, per fuel type.
  remainingSpinsThisMonth: Int

  # The number of spins used this month, per fuel type.
  usedSpinsThisMonth: Int
}

type WheelSegmentsType {
  # The integer values that make up the WoF segments.
  segments: [Int]
}

# The possible errors that can be raised are:
#
# - KT-CT-7011: Terms must be accepted.
# - KT-CT-7023: Unauthorized.
# - KT-CT-7010: The account does not have any available submissions.
# - KT-CT-7012: Wheel of Fortune submission error.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SpinWheelOfFortune {
  possibleErrors: [PossibleErrorType]

  #  The result of the Wheel of Fortune spin.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  spinResult: WheelOfFortuneSpinResultType
}

type WheelOfFortuneSpinResultType {
  # The amount won in cents.
  prizeAmount: Int
}

input WheelOfFortuneSpinInput {
  # The number of the account for which readings are submitted.
  accountNumber: String!

  # The supply type that the spin should be registered for.
  supplyType: SupplyType!

  # Indication whether the user has accepted the WoF terms and conditions.
  termsAccepted: Boolean!
}

# An enumeration.
enum SupplyType {
  ELECTRICITY
  GAS
}

type CreateAccountFileAttachmentPayload {
  postRequest: UploadPostRequest
  clientMutationId: String
}

# Information that should be used in the POST request to the S3 API.
#
# For more details please see [this](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/s3-presigned-urls.html#generating-a-presigned-url-to-upload-a-file).
type UploadPostRequest {
  url: String!
  fields: JSONString!
  key: String!
}

input CreateAccountFileAttachmentInput {
  filename: String!
  accountNumber: String!
  category: Category!
  clientMutationId: String
}

# An enumeration.
enum Category {
  FILE_ATTACHMENT_MCS_CERT
  FILE_ATTACHMENT_DNO_LETTER
  FILE_ATTACHMENT_FLEXI_ORB_CERT
  FILE_ATTACHMENT_HEAT_PUMP_HANDOVER_DOCUMENT
}

# The possible errors that can be raised are:
#
# - KT-CT-8710: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type TriggerPostUploadOperations {
  possibleErrors: [PossibleErrorType]
  operationsTriggered: Boolean
}

type SmartFlexBattery implements SmartFlexDeviceInterface {
  # A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  id: ID!

  # The user-friendly name for the device.
  name: String

  # The type of device.
  deviceType: KrakenFlexDeviceTypes!

  # The third-party that enables control of this device.
  provider: ProviderChoices!

  # Information about the current status of this device.
  status: SmartFlexDeviceStatusInterface

  # Active alert message(s) for a device, showing the latest first.
  alerts: [SmartFlexDeviceAlertInterface]

  # The current onboarding wizard for a device.
  onboardingWizard: SmartFlexOnboardingWizard

  # Make of the battery.
  make: String

  # Model of the battery.
  model: String
}

type BatteryDeviceType {
  # ID of the device in KrakenFlex.
  krakenflexDeviceId: ID

  # Batteries.
  deviceType: KrakenFlexDeviceTypes

  # Battery integration provider (make).
  provider: ProviderChoices

  # Device specific parameters.
  params: BatteryParamsType

  # The current status of the battery (e.g. connected, state of charge, power).
  deviceStatus: DeviceStatusType

  # The charging preferences of the battery (e.g. min / max state of charge %).
  chargingPreferences: BatteryChargingPreferencesType
}

type BatteryParamsType {
  # ID of the battery variant.
  variantId: ID
}

type DeviceStatusType {
  # The lifecycle status of the device.
  status: KrakenFlexDeviceStatusChoices
    @deprecated(
      reason: "The 'status' field is deprecated.\n\nPlease use the 'devices' query instead.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-06."
    )

  # Whether control of the device has been temporarily suspended.
  suspended: Boolean

  # The maximum import power of the device in kilowatts.
  maxImportInKw: Float

  # The maximum export power of the device in kilowatts.
  maxExportInKw: Float

  # Whether device is connected.
  pluggedIn: Boolean

  # Device status telemetry readings.
  readings: DeviceStatusReadingsType
}

# The current lifecycle status of a KrakenFlex device on the smarter tariff API:
#
# - `ONBOARDING` indicates the device has been registered on the system but has not yet completed the on-boarding process.
#     - Including a test charge step, to validate that communication and control of the device is possible within expected limits.
# - `ONBOARDING_TEST_IN_PROGRESS` indicates that there is a test charge in progress for the device.
# - `LIVE` indicates that the device has completed the on-boarding process and is ready for control.
# - `FAILED_ONBOARDING_TEST` indicates that there has been an issue validating that the device can be reliably communicated with or controlled on the system.
# - `RETIRED` indicates that the device has no connection details and is not currently available for control.
enum KrakenFlexDeviceStatusChoices {
  ONBOARDING
  PENDING_LIVE
  LIVE
  ONBOARDING_TEST_IN_PROGRESS
  FAILED_ONBOARDING_TEST
  RETIRED
}

type DeviceStatusReadingsType {
  # Device charging power in kilowatts (kW) - negative for import, positive for export.
  activePowerInKw: DeviceStatusReadingType

  # Energy stored in the device in kilowatt-hours (kWh).
  energyInKwh: DeviceStatusReadingType

  # State of charge of the battery in % (may not be a whole number).
  socPercentage: DeviceStatusReadingType
}

type DeviceStatusReadingType {
  # Value of the reading.
  value: Float!

  # Timestamp of the reading.
  timestamp: DateTime!
}

type BatteryChargingPreferencesType {
  # The minimum state of charge (soc) %.
  minimumSocPercentage: Int

  # The maximum state of charge (soc) %.
  maximumSocPercentage: Int
}

type BatteryVariantsType {
  # Make of the home battery.
  make: String

  # List of home battery models per make.
  models: [BatteryVariantModelsType]
}

type BatteryVariantModelsType {
  # ID of the battery variant.
  variantId: ID

  # Model name of the battery.
  model: String

  # Coupling type (AC/DC).
  couplingType: BatteryCouplingType

  # Usable capacity in kWh.
  batteryCapacityInKwh: Decimal

  # Max import/export power in kW.
  maxPowerInKw: Decimal

  # Whether an integration/make is live, i.e. available.
  isIntegrationLive: Boolean

  # Whether a variant is deprecated.
  isDeprecated: Boolean
}

# An enumeration.
enum BatteryCouplingType {
  AC
  DC
}

# Allow customers to set/update their battery's charging preferences.
#
# The possible errors that can be raised are:
#
# - KT-CT-4321: Serializer validation error.
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-4353: An error occurred while trying to update your charging preferences.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SetBatteryChargingPreferences {
  possibleErrors: [PossibleErrorType]

  # The battery device updated, with the ID of the device in KrakenFlex.
  krakenflexDevice: BatteryDeviceType
}

input BatteryChargingPreferencesInput {
  # Account number.
  accountNumber: String!

  # The minimum state of charge (soc) %.
  minimumSocPercentage: Int!
}

type ControllerStatus {
  # The status and telemetry information of a sensor.
  sensors: [SensorStatus]

  # The status and telemetry information of a zone.
  zones: [ZoneStatus]
}

type SensorStatus {
  # The code name for a sensor.
  code: String

  # The connectivity/online status of a sensor.
  connectivity: SensorConnectivity

  # The telemetry data of a sensor.
  telemetry: SensorTelemetry
}

type SensorConnectivity {
  # Whether or not a sensor is currently online.
  online: Boolean

  # Time at which the status was retrieved.
  retrievedAt: DateTime
}

type SensorTelemetry {
  # Temperature recorded by a sensor in celsius.
  temperatureInCelsius: Float

  # Percentage humidity recorded by the sensor.
  humidityPercentage: Int

  # Signal strength of a sensor measured in dBm (Received Signal Strength Indicator).
  rssi: Int

  # Deprecated.
  rssiPercentage: Int
    @deprecated(
      reason: "The 'rssiPercentage' field is deprecated.\n\nUse rssi instead.\n\n- Marked as deprecated on 2023-05-17.\n- Will be removed on 2023-05-31."
    )

  # Voltage recorded by a sensor.
  voltage: Float

  # Time at which the telemetry was retrieved.
  retrievedAt: DateTime
}

type ZoneStatus {
  # The heat pump controller zone, i.e. WATER, ZONE_1, ZONE_2 or AUXILIARY.
  zone: Zone

  # The telemetry data of a zone.
  telemetry: ZoneTelemetry
}

# An enumeration.
enum Zone {
  WATER
  ZONE_1
  ZONE_2
  AUXILIARY
}

type ZoneTelemetry {
  # Target temperature for a zone, in celsius.
  setpointInCelsius: Float

  # Heating mode in zone.
  mode: Mode

  # Whether relay is currently switched on (True) or off (False).
  relaySwitchedOn: Boolean

  # Whether there is demand for heat (True) or not (False).
  heatDemand: Boolean

  # Time at which the telemetry was retrieved.
  retrievedAt: DateTime
}

# An enumeration.
enum Mode {
  ON
  OFF
  AUTO
  BOOST
}

type ControllerAndZoneConfiguration {
  # Controller configuration.
  controller: ControllerConfiguration

  # List of zones with their configuration and schedules.
  zones: [ZoneInformation]

  # Controller configuration.
  heatPump: HeatPumpConfiguration
}

type ControllerConfiguration {
  # Controller firmware options for ESP and EFR chips.
  firmwareConfiguration: FirmwareConfiguration

  # Current state of the controller.
  state: [State]

  # 8 character password used to access the access point mode webpage.
  accessPointPassword: String

  # Timezone the controller is in.
  heatPumpTimezone: String

  # Whether or not the controller is currently connected.
  connected: Boolean

  # When the controller was last reset.
  lastReset: DateTime
}

type FirmwareConfiguration {
  # ESP32 firmware version (EFI System Partition).
  esp32: String

  # EFR32 firmware version (Emergency Firmware Recovery).
  efr32: String

  # The EUI of the controller being queried.
  eui: String
}

# An enumeration.
enum State {
  NORMAL_MODE
  EMERGENCY_MODE
  FAULT_MODE
  BLE_MODE
  AP_MODE
  SETUP
  FACTORY_RESTORE
}

type ZoneInformation {
  # Configuration for a zone.
  configuration: ZoneConfiguration

  # The heating schedules being used by this zone.
  schedules: [Schedule]
}

type ZoneConfiguration {
  # Code name of the zone.
  code: Zone

  # What the zone is used for (heating, water etc).
  zoneType: ZoneType

  # Enabled allows zone to heat when `callForHeat` is True.
  enabled: Boolean

  # User determined name for a zone.
  displayName: String

  # Primary sensor for the zone.
  primarySensor: String

  # Current operation.
  currentOperation: ZoneCurrentOperation

  # Previous operation.
  previousOperation: ZonePreviousOperation

  # Whether the zone is calling for heat.
  callForHeat: Boolean

  # Whether there is demand for heat (True) or not (False).
  heatDemand: Boolean

  # Default mode, if the zone loses connection to the primary sensor.
  emergency: Boolean

  # All associated sensors and ADCs.
  sensors: [SensorConfiguration]
}

enum ZoneType {
  HEAT
  WATER
  AUX
  EXT
  DIV
}

type ZoneCurrentOperation {
  # Heating mode in zone.
  mode: Mode

  # Target temperature for a zone, in celsius.
  setpointInCelsius: Float

  # For zones which do not support setpoints, whether the operation was an ON or an OFF.
  action: OperationAction

  # End time for the current operation.
  end: DateTime
}

# Whether the action was a turn-on or a turn-off.
enum OperationAction {
  ON
  OFF
}

type ZonePreviousOperation {
  # Heating mode in zone.
  mode: Mode

  # Target temperature for a zone, in celsius.
  setpointInCelsius: Float

  # For zones which do not support setpoints, whether the operation was an ON or an OFF.
  action: OperationAction
}

union SensorConfiguration = ADCSensorConfiguration | ZigbeeSensorConfiguration

type ADCSensorConfiguration implements SensorConfigurationInterface {
  # Code name of the sensor.
  code: String

  # User determined name for a sensor.
  displayName: String

  # Sensor type (NTC).
  type: SensorType

  # Whether or not a sensor is enabled.
  enabled: Boolean
}

interface SensorConfigurationInterface {
  # Code name of the sensor.
  code: String

  # User determined name for a sensor.
  displayName: String
}

# An enumeration.
enum SensorType {
  ZIGBEE
  NTC
  TSTAT
}

type ZigbeeSensorConfiguration implements SensorConfigurationInterface {
  # Code name of the sensor.
  code: String

  # User determined name for a sensor.
  displayName: String

  # Sensor type (Zigbee).
  type: SensorType

  # Sensor ID.
  id: ID

  # Sensor firmware version.
  firmwareVersion: String

  # Whether or not boost is enabled for a sensor.
  boostEnabled: Boolean
}

type Schedule {
  # A bitmask of the days this program is active for.
  days: String

  # The settings which make up this schedule.
  settings: [Setting]
}

type Setting {
  # The time this setting becomes active.
  startTime: Time

  # Whether the setting turns the zone on or off, or changes its temperature.
  action: String

  # Desired zone temperature (for zones which support setpoints).
  setpointInCelsius: Float
}

type HeatPumpConfiguration {
  # The serial number of the heat pump.
  serialNumber: String

  # The heat pump model (eg. COSY).
  model: String

  # The hardware version.
  hardwareVersion: String

  # Any fault codes present on the device.
  faultCodes: [String]

  # The weather compensation settings currently in place.
  weatherCompensation: WeatherCompensationConfiguration

  # The flow temperature set for heating.
  heatingFlowTemperature: FlowTemperatureConfiguration

  # Whether the system has a manifold set up.
  manifoldEnabled: Boolean

  # Whether the system has a hot water cylinder (tank) which is compatible with heat pumps.
  hasHeatPumpCompatibleCylinder: Boolean

  # The maximum temperature which the hot water can be set to.
  maxWaterSetpoint: Float

  # The minimum temperature which the hot water can be set to.
  minWaterSetpoint: Float
}

type WeatherCompensationConfiguration {
  # Whether weather compensation is enabled or not.
  enabled: Boolean!

  # The minimum and maximum temperatures which may be selected, dictated by the device.
  allowableRange: TemperatureRange!

  # The min and max flow temperatures currently selected by the user.
  currentRange: TemperatureRange!
}

type TemperatureRange {
  # The minimum allowable temperature in range.
  minimum: Temperature

  # The maximum allowable temperature in range.
  maximum: Temperature
}

# Describes the temperature of something that is relevant to the heating system.
type Temperature {
  # The temperature measured.
  value: Decimal

  # The units in which the temperature is being measured.
  unit: TemperatureUnit!
}

# An enumeration.
enum TemperatureUnit {
  DEGREES_CELSIUS
}

type FlowTemperatureConfiguration {
  # The minimum and maximum temperatures which may be selected, dictated by the device.
  allowableRange: TemperatureRange!

  # The flow temperature currently selected by the user.
  currentTemperature: Temperature!
}

type ControllerAtLocation {
  # The controller attached to the account.
  controller: Controller!

  # The model of the heat pump.
  heatPumpModel: String!

  # The location at which the device exists.
  location: Location!

  # When the controller was provisioned (at this location for this account).
  provisionedAt: DateTime
}

type Controller {
  # The EUID of the controller.
  euid: String!
}

type Location {
  # The property ID of the location.
  propertyId: ID!
}

# A container for some basic metrics relevant to the current state of the heating system.
type LiveTelemetry {
  # When these measurements were taken.
  readAt: DateTime!

  # The coefficient of performance at the time of measurement.
  coefficientOfPerformance: Decimal

  # The power being drawn by the heat pump at a given time.
  powerInput: Power!

  # The rate of heat flow from the heat pump at a given time.
  heatOutput: Power!

  # The temperature outdoors.
  outdoorTemperature: Temperature!
}

# Describes the power (not energy) being consumed (as electricity) or returned (as heat) by
# the system at a given point in time.
#
# Differs from `Energy` in that it describes the *rate* at which energy is being transferred at
# a given point in time.
type Power {
  # The amount of power (not energy) transmitted to or from the heat pump.
  value: Decimal

  # The units in which the power is being measured.
  unit: PowerUnit!
}

# An enumeration.
enum PowerUnit {
  KILOWATT
}

# A container for some basic metrics to show how the heating system has performed over its lifetime.
#
# Note that "its lifetime" may not be the actual life of the heat pump, but may have been reset
# when it was last provisioned.
type LifetimeTelemetry {
  # When these measurements were taken.
  readAt: DateTime!

  # The average lifetime coefficient of performance up to the time of measurement.
  seasonalCoefficientOfPerformance: Decimal

  # The electrical energy drawn by the heat pump over its lifetime.
  energyInput: Energy!

  # The heat energy emitted by the heat pump over its lifetime.
  heatOutput: Energy!
}

# Describes the energy (not power) consumed (as electricity) or returned (as heat) by the
# system over a given span of time.
#
# Differs from `Power` in that it describes the *total* amount of energy transferred during a
# given time frame (not a single point in time).
type Energy {
  # The amount of energy (not power) transmitted to or from the heat pump.
  value: Decimal

  # The units in which the power is being measured.
  unit: EnergyUnit!
}

# An enumeration.
enum EnergyUnit {
  KILOWATT_HOUR
}

type HeatPumpPerformanceGroupingNode {
  # The start datetime of the node.
  startAt: DateTime!

  # The end datetime of the node.
  endAt: DateTime!

  # The field to show energy input.
  energyInput: Energy

  # The field to show energy output.
  energyOutput: Energy

  # The field to show outdoor temperature.
  outdoorTemperature: Temperature
}

# The time interval that we report the performance for.
enum PerformanceGrouping {
  LIVE
  DAY
  WEEK
  MONTH
  YEAR
}

type HeatPumpTimeRangedPerformance {
  # The coefficient of performance (COP) of the heat pump.
  coefficientOfPerformance: Decimal

  # The field to show energy input.
  energyInput: Energy!

  # The field to show energy output.
  energyOutput: Energy!
}

# The possible errors that can be raised are:
#
# - KT-CT-4332: Invalid data.
# - KT-CT-4304: Error in preprovisioning step for Octopus Heat Pump.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type RequestProvisioningClaimCertificate {
  possibleErrors: [PossibleErrorType]

  # The certificate and private key required to create a provisioning claim.
  provisioningClaimBundle: ProvisioningClaimBundle
}

type ProvisioningClaimBundle {
  # The certificate which the controller will present to AWS IoT in order to validate its provisioning claim. It will contain the public key of the controller, and be signed by KF.
  certificate: String

  # This is the private key which will be used by the controller to make the provisioning claim, encrypted with the public key of the controller.
  encryptedPrivateKey: String

  # The AWS IoT endpoint hostname to connect to AWS APIs & services.
  awsIotHostname: String
}

input ProvisioningClaimRequestParameters {
  # The EUID of the device we are trying to provision.
  euid: String!

  # A string representing the number of whole milliseconds since the epoch.
  timestamp: String!

  # The SHA256 hash of the EUID and timestamp.
  nonce: String!

  # The signature of the nonce generated by the device's private key.
  signature: String!
}

# Turn a heating controller zone ON/OFF, set it to AUTO or BOOST it.
#
# The possible errors that can be raised are:
#
# - KT-CT-4333: Invalid data.
# - KT-CT-4306: Error setting mode for heat pump controller zone.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SetZoneMode {
  possibleErrors: [PossibleErrorType]

  # Unique ID associated with a zone's mode operation.
  transactionId: ID
}

input SetZoneModeParameters {
  # The heat pump controller zone, i.e. WATER, ZONE_1, ZONE_2 or AUXILIARY.
  zone: Zone!

  # The zone mode, i.e. ON, OFF, AUTO or BOOST.
  mode: Mode!

  # Target temperature for a zone in celsius.
  setpointInCelsius: FloatSafeDecimal

  # Time at which boost should end.
  endAt: DateTime
}

# A subclass of the Decimal type which can handle floating point values gracefully by
# converting them to strings before trying to convert them to Decimals.
#
# To see why this is valuable, consider the following python shell session where we construct
# Decimal values from floats and strings in turn:
#
# > initial_val = 20.6
#
# > Decimal(initial_val)
#   Decimal('20.60000000000000142108547152020037174224853515625')
#
# > Decimal(str(initial_val))
#   Decimal('20.6')
#
#
# * NOTE ON EDGE CASES FOR HIGH PRECISION INPUTS *
#
# Note that cpython itself only retains up to 17 digits of precision for a float, and
# disregards the rest, so if your *input* is a really big float, then this won't do you much
# good, because:
#
# > str(float('1.11111111111111111111111111111111111111111111111'))
#   '1.1111111111111112'
#
# - whereas
#
# > str(Decimal('1.11111111111111111111111111111111111111111111111'))
#   '1.11111111111111111111111111111111111111111111111'
#
# But that's not really the problem this class is trying to help with. It's to help with what
# look like 'simple' numbers (like 20.2), which end up being converted to very long ones with a
# slightly different value when converted to a decimal.
scalar FloatSafeDecimal

# De-provision a heating controller device.
#
# The possible errors that can be raised are:
#
# - KT-CT-4307: Error deprovisioning an Octopus heat pump.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type DeprovisionHeatingController {
  possibleErrors: [PossibleErrorType]

  # The message to display to the user upon successful device de-provisioning.
  message: String
}

# Set a heating controller zone's schedule(s).
#
# The possible errors that can be raised are:
#
# - KT-CT-4334: Invalid data.
# - KT-CT-4308: Error setting schedule(s) for heat pump controller zone.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SetZoneSchedules {
  possibleErrors: [PossibleErrorType]

  # Unique ID associated with adding schedule(s) for a zone.
  transactionId: ID
}

input SetZoneSchedulesParameters {
  # The heat pump controller zone, i.e. WATER, ZONE_1, ZONE_2 or AUXILIARY.
  zone: Zone!

  # The schedule(s) to be set for a specific zone.
  schedules: [ZoneSchedule]!
}

input ZoneSchedule {
  # Days of the week a schedule should be active, Sunday through Saturday, in bitmask format,e.g. Sun, Tue, Wed => 1011000.
  days: String!

  # Settings in a schedule for the selected day(s).
  settings: [ScheduleSettings]!
}

input ScheduleSettings {
  # Time for when settings should be active, in `HH:MM` (24h) format .
  time: Time!

  # Whether this setting turns the zone on or off, or changes its temperature.
  action: String!

  # Desired zone temperature (for zones which support setpoints).
  setpointInCelsius: FloatSafeDecimal
}

# Remove a sensor from a heating controller device.
#
# The possible errors that can be raised are:
#
# - KT-CT-4309: Error trying to remove sensor from heat pump controller.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type RemoveSensor {
  possibleErrors: [PossibleErrorType]

  # Unique ID associated with removing a sensor from a heat pump controller.
  transactionId: ID
}

# The possible errors that can be raised are:
#
# - KT-CT-4321: Serializer validation error.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type UpdateSensorDisplayName {
  possibleErrors: [PossibleErrorType]

  # Unique ID associated with updating a sensor attribute.
  transactionId: ID
}

# The possible errors that can be raised are:
#
# - KT-CT-4321: Serializer validation error.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type UpdateWaterSetpoint {
  possibleErrors: [PossibleErrorType]

  # Unique ID associated with this operation.
  transactionId: ID
}

# The possible errors that can be raised are:
#
# - KT-CT-4321: Serializer validation error.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type BulkUpdateSensorDisplayName {
  possibleErrors: [PossibleErrorType]

  # A mapping of transaction ids for each sensor.
  transactionIds: [SensorUpdateTransactionId]
}

# A mapping of sensor codes to transaction ids as returned from a successful KF request.
type SensorUpdateTransactionId {
  # The code of the sensor which was updated.
  sensorCode: String!

  # A UUID representing the update operation for this sensor.
  transactionId: String!
}

# A mapping of sensor codes to the display names we would like those sensors to have.
input SensorDisplayNameUpdate {
  # The code of the sensor you want to update.
  sensorCode: String!

  # The new display name to set for this sensor.
  newDisplayName: String!
}

# Reboot a heating controller.
#
# The possible errors that can be raised are:
#
# - KT-CT-1113: Disabled GraphQL field requested.
#
type RebootHeatingController {
  possibleErrors: [PossibleErrorType]

  # The unique ID associated with this reboot operation.
  transactionId: ID
}

# Set the primary sensor for a zone.
#
# The primary sensor is the one which controls the heating for that zone. Other sensors merely
# provide data, at least currently.
#
# The possible errors that can be raised are:
#
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SetZonePrimarySensor {
  possibleErrors: [PossibleErrorType]

  # The unique ID associated with this operation.
  transactionId: ID
}

input SetZonePrimarySensorParameters {
  # The heat pump controller zone.
  zone: Zone!

  # The code for the sensor we want to make primary, such as 'SENSOR01'.
  sensorCode: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-4321: Serializer validation error.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type UpdateFlowTemperatureConfiguration {
  possibleErrors: [PossibleErrorType]

  # Unique ID associated with this operation.
  transactionId: ID
}

input FlowTemperatureInput {
  # Whether weather compensation should be enabled or not.
  useWeatherCompensation: Boolean!

  # The min and max temperatures for when weather compensation is enabled.
  weatherCompensationValues: TemperatureRangeInput = null

  # Flow temperature if weather compensation is off.
  flowTemperature: TemperatureInput = null
}

# An input type to represent a finite temperature range.
input TemperatureRangeInput {
  # The minimum allowable temperature in range.
  minimum: TemperatureInput!

  # The maximum allowable temperature in range.
  maximum: TemperatureInput!
}

# Describes the temperature of something that is relevant to the heating system.
input TemperatureInput {
  # The temperature measured.
  value: Decimal!

  # The units in which the temperature is being measured.
  unit: TemperatureUnit!
}

# Information about an inverter that has been registered with KrakenFlex.
type SmartFlexInverter implements SmartFlexDeviceInterface {
  # A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  id: ID!

  # The user-friendly name for the device.
  name: String

  # The type of device.
  deviceType: KrakenFlexDeviceTypes!

  # The third-party that enables control of this device.
  provider: ProviderChoices!

  # Information about the current status of this device.
  status: SmartFlexDeviceStatusInterface

  # Active alert message(s) for a device, showing the latest first.
  alerts: [SmartFlexDeviceAlertInterface]

  # The current onboarding wizard for a device.
  onboardingWizard: SmartFlexOnboardingWizard

  # The make of the inverter.
  make: String

  # The model of the inverter.
  model: String

  # Telemetry data for the inverter.
  telemetry: SmartFlexInverterTelemetry
}

# Telemetry data for a registered inverter.
type SmartFlexInverterTelemetry {
  # Information about the inverter.
  inverter: InverterTelemetry

  # Information about the battery.
  battery: BatteryTelemetry

  # Information about the solar panels.
  solar: SolarTelemetry

  # Information about the grid.
  grid: GridTelemetry

  # Information about the site.
  site: SiteTelemetry
}

type InverterTelemetry {
  # Whether the inverter is currently connected (online/offline).
  connectionStatus: ConnectionStatus

  # The current power of the inverter in kW.
  powerInKw: Decimal
}

#
#     Connection status of the device, provided as part of the telemetry data.
#
enum ConnectionStatus {
  ONLINE
  OFFLINE
}

type BatteryTelemetry {
  # Whether the battery is currently connected (online/offline).
  connectionStatus: ConnectionStatus

  # The current power of the battery in kW.
  powerInKw: Decimal

  # The current state of charge (SoC) of the battery (percentage).
  stateOfCharge: Decimal
}

type SolarTelemetry {
  # The current power of the solar panels in kW.
  powerInKw: Decimal
}

type GridTelemetry {
  # The current power of the grid in kW.
  powerInKw: Decimal
}

type SiteTelemetry {
  # The current consumption of the site in kW (i.e. sum of battery, solar and grid power).
  consumptionInKw: Decimal

  # The current export of the site in kW (where 0 means no export).
  exportInKw: Decimal
}

type SmartFlexHeatPump implements SmartFlexDeviceInterface {
  # A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  id: ID!

  # The user-friendly name for the device.
  name: String

  # The type of device.
  deviceType: KrakenFlexDeviceTypes!

  # The third-party that enables control of this device.
  provider: ProviderChoices!

  # Information about the current status of this device.
  status: SmartFlexDeviceStatusInterface

  # Active alert message(s) for a device, showing the latest first.
  alerts: [SmartFlexDeviceAlertInterface]

  # The current onboarding wizard for a device.
  onboardingWizard: SmartFlexOnboardingWizard

  # The make of the heat pump, e.g. Daikin.
  make: String

  # The model of the heat pump, e.g. EDLA04E2V3.
  model: String

  # The maximum power consumed by the heat pump in kilowatts.
  powerInKw: NormalizedDecimal
}

# A subclass of the Decimal type that normalizes the value before converting it into a string.
#
# For example, "4.000" will be converted to "4" and "4.100" will be converted to "4.1".
scalar NormalizedDecimal

type HeatPumpDeviceType {
  krakenflexDeviceId: String

  # Always HEAT_PUMPS.
  deviceType: KrakenFlexDeviceTypes
    @deprecated(
      reason: "The 'deviceType' field is deprecated.\n\nThe value is always 'HEAT_PUMPS' so this field is redundant.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-06."
    )

  # The third party that provides control of this heat pump.
  provider: ProviderChoices
  params: HeatPumpParamsType
}

type HeatPumpParamsType {
  heatPumpId: ID
}

type HeatPumpStatusType {
  # Whether the heat pump is currently connected to the provider.
  isConnected: Boolean
  climateControlStatus: ClimateControlDetailsType
  waterTemperatureStatus: WaterTemperatureDetailsType
}

type ClimateControlDetailsType {
  climateControlEnabled: Boolean

  # The target temperature of the room in Celsius
  targetClimateControlTemperature: Decimal

  # The current temperature of the room in Celsius
  currentClimateControlTemperature: Decimal
}

type WaterTemperatureDetailsType {
  waterTemperatureEnabled: Boolean

  # The current temperature of the hot water tank in Celsius
  currentWaterTemperature: Decimal
}

type HeatPumpVariantsType {
  make: String
  models: [HeatPumpVariantModelsType]
}

type HeatPumpVariantModelsType {
  heatPumpId: ID
  model: String
  powerInKw: Decimal
  isDeprecated: Boolean
}

# The possible errors that can be raised are:
#
# - KT-CT-4329: Invalid data.
# - KT-CT-4346: Unable to set the room temperature.
# - KT-CT-7223: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SetRoomTemperature {
  possibleErrors: [PossibleErrorType]

  # The customer specific heat pump device details.
  heatPumpDevice: HeatPumpDeviceType
}

input RoomTemperatureInput {
  # Account number.
  accountNumber: String!

  # The temperature the room should be set to. The valid temperature range is between 12 and 30 degrees in increments of 0.5 degrees.
  temperature: Float!
}

# The possible errors that can be raised are:
#
# - KT-CT-4336: Unable to set hot water state.
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SetHotWaterState {
  possibleErrors: [PossibleErrorType]

  # The customer specific heat pump device details.
  heatPumpDevice: HeatPumpDeviceType
}

input HotWaterStateInput {
  # Account number.
  accountNumber: String!

  # The state that the hot water device should be set to. A value of true indicates that the device should be turned on, and a value of false indicates it should be switched off.
  state: Boolean!
}

# The possible errors that can be raised are:
#
# - KT-CT-4337: Unable to set climate control state.
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SetClimateControlState {
  possibleErrors: [PossibleErrorType]

  # The customer specific heat pump device details.
  heatPumpDevice: HeatPumpDeviceType
}

input ClimateControlStateInput {
  # Account number.
  accountNumber: String!

  # The state that the climate control device should be set to. A value of true indicates that the device should be turned on, and a value of false indicates it should be switched off.
  state: Boolean!
}

# Register a heat pump.
#
# The possible errors that can be raised are:
#
# - KT-CT-4316: Unable to get provider details.
# - KT-CT-4317: Unable to register device.
# - KT-CT-4330: Invalid data.
# - KT-CT-4331: Invalid data.
# - KT-CT-4335: Another device registration is already in progress.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type RegisterHeatPump {
  possibleErrors: [PossibleErrorType]

  # The customer specific heat pump device details.
  heatPumpDevice: HeatPumpDeviceType
}

input RegisterHeatPumpInput {
  # Account number.
  accountNumber: String!

  # The ID of the property the heat pump belongs to.
  propertyId: Int

  # The make, model and power of the heat pump.
  heatPump: HeatPumpInput!

  # The provider used to authenticate the device.
  provider: ProviderChoices!

  # The authentication details required given the chosen provider.
  authentication: AuthenticationInput!
}

input HeatPumpInput {
  # The heat pump variant ID.
  heatPumpId: ID!
}

# Information about a vehicle that has been registered with Kraken Flex.
type SmartFlexVehicle implements SmartFlexDeviceInterface {
  # A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  id: ID!

  # The user-friendly name for the device.
  name: String

  # The type of device.
  deviceType: KrakenFlexDeviceTypes!

  # The third-party that enables control of this device.
  provider: ProviderChoices!

  # Information about the current status of this device.
  status: SmartFlexDeviceStatusInterface

  # Active alert message(s) for a device, showing the latest first.
  alerts: [SmartFlexDeviceAlertInterface]

  # The current onboarding wizard for a device.
  onboardingWizard: SmartFlexOnboardingWizard

  # The make of the vehicle, e.g. Tesla.
  make: String

  # The model of the vehicle, e.g. Model 3.
  model: String

  # The user's preferences for charging this vehicle.
  chargingPreferences: SmartFlexVehicleChargingPreferences
}

# The user's preferences for charging, e.g. target SoC (State of Charge).
type SmartFlexVehicleChargingPreferences {
  # The time at which the target SoC should be achieved on a weekday.
  weekdayTargetTime: Time!

  # The target SoC to achieve on a weekday (percentage).
  weekdayTargetSoc: Int!

  # The time at which the target SoC should be achieved on a weekend.
  weekendTargetTime: Time!

  # The target SoC to achieve on a weekend (percentage).
  weekendTargetSoc: Int!

  # The minimum SoC (percentage).
  minimumSoc: Int

  # The maximum SoC (percentage).
  maximumSoc: Int
}

# The `Time` scalar type represents a Time value as
# specified by
# [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
scalar Time

# Information about a charge point that has been registered with Kraken Flex.
type SmartFlexChargePoint implements SmartFlexDeviceInterface {
  # A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  id: ID!

  # The user-friendly name for the device.
  name: String

  # The type of device.
  deviceType: KrakenFlexDeviceTypes!

  # The third-party that enables control of this device.
  provider: ProviderChoices!

  # Information about the current status of this device.
  status: SmartFlexDeviceStatusInterface

  # Active alert message(s) for a device, showing the latest first.
  alerts: [SmartFlexDeviceAlertInterface]

  # The current onboarding wizard for a device.
  onboardingWizard: SmartFlexOnboardingWizard

  # The make of the charge point, e.g. myenergi.
  make: String

  # The model of the charge point, e.g. Zappi.
  model: String

  # The user's preferences for charging using this charge point.
  chargingPreferences: SmartFlexVehicleChargingPreferences
}

# The current status of a registered vehicle.
type SmartFlexVehicleStatus implements SmartFlexDeviceStatusInterface {
  # The current status of the device.
  current: SmartFlexDeviceLifecycleStatus

  # Whether control of the device is currently disabled.
  isSuspended: Boolean

  # The current state of this SmartFlex device state machine.
  currentState: SmartFlexDeviceState

  # Information about the limits for the SoC.
  stateOfChargeLimit: StateOfChargeLimit

  # The reason for the most recent failed test dispatch (if any).
  testDispatchFailureReason: TestDispatchAssessmentFailureReason
}

type StateOfChargeLimit {
  # Maximum level of charge allowed by the battery relative to its capacity (in percent).
  upperSocLimit: Int

  # Time of the latest SoC limit reading.
  timestamp: String

  # Whether or not target SoC exceeds upper SoC limit.
  isLimitViolated: Boolean
}

#
#     The reason (if any) that we believe a test dispatch (test charge) did not succeed.
#
enum TestDispatchAssessmentFailureReason {
  NONE
  UNKNOWN
  ASSESSMENTS_FAILED
  NOT_AT_HOME
  UNABLE_TO_COMMUNICATE
  DEVICE_DISCONNECTED
  SOC_LIMIT_REACHED
  ERROR
}

# The current status of a registered charge point.
type SmartFlexChargePointStatus implements SmartFlexDeviceStatusInterface {
  # The current status of the device.
  current: SmartFlexDeviceLifecycleStatus

  # Whether control of the device is currently disabled.
  isSuspended: Boolean

  # The current state of this SmartFlex device state machine.
  currentState: SmartFlexDeviceState

  # Information about the limits for the SoC.
  stateOfChargeLimit: StateOfChargeLimit

  # The reason for the most recent failed test dispatch (if any).
  testDispatchFailureReason: TestDispatchAssessmentFailureReason
}

type OCPPDetailsType {
  url: String
  username: String
}

type OCPPConnectionType {
  isConnected: Boolean
}

type VehicleChargingPreferencesType {
  weekdayTargetTime: String
  weekdayTargetSoc: Int
  weekendTargetTime: String
  weekendTargetSoc: Int

  # The minimum state of charge (soc) %, if available.
  minimumSocPercentage: Int

  # The maximum state of charge (soc) %, if available.
  maximumSocPercentage: Int
}

type KrakenFlexDeviceType {
  krakenflexDeviceId: String

  # The third party that provides control over this device.
  provider: ProviderChoices
  vehicleMake: String
  vehicleModel: String
  vehicleBatterySizeInKwh: Decimal
  chargePointMake: String
  chargePointModel: String
  chargePointPowerInKw: Decimal
  status: String
  suspended: Boolean
  hasToken: Boolean
  createdAt: DateTime

  # Maximum state of charge (SoC) limit telemetry.
  stateOfChargeLimit: StateOfChargeLimit

  # The reason for the most recent failed test dispatch (if any).
  testDispatchFailureReason: TestDispatchAssessmentFailureReason
}

type UpsideDispatchType {
  # The start time of the dispatch.
  start: DateTime!

  # The end time of the dispatch.
  end: DateTime!

  # This field has been replaced by `start`.
  startDt: String
    @deprecated(
      reason: "The 'start_dt' field is deprecated.\n\n`start` has replaced `start_dt` for improved typing.\n\n- Marked as deprecated on 2024-04-19.\n- Will be removed on 2025-01-01."
    )

  # This field has been replaced by `end`.
  endDt: String
    @deprecated(
      reason: "The 'end_dt' field is deprecated.\n\n`end` has replaced `end_dt` for improved typing.\n\n- Marked as deprecated on 2024-04-19.\n- Will be removed on 2025-01-01."
    )

  # This field has been replaced by `delta`.
  deltaKwh: Int
    @deprecated(
      reason: "The 'delta_kwh' field is deprecated.\n\n`delta` has replaced `deltaKwh` for increased precision.\n\n- Marked as deprecated on 2024-04-19.\n- Will be removed on 2025-01-01."
    )

  # Energy in kWh (import has a negative value).
  delta: Decimal
  meta: UpsideDispatchMetaType
}

type UpsideDispatchMetaType {
  # Present for planned dispatches, otherwise `null`. Value can be `smart-charge`, `test-charge` or `bump-charge`.
  source: String

  # Present for completed dispatches, otherwise `null`. The only relevant value is `AT_HOME` if present.
  location: String
}

type CostOfChargeType {
  costOfChargeId: String
  krakenflexDeviceId: String
  reportDate: Date
  isSmartCharge: Boolean

  # Consumption in kWh.
  totalConsumption: Float

  # Cost in pence (excl. tax).
  totalCostExclTax: Float

  # Cost in pence (incl. tax).
  totalCostInclTax: Float
}

#
#     The frequency of the cost of charge data to be shown in the consumer app.
#
#     We are generating this data daily, weekly, monthly or annually, with the following
#     aggregations:
#     daily -> half-hourly aggregation
#     weekly & monthly -> daily aggregations
#     annually -> monthly aggregations
#
enum DataFrequency {
  DAILY
  WEEKLY
  MONTHLY
  ANNUALLY
}

type ChargePointDevicesType {
  make: String
  models: [ChargePointModelsType]
}

type ChargePointModelsType {
  model: String
  powerInKw: [String]
}

type ChargePointVariantType {
  make: String
  models: [ChargePointVariantModelType]
}

type ChargePointVariantModelType {
  variantId: Int
  model: String
  powerInKw: Decimal

  # Supply amperage. Used in markets where customers are more familiar with amps than power output.
  amperage: Int
  isIntegrationLive: Boolean
}

type ElectricVehicleType {
  make: String
  models: [ElectricVehicleModelType]
}

type ElectricVehicleModelType {
  vehicleId: Int
  model: String
  year: Int

  # This field is replacing `year`.
  availableFrom: Int
  availableTo: Int
  batterySize: Decimal
  supportedProviders: [String]
  isIntegrationLive: Boolean
}

type EnodeLinkSessionType {
  linkState: String
  linkUrl: String
}

#
#     Available vendors supported by Enode.
#
enum EnodeVendors {
  AUDI
  BMW
  CHEVROLET
  CITROEN
  CUPRA
  DS
  FIAT
  FORD
  HYUNDAI
  JAGUAR
  KIA
  MERCEDES
  MINI
  NISSAN
  OPEL
  PEUGEOT
  PORSCHE
  RENAULT
  SEAT
  SKODA
  TOYOTA
  VAUXHALL
  VOLKSWAGEN
  VOLVO
}

type UserVehiclesType {
  vehicleId: String
  information: VehicleInformationType
}

type VehicleInformationType {
  vin: String
  brand: String

  # The model name of the vehicle, if available (e.g. i3s 120).
  model: String

  # The year of the vehicle model, if available.
  year: Int

  # The (user chosen) display name of the vehicle, if available.
  displayName: String
}

# Register a device via intelligent octopus.
#
# Currently, this means an electric vehicle and charge point details.
#
# The possible errors that can be raised are:
#
# - KT-CT-4335: Another device registration is already in progress.
# - KT-CT-4321: Serializer validation error.
# - KT-CT-4314: Unable to get provider details.
# - KT-CT-4351: Provider authentication error.
# - KT-CT-4312: Unable to register device.
# - KT-CT-4363: No capable devices found.
# - KT-CT-4364: Multiple devices found.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type RegisterDevice {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: KrakenFlexDeviceType
}

input RegisterDeviceInput {
  # Account number.
  accountNumber: String!

  # The unique vehicle ID of the electric vehicle.
  vehicle: VehicleInput!

  # The charger details.
  chargePoint: ChargePointInput!

  # The provider used to authenticate the device.
  supportedProvider: ProviderChoices!

  # The authentication details required given the chosen provider.
  authentication: AuthenticationInput

  # The ID of the property the electric vehicle belongs to.
  propertyId: Int
}

input VehicleInput {
  # The unique electric vehicle id.
  vehicleId: Int!
}

input ChargePointInput {
  # The unique charge point id.
  chargePointId: ID
}

# Delete the connection details for a device registered for a given account number.
#
# The possible errors that can be raised are:
#
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-4352: Unable to delete connection details.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type DeleteDeviceConnectionDetails {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: KrakenFlexDeviceType
}

input AccountNumberInput {
  # Account number.
  accountNumber: String!
}

# Re-authenticate a device. The authentication details provided must be for the
# same device as was previously authenticated.
#
# The possible errors that can be raised are:
#
# - KT-CT-4313: Could not find KrakenFlex device.
# - KT-CT-4314: Unable to get provider details.
# - KT-CT-4315: Unable to re-authenticate device.
# - KT-CT-4363: No capable devices found.
# - KT-CT-4364: Multiple devices found.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type ReauthenticateDevice {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: KrakenFlexDeviceType
}

input ReauthenticateDeviceInput {
  # Account number.
  accountNumber: String!

  # The authentication details required for the currently authenticated device.
  authentication: AuthenticationInput!

  # The most recently registered device of this type will be re-authenticated.
  deviceType: KrakenFlexDeviceTypes!
}

# Allow customers to set/update their vehicle's charging preferences.
#
# The possible errors that can be raised are:
#
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-4321: Serializer validation error.
# - KT-CT-4353: An error occurred while trying to update your charging preferences.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SetVehicleChargingPreferences {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: KrakenFlexDeviceType
}

input VehicleChargingPreferencesInput {
  # Account number.
  accountNumber: String!
  weekdayTargetTime: String!
  weekdayTargetSoc: Int!
  weekendTargetTime: String!
  weekendTargetSoc: Int!
  targetType: String
}

# Initiate a test charge of an electric vehicle (EV).
#
# This is to ensure that the EV or EVSE (charge point) can be controlled remotely and successfully charged for a
# short period.
#
# If it is not possible to initiate a test charge, a KT-CT-4355 error will be returned. It may have a
# `testChargeRefusalReasons` extension which lists the reasons why the test charge was refused. Possible reasons
# include:
#
# - `TC_DEVICE_LIVE` (device is already live)
# - `TC_DEVICE_ONBOARDING_IN_PROGRESS` (test dispatch already in progress)
# - `TC_DEVICE_RETIRED` (device is retired)
# - `TC_DEVICE_SUSPENDED` (device is suspended)
# - `TC_DEVICE_DISCONNECTED` (device is disconnected)
# - `TC_DEVICE_AWAY_FROM_HOME` (device is away from home)
# - `TC_DEVICE_NO_LOCATION_CONFIGURED` (device has no location configured)
# - `TC_DEVICE_LOCATION_UNABLE_TO_IDENTIFY` (unable to identify device location)
# - `TC_DEVICE_LOCATION_MISSING` (device location is missing)
#
# The possible errors that can be raised are:
#
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-4355: Unable to trigger charge.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type PerformTestCharge {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: KrakenFlexDeviceType
}

# Initiate a boost charge for an electric vehicle (EV).
#
# This will start charging the EV and will not stop until the battery reaches 100% charged.
#
# If it is not possible to initiate a boost charge, a KT-CT-4357 error will be returned.
# It may have a `boostChargeRefusalReasons` extension which lists the reasons why the boost
# charge was refused. Possible reasons include:
#
# - `BC_DEVICE_NOT_YET_LIVE` (device is not yet live)
# - `BC_DEVICE_RETIRED` (device is retired)
# - `BC_DEVICE_SUSPENDED` (device is suspended)
# - `BC_DEVICE_DISCONNECTED` (device is disconnected)
# - `BC_DEVICE_NOT_AT_HOME` (device is not at home)
# - `BC_BOOST_CHARGE_IN_PROGRESS` (boost charge already in progress)
#
# The possible errors that can be raised are:
#
# - KT-CT-4356: A boost charge cannot currently be performed.
# - KT-CT-4357: Unable to trigger boost charge.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type PerformBoostCharge {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: KrakenFlexDeviceType
}

# The possible errors that can be raised are:
#
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-4354: Unable to cancel boost charge.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type DeleteBoostCharge {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: KrakenFlexDeviceType
}

input DeleteBoostChargeInput {
  # Account number.
  accountNumber: String!
}

# Suspend control of a device while away from home, e.g. on holiday.
#
# This is to prevent charging during that period.
#
# The possible errors that can be raised are:
#
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-4358: Unable to suspend device control.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type SuspendDeviceControl {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: KrakenFlexDeviceType
}

# Resume control of a device after having been away from home.
#
# This is so that the device can be charged again according to the set preferences.
#
# The possible errors that can be raised are:
#
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-4359: Unable to resume device control.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type ResumeDeviceControl {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: KrakenFlexDeviceType
}

# Open Charge Point Protocol (OCPP) authentication.
#
# Take the given OCPP authentication details and trigger OCPP authentication.
#
# The possible errors that can be raised are:
#
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-4310: Unable to register OCPP authentication details.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type OCPPAuthentication {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: KrakenFlexDeviceType
}

input OCPPAuthenticationInput {
  # Account number.
  accountNumber: String!

  # The OCPP authentication details.
  details: String!
}

# Information about a device that has been registered for Smart Flex.
type SmartFlexDevice implements SmartFlexDeviceInterface {
  # A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  id: ID!

  # The user-friendly name for the device.
  name: String

  # The type of device.
  deviceType: KrakenFlexDeviceTypes!

  # The third-party that enables control of this device.
  provider: ProviderChoices!

  # Information about the current status of this device.
  status: SmartFlexDeviceStatusInterface

  # Active alert message(s) for a device, showing the latest first.
  alerts: [SmartFlexDeviceAlertInterface]

  # The current onboarding wizard for a device.
  onboardingWizard: SmartFlexOnboardingWizard
}

# Some general information about a device.
interface SmartFlexDeviceInterface {
  # A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  id: ID!

  # The user-friendly name for the device.
  name: String

  # The type of device.
  deviceType: KrakenFlexDeviceTypes!

  # The third-party that enables control of this device.
  provider: ProviderChoices!

  # Information about the current status of this device.
  status: SmartFlexDeviceStatusInterface

  # Active alert message(s) for a device, showing the latest first.
  alerts: [SmartFlexDeviceAlertInterface]

  # The current onboarding wizard for a device.
  onboardingWizard: SmartFlexOnboardingWizard
}

#
#     The device types that can be controlled by KrakenFlex.
#
enum KrakenFlexDeviceTypes {
  BATTERIES
  ELECTRIC_VEHICLES
  INVERTERS
  HEAT_PUMPS
  STORAGE_HEATERS
  THERMOSTATS
}

#
#     This refers to the provider that is used to authenticate when registering a device.
#
enum ProviderChoices {
  DAIKIN
  ECOBEE
  ENERGIZER
  ENPHASE
  ENODE
  FORD
  GIVENERGY
  HYPERVOLT
  HUAWEI
  INDRA
  JEDLIX
  MYENERGI
  OCPP_WALLBOX
  OHME
  SENSI
  SMARTCAR
  TESLA
  SMART_PEAR
  VP_AMAZON
  VP_HONEYWELL_CC
  VP_HONEYWELL_RES
  VP_NEST
}

interface SmartFlexDeviceStatusInterface {
  # The current status of the device.
  current: SmartFlexDeviceLifecycleStatus

  # Whether control of the device is currently disabled.
  isSuspended: Boolean

  # The current state of this SmartFlex device state machine.
  currentState: SmartFlexDeviceState
}

# The current lifecycle status of a KrakenFlex device on the smarter tariff API.
enum SmartFlexDeviceLifecycleStatus {
  ONBOARDING
  PENDING_LIVE
  LIVE
  ONBOARDING_TEST_IN_PROGRESS
  FAILED_ONBOARDING_TEST
  RETIRED
}

#
enum SmartFlexDeviceState {
  # Authentication Pending - ready to start authentication and authorization, or auth is in progress.
  AUTHENTICATION_PENDING

  # Authentication Failed - failed to connect and ready to restart authentication and authorization.
  AUTHENTICATION_FAILED

  # Authentication Complete - ready to start test (if needed) or pending live where auth or telemetry is delayed.
  AUTHENTICATION_COMPLETE

  # Test Charge in Progress - connection and smart control test has successfully started and is occurring.
  TEST_CHARGE_IN_PROGRESS

  # Test Charge Failed - connection or smart control test has failed or could not start, ready to retry test.
  TEST_CHARGE_FAILED

  # Test Charge Not Available - not currently capable of smart control test (e.g. away from home or unplugged).
  TEST_CHARGE_NOT_AVAILABLE

  # Setup Complete - test is complete (if needed) and device is live, but not ready for smart control.
  SETUP_COMPLETE

  # Smart Control Capable - live and ready for smart control (e.g. at home and plugged in) but none is scheduled.
  SMART_CONTROL_CAPABLE

  # Smart Control in Progress - smart control (e.g. smart charging) is scheduled or is currently occurring.
  SMART_CONTROL_IN_PROGRESS

  # Manual Boosting (e.g. bump charging) - user has overridden the schedule to immediately boost (e.g. bump charge now).
  BOOSTING

  # Smart Control Off (suspended) - smart control has been (temporarily) disabled (e.g. by the user with holiday mode).
  SMART_CONTROL_OFF

  # Smart Control Not Available - not currently capable of smart control (e.g. away from home or unplugged).
  SMART_CONTROL_NOT_AVAILABLE

  # Lost Connection - lost connection to the device, ready to re-auth (if not temporary / automatic fix).
  LOST_CONNECTION

  # Retired - deleted / de-authed (re-auth not possible, re-register device to onboard again).
  RETIRED
}

interface SmartFlexDeviceAlertInterface {
  # A device alert message.
  message: String

  # When a device alert message is published.
  publishedAt: DateTime
}

type SmartFlexOnboardingWizard {
  # A unique identifier for this SmartFlex onboarding wizard.
  id: ID!

  # A Backend Screen that renders the SmartFlex onboarding wizard.
  backendScreen(
    # The maximum version of Backend Screens supported by the client.
    maxVersionSupported: Int = 1
  ): BackendScreenType
}

# A backend screen is the top-level container for mobile UI.
union BackendScreenType = ComponentListType | GenericBackendScreen | Dashboard

# A list of components which comprise a screen.
#
# This is a legacy type; GenericBackendScreen should be preferred. This is because API clients
# should not need to explicitly query for screen attributes like `items` - these fields are
# embedded in the screenData field.
type ComponentListType implements AccessibilityInterface & IdentifiableInterface & BackendScreenInterface {
  # Whether the element is hidden from view.
  accessibilityHidden: Boolean

  # Accessible description of the element.
  accessibilityLabel: String

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The name of the screen.
  name: String!

  # The refresh / polling frequency in milliseconds.
  refreshFrequency: Int

  # Serialized JSON representation of the screen.
  screenData: String

  # The list of components.
  items: [ItemType]!
    @deprecated(
      reason: "The 'items' field is deprecated.\n\nAccess `items` via `screenData` instead.\n\n- Marked as deprecated on 2024-07-02.\n- Will be removed on 2024-08-01."
    )
}

# Properties relating to the accessibility of features.
interface AccessibilityInterface {
  # Whether the element is hidden from view.
  accessibilityHidden: Boolean

  # Accessible description of the element.
  accessibilityLabel: String
}

# The identity of an object.
interface IdentifiableInterface {
  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String
}

# A backend screen is the top-level container for mobile UI.
interface BackendScreenInterface {
  # The name of the screen.
  name: String!

  # The refresh / polling frequency in milliseconds.
  refreshFrequency: Int

  # Serialized JSON representation of the screen.
  screenData: String
}

# Items are sections making up a screen. They can be different types, hence Union.
union ItemType =
    TextType
  | ImageType
  | AnimationType
  | RectangularButtonType
  | PillButtonType
  | CardComponentType

# A block of text.
type TextType implements TextInterface & IdentifiableInterface {
  # The text content.
  value: String!

  # The text style, i.e. header, body.
  textStyle: TextStyleV1

  # The text alignment.
  textAlignment: Alignment

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String
}

interface TextInterface {
  # The text content.
  value: String!

  # The text style, i.e. header, body.
  textStyle: TextStyleV1

  # The text alignment.
  textAlignment: Alignment
}

# The style is the typographical hierarchy.
# These are Typescale Categories from the Mobile Design System (Figma).
enum TextStyleV1 {
  TITLE1
  TITLE2
  TITLE3
  TITLE4
  TITLE5
  TITLE6
  BODY1
  BODY2
  BUTTON_TEXT
  CALLOUT1
  CALLOUT2
  CALLOUT3
  SMALL1
  SMALL2
  SMALL3
  INPUT_TITLE
  TABULAR
}

enum Alignment {
  START
  CENTER
  END
}

# A media element containing an image.
type ImageType implements SizedItemInterface & MediaInterface & AccessibilityInterface & IdentifiableInterface {
  # The measurement of the element.
  width: ItemSizeType

  # The resource URL of the media.
  mediaUrl: String!

  # The horizontal alignment of the media.
  horizontalAlignment: Alignment

  # Whether the element is hidden from view.
  accessibilityHidden: Boolean

  # Accessible description of the element.
  accessibilityLabel: String

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String
}

# Sizes for elements.
interface SizedItemInterface {
  # The measurement of the element.
  width: ItemSizeType
}

union ItemSizeType = FractionSizeType | PointsSizeType

# A fractional measurement.
type FractionSizeType implements IdentifiableInterface {
  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The fractional value.
  fraction: Decimal!
}

# A measurement in points.
type PointsSizeType implements IdentifiableInterface {
  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The points value.
  points: Int!
}

# The media interface.
interface MediaInterface {
  # The resource URL of the media.
  mediaUrl: String!

  # The horizontal alignment of the media.
  horizontalAlignment: Alignment
}

# A media element containing an animation, such as a Lottie.
type AnimationType implements SizedItemInterface & MediaInterface & AccessibilityInterface & IdentifiableInterface {
  # The measurement of the element.
  width: ItemSizeType

  # The resource URL of the media.
  mediaUrl: String!

  # The horizontal alignment of the media.
  horizontalAlignment: Alignment

  # Whether the element is hidden from view.
  accessibilityHidden: Boolean

  # Accessible description of the element.
  accessibilityLabel: String

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String
}

type RectangularButtonType implements ButtonInterface & IdentifiableInterface {
  # The button style.
  buttonStyle: ButtonStyle

  # Title text of the button.
  title: String!

  # The action to perform when the button is pressed.
  buttonAction: ActionType!

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # Colour style of button eg. filled, outlined, text_only.
  variant: ButtonVariance
}

# The button interface.
interface ButtonInterface {
  # The button style.
  buttonStyle: ButtonStyle

  # Title text of the button.
  title: String!

  # The action to perform when the button is pressed.
  buttonAction: ActionType!
}

enum ButtonStyle {
  PRIMARY
  SECONDARY
}

# Actions are things to do upon a user interaction, such as tapping a button.
union ActionType =
    DeeplinkActionType
  | LinkActionType
  | BackendScreenEventActionType
  | CloseActionType
  | ScreenActionType

# An action which navigates to the URL of another backend screen.
type DeeplinkActionType implements ActionInterface & IdentifiableInterface {
  # The name of the action object's type.
  typeName: String

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The URL to navigate to.
  url: String!
}

# Actions are events created by buttons and other interaction.
interface ActionInterface {
  # The name of the action object's type.
  typeName: String
}

# An action which navigates to any URL.
type LinkActionType implements ActionInterface & IdentifiableInterface {
  # The name of the action object's type.
  typeName: String

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The URL to navigate to.
  url: String!
}

# An action which triggers some event in the Kraken backend.
type BackendScreenEventActionType implements ActionInterface & IdentifiableInterface {
  # The name of the action object's type.
  typeName: String

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The ID of the event to trigger.
  eventId: String!

  # List of key-value pairs to pass as parameters to the event.
  params: [BackendScreenParam]!
}

# A key-value pair (both Strings) which is passed as a parameter to a screen.
type BackendScreenParam {
  key: String!
  value: String!
}

# Closes the screen.
type CloseActionType implements ActionInterface & IdentifiableInterface & AccessibilityInterface {
  # The name of the action object's type.
  typeName: String

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # Whether the element is hidden from view.
  accessibilityHidden: Boolean

  # Accessible description of the element.
  accessibilityLabel: String
}

# An action which calls another backend screen via its screen id.
type ScreenActionType implements IdentifiableInterface & ActionInterface {
  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The name of the action object's type.
  typeName: String

  # The ID of the screen to navigate to.
  screenId: String!

  # Map of the parameters (key-value pairs) to pass to the next backend screen.
  params: [BackendScreenParam]!

  # Whether to allow returning to the original caller screen.
  allowBack: Boolean!
}

enum ButtonVariance {
  FILLED
  OUTLINED
  TEXT_ONLY
}

type PillButtonType implements ButtonInterface & IdentifiableInterface {
  # The button style.
  buttonStyle: ButtonStyle

  # Title text of the button.
  title: String!

  # The action to perform when the button is pressed.
  buttonAction: ActionType!

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String
}

# A card containing a list of items
type CardComponentType implements AccessibilityInterface & IdentifiableInterface {
  # Whether the element is hidden from view.
  accessibilityHidden: Boolean

  # Accessible description of the element.
  accessibilityLabel: String

  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The list of components.
  items: [CardItemType]!
}

# Items are sections making up a card.
union CardItemType =
    TextType
  | ImageType
  | AnimationType
  | RectangularButtonType
  | PillButtonType

# A generic backend screen that can be used to define any type of screen.
type GenericBackendScreen implements BackendScreenInterface {
  # The name of the screen.
  name: String!

  # The refresh / polling frequency in milliseconds.
  refreshFrequency: Int

  # Serialized JSON representation of the screen.
  screenData: String
}

# A list of components which comprise a dashboard screen.
type Dashboard implements IdentifiableInterface {
  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The list of sections for a dashboard.
  dashboardItems: [SectionType]!

  # The serialised dashboard items.
  serialisedDashboardItems: String!
}

# A section containing a list of cards or carousel items
type SectionType implements IdentifiableInterface {
  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The content of the section.
  content: SectionContent!

  # The order of the section.
  order: Int!
}

union SectionContent = CardComponentType | CarouselItemType

type CarouselItemType implements IdentifiableInterface {
  # Unique identifier of the object.
  id: ID

  # The name of the object's type.
  typename: String

  # The list of cards.
  cards: [CardComponentType]!
}

# Information about an alert relevant to a device registered for Smart Flex.
type SmartFlexDeviceAlert implements SmartFlexDeviceAlertInterface {
  # A device alert message.
  message: String

  # When a device alert message is published.
  publishedAt: DateTime
}

# Information about the current status of a device registered for Smart Flex.
type SmartFlexDeviceStatus implements SmartFlexDeviceStatusInterface {
  # The current status of the device.
  current: SmartFlexDeviceLifecycleStatus

  # Whether control of the device is currently disabled.
  isSuspended: Boolean

  # The current state of this SmartFlex device state machine.
  currentState: SmartFlexDeviceState
}

type ProviderAuthDetailsType {
  # OAuth 2.0 URI for the provider.
  oauthUri: String!
}

# An enumeration.
enum ClientType {
  APP
  WEB
}

type AccountIoEligibility {
  # Whether account is eligible to register devices with Intelligent Octopus or not.
  isEligibleForIo: Boolean
}

# Details of a public key that can be added to devices for end-to-end authentication or encryption.
#
# E.g. for Tesla the user visits a URL and the name can be used to show what the key is called.
# https://github.com/teslamotors/vehicle-command#distributing-your-public-key
type ProviderVirtualKeyDetailsType {
  # Friendly human-readable name for the virtual key.
  virtualKeyName: String!

  # URI for the virtual key.
  virtualKeyUri: String!
}

# De-authenticate a registered device.
#
# The possible errors that can be raised are:
#
# - KT-CT-4301: Unable to find device for given account.
# - KT-CT-4350: Unable to de-authenticate device.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type DeauthenticateDevice {
  possibleErrors: [PossibleErrorType]
  krakenflexDevice: DeviceDetailsType
}

type DeviceDetailsType {
  krakenflexDeviceId: String

  # The third party that provides control over this device.
  provider: ProviderChoices

  # The type of device.
  deviceType: KrakenFlexDeviceTypes
}

input DeAuthenticationInput {
  # Account number.
  accountNumber: String!

  # The most recently registered device of this type will be de-authenticated.
  deviceType: KrakenFlexDeviceTypes = null
}

# Register a device for smart controlling.
#
# Where device refers to batteries, electric vehicles, heat pumps or thermostats.
#
# The possible errors that can be raised are:
#
# - KT-CT-4324: Device already registered error.
# - KT-CT-4321: Serializer validation error.
# - KT-CT-4312: Unable to register device.
# - KT-CT-4363: No capable devices found.
# - KT-CT-4364: Multiple devices found.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type DeviceRegistration {
  possibleErrors: [PossibleErrorType]

  # Device ID(s) of the registered device(s).
  registeredDeviceIds: [String]
}

input DeviceRegistrationInput {
  # Account number.
  accountNumber: String!

  # The ID of the property the device belongs to.
  propertyId: Int!

  # The device type to be registered - batteries, electric vehicles, heat pumps or thermostats.
  deviceType: KrakenFlexDeviceTypes!

  # The provider used to authenticate the device.
  provider: ProviderChoices!

  # The device type specific details required for registering a device.
  deviceDetails: DeviceDetailsInput

  # The authentication details required given the chosen provider.
  authentication: AuthenticationInput
}

input DeviceDetailsInput {
  # Unique device variant id.
  deviceVariantId: ID

  # Auxiliary device variant id.
  auxDeviceVariantId: ID
}

input AuthenticationInput {
  # SSO access token for the chosen provider authentication.
  accessToken: String

  # Provider code from user login used for SSO.
  authorizationCode: String

  # SSO refresh token for the chosen provider authentication.
  refreshToken: String

  # SSO token expiry for the provider's authentication (integer in seconds).
  expiresIn: Int

  # State from user login used for SSO.
  state: String

  # ID of the device in the external provider system.
  providerDeviceId: String

  # Full redirect URI (including all query string parameters) from the result of an OAuth 2.0 flow.
  redirectUri: String
}

# Complete the registration of a device.
#
# The possible errors that can be raised are:
#
# - KT-CT-4321: Serializer validation error.
# - KT-CT-4322: Unable to complete registration error.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type ThirdPartyCompleteDeviceRegistration {
  possibleErrors: [PossibleErrorType]

  # The response showing account validity and optional tariff information.
  success: ThirdPartyCompleteDeviceRegistrationType
}

type ThirdPartyCompleteDeviceRegistrationType {
  # If the account is valid.
  isAccountValid: Boolean!

  # If a switch to the required tariff is in progress.
  isTariffSwitchInProgress: Boolean!

  # The tariff the account is on, if the switch is complete.
  tariff: ThirdPartyTariffsType
}

type ThirdPartyTariffsType {
  # Tariff rates of the charging location.
  tariffs: [ThirdPartyTariffType]!

  # Tariff intervals of the charging location.
  tariffIntervals: [ThirdPartyTariffIntervalType]!
}

type ThirdPartyTariffType {
  # Currency according to the ISO 4217 standard.
  currency: String!

  # Price per kWh in the given currency.
  price: Decimal!

  # The type of tariff this is (e.g. peak or offPeak).
  type: String!
}

type ThirdPartyTariffIntervalType {
  # Local 24hr start time of the tariff interval (format hh:mm).
  startTime: String!

  # Local 24hr end time of the tariff interval (format hh:mm).
  endTime: String!

  # Day(s) of the week of the tariff interval.
  daysOfWeek: [String]!

  # The type of tariff this is (e.g. peak or offPeak).
  tariffType: String!
}

input CompleteDeviceRegistrationInput {
  # Account number that the device is registered to.
  accountNumber: String!

  # Postcode of the property (linked to the account) that the device is registered to.
  postalCode: String!

  # External reference in the third-party system to identify the device.
  externalDeviceIdentifier: String!
}

# Create a wizard for onboarding a device with SmartFlex.
#
# The possible errors that can be raised are:
#
# - KT-CT-4321: Serializer validation error.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type StartSmartFlexOnboarding {
  possibleErrors: [PossibleErrorType]

  # The wizard created for onboarding the device with SmartFlex.
  wizard: SmartFlexOnboardingWizard
}

input StartSmartFlexOnboardingInput {
  # The account to which the device should be registered.
  accountNumber: String!

  # The property where the device is located/charged.
  propertyId: Int!
}

# Cancel onboarding of a device with SmartFlex.
#
# The possible errors that can be raised are:
#
# - KT-CT-4371: Onboarding wizard ID is invalid.
# - KT-CT-4372: Simultaneous attempts to update onboarding process.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CancelSmartFlexOnboarding {
  possibleErrors: [PossibleErrorType]

  # The wizard created for onboarding the device with SmartFlex.
  wizard: SmartFlexOnboardingWizard
}

input CancelSmartFlexOnboardingInput {
  # The ID of the SmartFlex onboarding wizard to cancel.
  wizardId: ID!
}

input SmartControlInput {
  # The ID of the device.
  deviceId: ID!

  # The smart control action, i.e. suspend or unsuspend.
  action: SmartControlAction!
}

# The smart control action choices, i.e. suspend or unsuspend.
enum SmartControlAction {
  SUSPEND
  UNSUSPEND
}

# The possible errors that can be raised are:
#
# - KT-GB-5911: We have assigned all electric blanket discount codes.
# - KT-GB-5912: Account already has a discount code assigned.
# - KT-GB-5913: An error occurred assigning a discount code.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type AssignDiscountCode {
  possibleErrors: [PossibleErrorType]

  # The assigned discount code.
  discountCode: String
}

# The possible errors that can be raised are:
#
# - KT-GB-6013: Account is not eligible to order a blanket.
# - KT-GB-6014: An error occurred placing the order.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type OrderBlanket {
  possibleErrors: [PossibleErrorType]

  # Whether the blanket order was placed successfully.
  success: Boolean
}

# Consumption cost for different smart tariffs.
type SmartTariffComparisonType {
  # Total cost for a period.
  currentCost: Float!

  # Total cost with tax for a period.
  currentCostWithTax: Float!

  # Costs comparisons for available smart tariffs. Note: if product type is not supported or product doesn't have unit rates - it will not be included in response.
  costComparisons: [TariffComparisonType]

  # The datetime the consumption readings start.
  consumptionReadingsStartAt: DateTime!

  # The datetime the consumption readings end.
  consumptionReadingsEndAt: DateTime!
}

type TariffComparisonType {
  # Tariff name.
  tariff: String

  # Cost of a tariff.
  cost: Float

  # Cost of a tariff with tax.
  costWithTax: Float
}

type SavingSessionsType {
  # Info related to a specific account.
  account(
    # Kraken account number.
    accountNumber: String!
  ): SavingSessionsAccountType

  # Saving Sessions events, ordered by start datetime.
  events(
    # Optional argument to include dev events.
    getDevEvents: Boolean
  ): [SavingSessionsEventType]

  # The total number of events.
  eventCount(
    # Optional argument to include dev events.
    getDevEvents: Boolean
  ): Int

  # Combined statistics from all of the Savings Sessions so far.
  nationalAggregatedStats: SavingSessionsNationalAggregatedStatsType

  # Prize draw information.
  prizeDrawInformation: SavingSessionsPrizeDrawInformationType
}

type SavingSessionsAccountType {
  # Whether the account is eligible to join the campaign.
  canJoinCampaign: Boolean

  # Whether the account joined the campaign.
  hasJoinedCampaign: Boolean

  # Meterpoints eligible for signup to Saving Sessions.
  eligibleMeterPoints: [EligibleMetersPointsType]

  # The meter point signed up to Saving Sessions.
  signedUpMeterPoint: EligibleMetersPointsType

  # Whether the account is a business account.
  isBusinessAccount: Boolean

  # Whether the account is a tester account for the campaign.
  isTesterAccount: Boolean

  # The events that the account has joined.
  joinedEvents: [SavingSessionsAccountJoinedEventsType]

  # The event streak history of the account.
  eventStreak: [SavingSessionsAccountEventStreakType]
}

type EligibleMetersPointsType {
  # The formatted supply address including postcode.
  address: String

  # The valid Saving Sessions MPAN.
  mpan: String
}

type SavingSessionsAccountJoinedEventsType {
  # The event ID of the joined event.
  eventId: Int

  # The start datetime of the joined event.
  startAt: DateTime

  # The end datetime of the joined event.
  endAt: DateTime

  # The amount of OctoPoints the account has been awarded for their participation in the event.
  rewardGivenInOctoPoints: Int

  # The energy saved in kWh for the event.
  energySavedInKwh: Float

  # The outcome of the account's participation of the event.
  status: SavingSessionsAccountEventResultStatusChoices

  # The status of the event.
  eventStatus: SavingSessionsAccountEventStatus

  # Updated results status.
  resultsStatus: SavingSessionsAccountEventResultStatusChoices

  # The saved amount of CO2 in grams for the event.
  co2SavedInGrams: Float

  # The total consumption reduction in percentage for the event.
  percentageSaved: Float

  # Percent rank amongst all customers that reduced consumption.
  netReductionPctRank: Float

  # The average payment amongst all customers per event.
  avgCustomerRemunerationPounds: Float

  # How much we thought the customer was going to use over the event period.
  baselineConsumptionDeltaKwh: Float

  # How much the customer actually used over the event period.
  consumptionDeltaKwh: Float

  # The datetime of when the results were set.
  resultsSetAt: DateTime
}

# An enumeration.
enum SavingSessionsAccountEventResultStatusChoices {
  NONE
  CALCULATING
  UPCOMING
  SUCCESS
  PARTIAL_SUCCESS
  FAIL
  MISSING_READINGS
}

# An enumeration.
enum SavingSessionsAccountEventStatus {
  UPCOMING
  ONGOING
  DONE
}

type SavingSessionsAccountEventStreakType {
  # The start datetime of the joined event.
  eventStartDate: DateTime

  # Did the account opt-in to the event.
  isOptedIntoEvent: Boolean

  # Dispatch notice time of event (day before, within 1 day, etc).
  dispatchNotice: DispatchNoticeTypeChoices

  # The streak point the account had during the event.
  streakPoints: Int
}

#
#     The various dispatch notice time types ecisting in the datalake for saving session events.
#
enum DispatchNoticeTypeChoices {
  DAY_AHEAD
  WITHIN_DAY_1
  WITHIN_DAY_2
}

type SavingSessionsEventType {
  # The event ID.
  id: Int

  # The event code.
  code: String

  # The start of the event.
  startAt: DateTime

  # The end of the event.
  endAt: DateTime

  # Status of the event.
  status: SavingSessionsAccountEventStatus

  # The total number of participants who joined the event.
  totalParticipants: Int

  # The number of OctoPoints an account will earn per kWh of energy reduced, if successful.
  rewardPerKwhInOctoPoints: Int

  # Whether this this a test event.
  devEvent: Boolean
}

type SavingSessionsNationalAggregatedStatsType {
  # The amount of energy saved across all Saving Sessions, in kWh.
  energySavedInKwh: Int

  # The equivalent total energy saved in a phrase.
  energySavedEquivalentInWords: String

  # The equivalent total CO2 saved in a phrase.
  co2SavedEquivalentInWords: String

  # Optional additional context for the CO2e statement.
  co2SavedEquivalentTooltip: String

  # The last datetime the stats were updated.
  lastUpdatedAt: DateTime
}

type SavingSessionsPrizeDrawInformationType {
  # Whether there is prize draw information to show for the next Saving Session.
  showPrizeDraw: Boolean

  # A description of the spot prize for the next Saving Session.
  nextSessionPrizeDescription: String

  # A description of the the latest spot prize winner.
  latestAwardedPrizeDescription: String

  # The last datetime the prize draw information was updated.
  lastUpdatedAt: DateTime
}

# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-GB-5110: Campaign not found.
# - KT-GB-5111: Meter point not found.
# - KT-GB-5112: Error joining campaign.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type JoinSavingSessionsCampaign {
  possibleErrors: [PossibleErrorType]
  account: SavingSessionsAccountReturnType
}

# The input type for signing an account up to Saving Sessions.
input JoinSavingSessionsCampaignInput {
  # The account number.
  accountNumber: String!

  # The MPAN to be signed up.
  mpan: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-GB-5114: Saving Sessions event not found.
# - KT-GB-5116: Account is not part of a Saving Sessions campaign.
# - KT-GB-5117: Account ineligible to join Saving Sessions event.
# - KT-GB-5115: Error joining event.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type JoinSavingSessionsEvent {
  possibleErrors: [PossibleErrorType]

  # The event codes that the account has joined.
  joinedEventCodes: [String]
}

# The input type for opting an account in to a Saving Sessions event.
input JoinSavingSessionsEventInput {
  # The account number.
  accountNumber: String!

  # The code of the event the user is trying to sign up to.
  eventCode: String!
}

# Referral claim code is a way of claiming promotional benefit coming from the partner-reward referral schemes.
type ReferralClaimCodeType {
  # Id of claim code instance.
  id: Int

  # Value of claim code.
  value: String

  # Referral scheme claim code belongs to.
  referralScheme: ReferralSchemeType

  # Account referral associated with the claim code.
  accountReferral: ReferralType

  # Datetime when claim code was generated.
  createdAt: DateTime
}

# Record the terms have been accepted and progress the workflow.
type AcceptTermsAndConditions {
  # Version of terms and conditions that were accepted.
  acceptedVersion: String
}

input AcceptTermsAndConditionsInput {
  # The account number.
  accountNumber: String!

  # The ID of the Enrolment.
  enrolmentId: ID!

  # The version of accepted terms and conditions.
  termsVersion: TermsVersionInput!
}

input TermsVersionInput {
  # The major version of terms and conditions that were accepted.
  versionMajor: Int!

  # The minor version of terms and conditions that were accepted.
  versionMinor: Int!
}

type ConstantineSpawnData {
  # A List of Constantines.
  constantines: [ConstantineSpawn]

  # The datetime of when the list of Constantines will expire.
  cacheExpiry: DateTime
}

type ConstantineSpawn {
  # The name describing which kind of Constantine this Constantine is.
  displayName: String

  # The slug for this kind of Constantine.
  slug: String

  # How rare this kind of Constantine is expressed as en enum associated to a percentage value.
  rarity: Rarity

  # The description for each kind of Constantine
  description: String

  # How many prize entries catching this Constantine is worth.
  prizeEntries: Int

  # Unique Identifier for the Constantine.
  spawnId: String

  # If the user has caught this Constantine in the cache period.
  isCaught: Boolean
}

# An enumeration.
enum Rarity {
  Popular
  Uncommon
  Rare
  Epic
  Legendary
}

type GetSnapsResponseType {
  # All available sets of constantine.
  sets: [SnapSetType]

  # Total amount of prize entries.
  totalPrizeEntries: Int
}

type SnapSetType {
  # The name of the set of Constantines.
  displayName: String

  # The slug for this kind of Constantine set.
  slug: String

  # Is this Constantine set completed (all constantines in set caught).
  isComplete: Boolean

  # List of caught Constantines for this set.
  constantinesCaught: [CaughtConstantine]

  # List of Constantines not yet caught for this set.
  constantinesRemaining: [ConstantineType]

  # The amount of prizes entries completing the set is worth.
  prizeEntries: Int
}

type CaughtConstantine {
  # The name describing which kind of Constantine this Constantine is.
  displayName: String

  # The slug for this kind of Constantine.
  slug: String

  # How rare this kind of Constantine is expressed as en enum associated to a percentage value.
  rarity: Rarity

  # The description for each kind of Constantine
  description: String

  # How many prize entries catching this Constantine is worth.
  prizeEntries: Int

  # The amount of times this Constantine has been caught.
  totalCaught: Int

  # The first time this Constantine was caught.
  firstCaught: DateTime
}

type ConstantineType {
  # The name describing which kind of Constantine this Constantine is.
  displayName: String

  # The slug for this kind of Constantine.
  slug: String

  # How rare this kind of Constantine is expressed as en enum associated to a percentage value.
  rarity: Rarity

  # The description for each kind of Constantine
  description: String

  # How many prize entries catching this Constantine is worth.
  prizeEntries: Int
}

type OctoplusAccountInfoType {
  # Describes whether or not this account is enrolled in the Octoplus campaign.
  isOctoplusEnrolled: Boolean

  # Describes whether or not the request user is the nominated user for this account.
  isLoyaltyPointsUser: Boolean

  # Information about an account's eligibility for joining the Octoplus campaign.
  octoplusEligibility: OctoplusEligibilityType

  # URL for the octoplus snap page if account is eligible.
  octoplusSnapWebUrl: OctoplusSnapWebUrlType
}

type OctoplusEligibilityType {
  # Describes whether or not this account is eligible to join the Octoplus campaign.
  isEligible: Boolean

  # Describes why an account is ineligible for Octoplus. Will be null if the account is eligible.
  ineligibilityReason: IneligibilityReasons
    @deprecated(
      reason: "The 'ineligibilityReason' field is deprecated.\n\nPlease use ineligibility_reasons instead.\n\n- Marked as deprecated on 2023-10-10.\n- Will be removed on 2024-01-01."
    )

  # Returns multiple reasons for why an account is ineligible for Octoplus. Will be empty if the account is eligible.
  ineligibilityReasons: [IneligibilityReasons]
}

# An enumeration.
enum IneligibilityReasons {
  OCTOPLUS_DISABLED
  ALREADY_SIGNED_UP
  INCORRECT_BRAND
  NO_PROPERTIES
  NO_ELIGIBLE_METERS
  NO_DIRECT_DEBIT
  ACTIVE_EXCLUSION_CAMPAIGN
}

type OctoplusSnapWebUrlType {
  # URL for the octoplus snap page if account is eligible. Eg. 'https://octopus.energy/snap/webview?abcd=efg'.
  url: String!

  # Domain for the snap web url, ex. 'octopus.energy'
  domain: String!

  # Path for the snap web url, ex. 'snap/webview'
  path: String!
}

type OctoplusFeatureFlagsType {
  # Describes whether or not the new Octopoints system should be shown in clients.
  shouldClientDisplayOctopointsV2: Boolean

  # Describes whether or not the Octoplus campaign should be shown in clients.
  shouldClientDisplayOctoplus: Boolean

  # Describes whether or not rewards should be shown in clients.
  shouldClientDisplayRewards: Boolean

  # Describes whether or not Octoplus rewards should be shown in clients.
  shouldClientDisplayOctoplusRewards: Boolean

  # Describes whether or not partner rewards should be shown in clients.
  shouldClientDisplayPartnerRewards: Boolean

  # Describes whether or not Octoplus partner offers should be shown in clients.
  shouldClientDisplayOctoplusPartnerOffers: Boolean

  # Describes whether or not Octoplus Shoptopus offers should be shown in clients.
  shouldClientDisplayOctoplusShoptopusOffers: Boolean

  # Describes whether or not Octoplus related offers should be shown in clients.
  shouldClientDisplayOctoplusRelatedOffers: Boolean

  # Describes whether or not Octoplus partner offer list should be shown in clients.
  shouldClientDisplayOctoplusPartnerOfferList: Boolean
}

type OctoplusRewardType {
  # The unique id of the reward.
  id: Int

  # The account number associated with this reward.
  accountNumber: String

  # The offer claimed as part of this reward.
  offer: OctoplusOfferType

  # The human-readable identifier for the offer.
  offerSlug: String
    @deprecated(
      reason: "The 'offer_slug' field is deprecated.\n\nPlease use 'offer.slug' instead\n\n- Marked as deprecated on 2023-12-21.\n- Will be removed on 2024-02-10."
    )

  # The display name of the offer.
  offerName: String
    @deprecated(
      reason: "The 'offer_name' field is deprecated.\n\nPlease use 'offer.name' instead\n\n- Marked as deprecated on 2023-12-21.\n- Will be removed on 2024-02-10."
    )

  # The price tag for the offer.
  priceTag: String
    @deprecated(
      reason: "The 'price_tag' field is deprecated.\n\nPlease use 'offer.price_tag' instead\n\n- Marked as deprecated on 2023-12-21.\n- Will be removed on 2024-02-10."
    )

  # The name of the reward partner.
  partnerName: String
    @deprecated(
      reason: "The 'partner_name' field is deprecated.\n\nPlease use 'offer.partner_name' instead\n\n- Marked as deprecated on 2023-12-21.\n- Will be removed on 2024-02-10."
    )

  # The instructions for how to use the reward.
  usageInstructions: String
    @deprecated(
      reason: "The 'usage_instructions' field is deprecated.\n\nPlease use 'offer.usage_instructions' instead\n\n- Marked as deprecated on 2023-12-21.\n- Will be removed on 2024-02-10."
    )

  # The voucher associated with this reward.
  vouchers: [VoucherType]

  # The datetime at which the reward was initially claimed.
  claimedAt: DateTime

  # The current status of the reward.
  status: OctoplusRewardStatus
}

type OctoplusOfferType {
  # The slug to be used as the offer identifier.
  slug: String

  # The name of the offer to be displayed to the user.
  name: String

  # The short description of the offer.
  description: String

  # The long description of the offer.
  longDescription: String

  # The name of the reward partner.
  partnerName: String

  # The price tag for this offer.
  priceTag: String

  # The points cost of claiming this offer.
  pointsCost: Int

  # The available sites url for this offer.
  availableSitesUrl: String

  # The partner site url for this offer.
  partnerSiteUrl: String

  # The image urls for this offer.
  imageUrls: OctoplusOfferImageUrlsType

  # The terms and conditions to display to the user.
  termsAndConditions: String

  # The faqs for this offer.
  faqs: [OctoplusOfferFAQsType]

  # The instructions for the user as to how to use their claimed reward.
  usageInstructions: String

  # The category of the offer.
  category: String

  # Describes whether the user should be able to claim this offer, and the reason if not.
  claimAbility: OctoplusRewardClaimAbilityType

  # The datetime at which the user should no longer be able to claim this offer.
  claimBy: DateTime
}

type OctoplusOfferImageUrlsType {
  # The banner image url.
  banner: String

  # The mobile banner url.
  bannerMobile: String

  # The logo url.
  logo: String

  # The mobile logo url.
  logoMobile: String
    @deprecated(
      reason: "The 'logo_mobile' field is deprecated.\n\nPlease use logo instead\n\n- Marked as deprecated on 2023-12-20.\n- Will be removed on 2024-01-10."
    )
}

type OctoplusOfferFAQsType {
  # The FAQ question field.
  question: String

  # The FAQ answer field.
  answer: String
}

type OctoplusRewardClaimAbilityType {
  # Describes whether the user should be able to claim this offer.
  canClaimOffer: Boolean

  # Describes why a user cannot claim this offer.
  cannotClaimReason: CannotClaimReason
}

enum CannotClaimReason {
  OUT_OF_STOCK
  MAX_CLAIMS_PER_PERIOD_REACHED
  INSUFFICIENT_POINTS
}

union VoucherType = OctoplusVoucherType | ShoptopusVoucherType

type OctoplusVoucherType {
  # The voucher code.
  code: String

  # The type of voucher.
  type: String

  # The barcode value/code.
  barcode: String

  # The value to be encoded in the rendered barcode.
  barcodeValue: String

  # The type of barcode to render.
  barcodeFormat: String

  # The datetime at which the voucher will no longer be useable.
  expiresAt: DateTime
}

type ShoptopusVoucherType {
  # The voucher code.
  code: String
}

enum OctoplusRewardStatus {
  PENDING
  ISSUED
  CANCELLED
}

type OctoplusOfferGroupConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [OctoplusOfferGroupConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `OctoplusOfferGroupConnectionType` and its cursor.
type OctoplusOfferGroupConnectionTypeEdge {
  # The item at the end of the edge
  node: OctoplusOfferGroupType

  # A cursor for use in pagination
  cursor: String!
}

type OctoplusOfferGroupType {
  # Unique identifier of the Offer Group.
  id: Int!

  # The name describing offer group.
  name: String

  # The image urls for this offer.
  imageUrls: OctoplusOfferGroupImageUrlsType
  octoplusOffers: [OctoplusOfferType!]!
}

type OctoplusOfferGroupImageUrlsType {
  # The mobile banner url.
  bannerMobile: String
}

type ShoptopusVoucherAvailabilityType {
  # The voucher value.
  value: Int

  # Denotes whether or not this voucher value is currently available.
  availability: Boolean
}

# The possible errors that can be raised are:
#
# - KT-GB-9316: Account is not Octoplus-enrolled.
# - KT-GB-9325: Invalid constantine slug.
# - KT-GB-9326: Invalid spawn ID.
# - KT-GB-9319: This feature is not currently available.
# - KT-GB-9327: Snap failed to create.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type CreateSnap {
  possibleErrors: [PossibleErrorType]

  # Returns true if snap was successfully created.
  success: Boolean
}

# Sign an account up to Octoplus.
#
# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-GB-9310: Account ineligible for joining Octoplus.
# - KT-GB-9311: Error joining campaign.
# - KT-GB-9312: Account already signed up to Octoplus.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type JoinOctoplusCampaign {
  possibleErrors: [PossibleErrorType]

  # Returns mutation success. Deprecated, in favour of the outcome field.
  success: Boolean

  # Outcome of the Octoplus and Saving Sessions enrolment.
  outcome: EnrolmentOutcome
}

type EnrolmentOutcome {
  # The outcome of the Octoplus enrolment.
  octoplus: OctoplusEnrolmentOutcome

  # The outcome of the saving sessions enrolment, null if the account did not opt in to enrol.
  savingSessions: SavingSessionsEnrolmentOutcome
}

type OctoplusEnrolmentOutcome {
  # Whether or not this account has been enrolled in the Octoplus campaign.
  hasEnrolled: Boolean
}

type SavingSessionsEnrolmentOutcome {
  # Whether or not this account has been enrolled in the Saving Sessions campaign.
  hasEnrolled: Boolean

  # The MPAN of the meter point that has been enrolled.
  enrolledMpan: String

  # The reason for not enrolling.
  notEnrolledReason: String
}

input SavingSessionsEnrolmentOptions {
  # Whether or not the account should enrol in Saving Sessions.
  shouldEnrol: Boolean

  # The MPAN of the meter point to enrol with Saving Sessions. If not provided, a random eligible meter point for the account will be selected
  nominatedMpan: String
}

# The possible errors that can be raised are:
#
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
# - KT-GB-9313: Not enough Octopoints.
# - KT-GB-9314: Reward could not be processed.
# - KT-GB-9315: Reward of this type unavailable.
# - KT-GB-9316: Account is not Octoplus-enrolled.
# - KT-GB-9319: This feature is not currently available.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type ClaimShoptopusVoucher {
  possibleErrors: [PossibleErrorType]

  # The Reward Voucher code.
  code: String
}

# The possible errors that can be raised are:
#
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
# - KT-GB-9313: Not enough Octopoints.
# - KT-GB-9314: Reward could not be processed.
# - KT-GB-9315: Reward of this type unavailable.
# - KT-GB-9316: Account is not Octoplus-enrolled.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type ClaimOctoplusReward {
  possibleErrors: [PossibleErrorType]

  # The ID of the claimed reward.
  rewardId: String
}

# The possible errors that can be raised are:
#
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
# - KT-GB-9319: This feature is not currently available.
# - KT-GB-9323: Could not create contact link.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateOctoplusRewardContactLink {
  possibleErrors: [PossibleErrorType]

  # The URL of the customer contact form link.
  url: String
}

type OctocareUsageInfo {
  # The Device ID of the smart meter associated with the property of the Cared-For account, which must also have an Octopus Mini device installed.
  meterDeviceId: String!

  # The first line of the address of the property associated with the Cared-For account.
  propertyAddressLine1: String!
}

type OctocareOnboardingInfo {
  # The Device ID of the communication hub associated with the property of the Cared-For account, which must also have an Octopus Mini device installed.
  chfDeviceId: String!

  # The first line of the address of the property associated with the Cared-For account.
  propertyAddressLine1: String!

  # The ID of the property the Mini will be onboarded in.
  propertyId: ID!
}

type OctoPointsType {
  # Info related to a specific account's wallet.
  account(
    # Kraken account number.
    accountNumber: String!
  ): OctoPointsAccountType
}

type OctoPointsAccountType {
  # The current number of OctoPoints in an account's OctoPoints wallet.
  currentPointsInWallet: Int

  # The events for an account's OctoPoints wallet.
  events: [OctoPointsAccountEventType]
}

type OctoPointsAccountEventType {
  # The datetime the event happened.
  createdAt: DateTime

  # The reason the event happened.
  reason: EventReasonChoices

  # The amount of OctoPoints added to an account's wallet (this can be negative).
  pointsAddedToWallet: Int
}

# An enumeration.
enum EventReasonChoices {
  SAVING_SESSIONS_REWARD
  AD_HOC_CREDIT
  OCTO_POINTS_CONVERSION
  OCTO_ASSIST_FUND_DONATION
}

# Redeem OctoPoints as account credit.
#
# The possible errors that can be raised are:
#
# - KT-CT-4177: Unauthorized.
# - KT-GB-5011: Not enough OctoPoints for redemption.
# - KT-GB-5010: Error redeeming OctoPoints.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type RedeemOctoPointsForAccountCredit {
  possibleErrors: [PossibleErrorType]

  # The number of OctoPoints that were redeemed.
  pointsRedeemed: Int

  # The number of OctoPoints remaining in the wallet.
  remainingPointsInWallet: Int
}

# The input type for redeeming OctoPoints.
input RedeemOctoPointsInput {
  # The account number.
  accountNumber: String!
}

type FieldSalesVisitConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [FieldSalesVisitConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `FieldSalesVisitConnectionType` and its cursor.
type FieldSalesVisitConnectionTypeEdge {
  # The item at the end of the edge
  node: FieldSalesVisitType

  # A cursor for use in pagination
  cursor: String!
}

# A field sales visit at an address.
type FieldSalesVisitType {
  startedAt: DateTime!
  stoppedAt: DateTime!
  addressLine1: String!
  addressLine2: String!
  addressLine3: String!

  # Post town
  addressLine4: String!

  # County
  addressLine5: String!
  outcome: AppSessionOutcome

  # Affiliate Link.
  affiliateLink: AffiliateLinkType

  # Field Sales Outcomes.
  outcomes: [FieldSalesVisitOutcomeType]
}

# An enumeration.
enum AppSessionOutcome {
  # Switched
  SWITCHED

  # Switched Business
  SWITCHED_BUSINESS

  # Switched (Credit Check Waiver)
  SWITCHED_CREDIT_CHECK_WAIVER

  # Switched (First Contact)
  SWITCHED_FIRST_CONTACT

  # Switched (Callback)
  SWITCHED_CALLBACK

  # Switched (Smart Product)
  SWITCHED_SMART_PRODUCT

  # Quoted - no switch
  QUOTED_NO_SWITCH

  # Quoted - no sale
  QUOTED_NO_SALE

  # Quoted - no sale - quote emailed
  QUOTED_NO_SALE_QUOTE_EMAILED

  # Quoted - no sale price
  QUOTED_NO_SALE_PRICE

  # Quoted - no sale exit fees
  QUOTED_NO_SALE_EXIT_FEES

  # Quoted - no sale no email
  QUOTED_NO_SALE_NO_EMAIL

  # Quoted - no sale issue bank details
  QUOTED_NO_SALE_ISSUE_BANK_DETAILS

  # Quoted - no sale advanced payment
  QUOTED_NO_SALE_ADVANCED_PAYMENT

  # Quoted - no sale standing charge
  QUOTED_NO_SALE_STANDING_CHARGE

  # Quoted - no sale paper bills
  QUOTED_NO_SALE_PAPER_BILLS

  # Quoted - no sale monthly dd
  QUOTED_NO_SALE_MONTHLY_DD

  # Quoted - no sale credit check issue
  QUOTED_NO_SALE_CREDIT_CHECK_ISSUE

  # Quoted - no sale waiver wanted
  QUOTED_NO_SALE_WAIVER_WANTED

  # Quoted - no sale objected to deposit
  QUOTED_NO_SALE_DEPOSIT

  # Quoted - no sale objected to autopay
  QUOTED_NO_SALE_AUTOPAY

  # Quoted - no sale prepay too high
  QUOTED_NO_SALE_PREPAY

  # Quoted - no sale unsure of current contract
  QUOTED_NO_SALE_UNSURE_OF_CURRENT_CONTRACT

  # Quoted - no sale other
  QUOTED_NO_SALE_OTHER

  # Pitch - no quote
  PITCH_NO_QUOTE

  # No pitch
  NO_PITCH

  # No pitch - switched recently
  NO_PITCH_SWITCHED_RECENTLY

  # No pitch - vulnerable
  NO_PITCH_VULNERABLE

  # No pitch - no d2d
  NO_PITCH_NO_D2D

  # No pitch - not interested
  NO_PITCH_NOT_INTERESTED

  # No pitch - TPI/third party
  NO_PITCH_TPI_THIRD_PARTY

  # Pitch no quote - switched recently
  PITCH_NO_QUOTE_SWITCHED_RECENTLY

  # Pitch no quote - price
  PITCH_NO_QUOTE_PRICE

  # Pitch no quote - in contract
  PITCH_NO_QUOTE_IN_CONTRACT

  # Pitch no quote - no email
  PITCH_NO_QUOTE_NO_EMAIL

  # Pitch no quote - not interested
  PITCH_NO_QUOTE_NOT_INTERESTED

  # Pitch no quote - advanced payment
  PITCH_NO_QUOTE_ADVANCED_PAYMENT

  # Callback
  CALLBACK

  # Quoted - callback
  QUOTED_CALLBACK

  # Callback - pitched
  CALLBACK_PITCHED

  # No answer
  NO_ANSWER

  # Not bill payer
  NOT_BILL_PAYER

  # Not decision maker
  NOT_DECISION_MAKER

  # Busy
  BUSY

  # Multiple properties owned
  MULTIPLE_PROPERTIES

  # Callback - courtesy call
  CALLBACK_COURTESY_CALL

  # Don’t call again
  DONT_CALL_AGAIN

  # No cold calling
  NO_COLD_CALLING

  # Sheltered housing
  SHELTERED_HOUSING

  # No fixed address
  NO_FIXED_ADDRESS

  # Occupy account
  OCCUPY_ACCOUNT

  # Occupier - not bill payer
  OCCUPIER_NOT_BILL_PAYER

  # Occupier - no answer
  OCCUPIER_NO_ANSWER

  # Occupier - refused to discuss
  OCCUPIER_REFUSED_TO_DISCUSS

  # Occupier - suspected empty property
  OCCUPIER_SUSPECTED_EMPTY_PROPERTY

  # Meter reading
  METER_READING

  # Meter reading - unable to take reading
  METER_READING_UNABLE_TO_TAKE_READING

  # Meter reading - no answer
  METER_READING_NO_ANSWER

  # Energy help visit - completed
  ENERGY_HELP_VISIT_COMPLETED

  # Energy help visit - leaflet left
  ENERGY_HELP_VISIT_LEAFLET

  # PSR registered
  PSR_REGISTERED

  # Smart meter registered
  SMART_METER_REGISTERED

  # Consumer app download
  CONSUMER_APP_DOWNLOAD

  # EBSS voucher check in
  EBSS_VOUCHER_CHECK_IN

  # PPM requested
  PPM_REQUESTED

  # COT proven
  COT_PROVEN

  # COT no proof
  COT_NO_PROOF

  # COS
  COS

  # Paid in full
  PAID_IN_FULL

  # Payment plan
  PAYMENT_PLAN

  # Paid partial
  PAID_PARTIAL

  # Paid reduced settlement
  PAID_REDUCED_SETTLEMENT

  # Insolvency
  INSOLVENCY

  # Exhausted - no contact
  EXHAUSTED_NO_CONTACT

  # Exhausted - contact
  EXHAUSTED_CONTACT

  # Unable to locate
  UNABLE_TO_LOCATE

  # Empty
  EMPTY

  # Demolished
  DEMOLISHED

  # Unable to trace
  UNABLE_TO_TRACE

  # Prison
  PRISON

  # Vulnerable
  VULNERABLE

  # Deceased
  DECEASED

  # Withdrawn
  WITHDRAWN

  # Query
  QUERY

  # Wrong address selected
  WRONG_ADDRESS_SELECTED

  # Prepayment meter
  PREPAYMENT_METER

  # Already an existing customer
  EXISTING_CUSTOMER

  # Lead generation
  LEAD_GENERATION

  # Electric vehicle lead generation
  LEAD_GENERATION_EV

  # Electric juice switch & lead generation
  LEAD_GENERATION_EJ

  # Electric juice lite switch & lead generation
  LEAD_GENERATION_EJ_LITE

  # Business lead generation
  LEAD_GENERATION_BUSINESS

  # Solar lead generation
  LEAD_GENERATION_SOLAR

  # Heat pump lead generation
  LEAD_GENERATION_HEAT_PUMP

  # Property ineligible
  PROPERTY_INELIGIBLE

  # Electric juice switch
  ELECTRIC_JUICE_SWITCH

  # Electric juice lite switch
  ELECTRIC_JUICE_SWITCH_LITE

  # Electric juice not interested
  ELECTRIC_JUICE_NOT_INTERESTED

  # Vulnerability project
  VULNERABILITY_PROJECT

  # The customer was transferred to another team/agent
  TRANSFERRED
}

# Affiliate link for the organization.
type AffiliateLinkType {
  id: ID!
  organisation: AffiliateOrganisationType
  subdomain: String!
  trainingStatus: LinkTrainingStatus!
  isBusiness: Boolean!
  contactName: String!
  contactEmail: String!
  landingUrl: String!
}

type AffiliateOrganisationType {
  id: ID!
  name: String!

  # Sales Channel
  salesChannel: SalesChannelChoices

  # Allow performing tariff renewals via API.
  canRenewTariffs: Boolean

  # Default Account Type
  defaultAccountType: AccountTypeChoices

  # Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  allowAlternativePaymentMethods: Boolean

  # Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  canRegisterBusinessMeterPoints: Boolean

  # Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  canRegisterPortfolioAccounts: Boolean

  # Allow registration requests with customers without an email address.
  canRegisterCustomersWithoutEmailAddress: Boolean

  # Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  canUseIvrSupportApi: Boolean

  # Allow this partner to skip validation that ensures all meter points belong to the same address
  skipMeterPointAddressValidation: Boolean

  # Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  isFieldSalesOnlyProduct: Boolean
}

# An enumeration.
enum SalesChannelChoices {
  DIRECT
  PRICE_COMPARISON
  TELESALES
  DIGI_TELESALES
  EVENTS
  FIELD_SALES
  AGGREGATOR
  PARTNERSHIPS
  NEW_TENANT
  MOVE_IN
  WORKPLACE_POP_UP
  BROKER
  PARENT_POWER
  PEOPLE_POWER
  GIFT_OF_KIT
  HIGH_REFERRER
  SUPPLIER_OF_LAST_RESORT
  ACQUISITION
  WORKS_WITH_OCTOPUS
  LANDLORD
  DEBT_COLLECTION_AGENCY
  OCTOPUS_TRUSTED_PARTNERS
}

# An enumeration.
enum LinkTrainingStatus {
  # Not applicable
  NOT_APPLICABLE

  # In training
  IN_TRAINING

  # Qualified
  QUALIFIED
}

# The specific outcome of a field sales visit at an address.
type FieldSalesVisitOutcomeType {
  type: AppSessionOutcomeType!
  category: AppSessionOutcomeCategory
  reason: String
}

# An enumeration.
enum AppSessionOutcomeType {
  # Sale
  SALE

  # Business Sale
  BUSINESS_SALE

  # Occupier
  OCCUPIER

  # Meter Reading
  METER_READING

  # Electroverse Lead
  ELECTROVERSE_LEAD

  # Electroverse
  ELECTROVERSE

  # Ev Lead
  EV_LEAD

  # Energy Help
  ENERGY_HELP

  # Solar Lead
  SOLAR_LEAD

  # Ev Charger
  EV_CHARGER

  # Heat Pump Lead
  HEAT_PUMP_LEAD

  # Intelligent Octopus Signup
  INTELLIGENT_OCTOPUS_SIGNUP

  # Credit
  CREDIT

  # Unknown
  UNKNOWN

  # Lead
  LEAD

  # Business Lead
  BUSINESS_LEAD

  # Electric Universe
  ELECTRIC_UNIVERSE

  # Energy Support
  ENERGY_SUPPORT
}

# An enumeration.
enum AppSessionOutcomeCategory {
  # Success
  SUCCESS

  # Quoted No Switch
  QUOTED_NO_SWITCH

  # Quoted No Sale
  QUOTED_NO_SALE

  # Pitch No Quote
  PITCH_NO_QUOTE

  # No Pitch
  NO_PITCH

  # Callback
  CALLBACK

  # Unsuccessful
  UNSUCCESSFUL

  # Dont Call Again
  DONT_CALL_AGAIN

  # Psr Registered
  PSR_REGISTERED

  # Smart Meter Registered
  SMART_METER_REGISTERED

  # Consumer App Download
  CONSUMER_APP_DOWNLOAD

  # Vulnerability Project
  VULNERABILITY_PROJECT

  # Transferred
  TRANSFERRED

  # Unknown
  UNKNOWN

  # Switched
  SWITCHED

  # Switched Business
  SWITCHED_BUSINESS

  # Switched Credit Check Waiver
  SWITCHED_CREDIT_CHECK_WAIVER

  # Switched First Contact
  SWITCHED_FIRST_CONTACT

  # Switched Callback
  SWITCHED_CALLBACK

  # Switched Smart Product
  SWITCHED_SMART_PRODUCT

  # Quoted No Sale Quote Emailed
  QUOTED_NO_SALE_QUOTE_EMAILED

  # Quoted No Sale Price
  QUOTED_NO_SALE_PRICE

  # Quoted No Sale Exit Fees
  QUOTED_NO_SALE_EXIT_FEES

  # Quoted No Sale No Email
  QUOTED_NO_SALE_NO_EMAIL

  # Quoted No Sale Issue Bank Details
  QUOTED_NO_SALE_ISSUE_BANK_DETAILS

  # Quoted No Sale Advanced Payment
  QUOTED_NO_SALE_ADVANCED_PAYMENT

  # Quoted No Sale Standing Charge
  QUOTED_NO_SALE_STANDING_CHARGE

  # Quoted No Sale Paper Bills
  QUOTED_NO_SALE_PAPER_BILLS

  # Quoted No Sale Monthly Dd
  QUOTED_NO_SALE_MONTHLY_DD

  # Quoted No Sale Credit Check Issue
  QUOTED_NO_SALE_CREDIT_CHECK_ISSUE

  # Quoted No Sale Waiver Wanted
  QUOTED_NO_SALE_WAIVER_WANTED

  # Quoted No Sale Deposit
  QUOTED_NO_SALE_DEPOSIT

  # Quoted No Sale Autopay
  QUOTED_NO_SALE_AUTOPAY

  # Quoted No Sale Prepay
  QUOTED_NO_SALE_PREPAY

  # Quoted No Sale Unsure Of Current Contract
  QUOTED_NO_SALE_UNSURE_OF_CURRENT_CONTRACT

  # Quoted No Sale Other
  QUOTED_NO_SALE_OTHER

  # No Pitch Switched Recently
  NO_PITCH_SWITCHED_RECENTLY

  # No Pitch Vulnerable
  NO_PITCH_VULNERABLE

  # No Pitch No D2D
  NO_PITCH_NO_D2D

  # No Pitch Not Interested
  NO_PITCH_NOT_INTERESTED

  # No Pitch Tpi Third Party
  NO_PITCH_TPI_THIRD_PARTY

  # Pitch No Quote Switched Recently
  PITCH_NO_QUOTE_SWITCHED_RECENTLY

  # Pitch No Quote Price
  PITCH_NO_QUOTE_PRICE

  # Pitch No Quote In Contract
  PITCH_NO_QUOTE_IN_CONTRACT

  # Pitch No Quote No Email
  PITCH_NO_QUOTE_NO_EMAIL

  # Pitch No Quote Not Interested
  PITCH_NO_QUOTE_NOT_INTERESTED

  # Pitch No Quote Advanced Payment
  PITCH_NO_QUOTE_ADVANCED_PAYMENT

  # Quoted Callback
  QUOTED_CALLBACK

  # Callback Pitched
  CALLBACK_PITCHED

  # No Answer
  NO_ANSWER

  # Not Bill Payer
  NOT_BILL_PAYER

  # Not Decision Maker
  NOT_DECISION_MAKER

  # Busy
  BUSY

  # Multiple Properties
  MULTIPLE_PROPERTIES

  # Callback Courtesy Call
  CALLBACK_COURTESY_CALL

  # No Cold Calling
  NO_COLD_CALLING

  # Sheltered Housing
  SHELTERED_HOUSING

  # No Fixed Address
  NO_FIXED_ADDRESS

  # Occupy Account
  OCCUPY_ACCOUNT

  # Occupier Not Bill Payer
  OCCUPIER_NOT_BILL_PAYER

  # Occupier No Answer
  OCCUPIER_NO_ANSWER

  # Occupier Refused To Discuss
  OCCUPIER_REFUSED_TO_DISCUSS

  # Occupier Suspected Empty Property
  OCCUPIER_SUSPECTED_EMPTY_PROPERTY

  # Meter Reading
  METER_READING

  # Meter Reading Unable To Take Reading
  METER_READING_UNABLE_TO_TAKE_READING

  # Meter Reading No Answer
  METER_READING_NO_ANSWER

  # Energy Help Visit Completed
  ENERGY_HELP_VISIT_COMPLETED

  # Energy Help Visit Leaflet
  ENERGY_HELP_VISIT_LEAFLET

  # Ebss Voucher Check In
  EBSS_VOUCHER_CHECK_IN

  # Wrong Address Selected
  WRONG_ADDRESS_SELECTED

  # Prepayment Meter
  PREPAYMENT_METER

  # Existing Customer
  EXISTING_CUSTOMER

  # Lead Generation
  LEAD_GENERATION

  # Lead Generation Ev
  LEAD_GENERATION_EV

  # Lead Generation Ej
  LEAD_GENERATION_EJ

  # Lead Generation Ej Lite
  LEAD_GENERATION_EJ_LITE

  # Lead Generation Business
  LEAD_GENERATION_BUSINESS

  # Lead Generation Solar
  LEAD_GENERATION_SOLAR

  # Lead Generation Heat Pump
  LEAD_GENERATION_HEAT_PUMP

  # Property Ineligible
  PROPERTY_INELIGIBLE

  # Electric Juice Switch
  ELECTRIC_JUICE_SWITCH

  # Electric Juice Switch Lite
  ELECTRIC_JUICE_SWITCH_LITE

  # Electric Juice Not Interested
  ELECTRIC_JUICE_NOT_INTERESTED

  # Ppm Requested
  PPM_REQUESTED

  # Cot Proven
  COT_PROVEN

  # Cot No Proof
  COT_NO_PROOF

  # Cos
  COS

  # Paid In Full
  PAID_IN_FULL

  # Payment Plan
  PAYMENT_PLAN

  # Paid Partial
  PAID_PARTIAL

  # Paid Reduced Settlement
  PAID_REDUCED_SETTLEMENT

  # Insolvency
  INSOLVENCY

  # Exhausted No Contact
  EXHAUSTED_NO_CONTACT

  # Exhausted Contact
  EXHAUSTED_CONTACT

  # Unable To Locate
  UNABLE_TO_LOCATE

  # Empty
  EMPTY

  # Demolished
  DEMOLISHED

  # Unable To Trace
  UNABLE_TO_TRACE

  # Prison
  PRISON

  # Vulnerable
  VULNERABLE

  # Deceased
  DECEASED

  # Withdrawn
  WITHDRAWN

  # Query
  QUERY
}

type CharityDonationHistoryType {
  totalDonatedAmount: Int
}

type BalanceForecastType {
  # Whether the balance forecast is available for the given account.
  isAvailable: Boolean
}

type AccountUrl {
  urlIdentifier: String
  url: String
}

type Urls {
  # The Wheel of Fortune URL for the given account's electricity meter.
  wheelOfFortuneElec: String

  # The Wheel of Fortune URL for the given account's gas meter.
  wheelOfFortuneGas: String

  # The meter reading submission URL for the given account.
  meterReadingSubmission: String

  # The tariff renewal URL for the given account.
  tariffRenewal: String

  # URL to book a smart meter installation for the given account and property.
  bookSmartMeterInstallation(propertyId: Int!): String

  # Pre-signed URL for editing a customers Priority Services Register preferences.
  updateSensitiveCustomerData: String

  # Pre-signed URL to join the Saving Sessions campaign.
  savingSessionsJoinCampaign: String

  # Pre-signed URL to the saving session dashboard.
  savingSessionsDashboard: String

  # Pre-signed URL to join the next Saving Sessions event.
  savingSessionsJoinNextEvent: String
    @deprecated(
      reason: "The 'savingSessionsJoinNextEvent' field is deprecated.\n\nUse the savingSessionsDashboard instead.\n\n- Marked as deprecated on 2022-10-31.\n- Will be removed on 2022-11-15."
    )
}

# Create an AWS provisioning claim certificate.
type CreateProvisioningClaim {
  # The temporary provisioning certification.
  tempProvisioningClaimCert: GenericScalar
}

# Generate a PAN (Payment Allocation Number) for a smart meter. This can be used to add credit to the meter in a shop,
# if the meter is in prepayment mode.
#
# The possible errors that can be raised are:
#
# - KT-CT-1113: Disabled GraphQL field requested.
#
type GeneratePaymentAllocationNumber {
  possibleErrors: [PossibleErrorType]

  # The Payment Allocation Number routes payments made via a PSP (Payment Service Provider) to this device.
  pan: String!
}

# Identifies a SMETS2 meter (or a SMETS1 E&A'd meter).
input SmartMeterDeviceInput {
  # Account number of customer.
  accountNumber: String!

  # Electricity or gas meter device ID.
  deviceId: String!
}

type CampaignType {
  name: String!
  slug: String!
  expiryDate: Date
}

# Quote a given account on a campaign offer.
type QuoteCampaignOffer {
  quoteCode: String
}

input QuoteCampaignOfferInput {
  # Account number.
  accountNumber: String!

  # Property to quote on.
  propertyId: Int!

  # Slug of campaign to quote on.
  campaignSlug: String!
}

# Replace the given agreement with the given product.
#
# TODO: Move this outside of plugin as it is applicable to the wider domain.
type ReplaceAgreement {
  account: AccountInterface
}

interface AccountInterface {
  # The brand of the account.
  brand: String

  # The current status of the account.
  status: AccountStatus

  # The current account balance.
  balance(
    # If this variable is set to true, the balance will be calculated based on the sum of balances on all ledgers configured to contribute to this account's balance. Otherwise, only the main ledger's balance will be fetched (legacy behaviour). If you are unsure, set this value to true.
    includeAllLedgers: Boolean = false
  ): Int!

  # The current account overdue balance.
  overdueBalance: Int

  # Unique reference number from a 3rd party enrolment.
  urn: String

  # The billing name of the account.
  billingName: String

  # The billing sub name of the account.
  billingSubName: String

  # The billing email of the account.
  billingEmail: String

  # The billing address of the account.
  billingAddress: String
  billingAddressLine1: String
  billingAddressLine2: String
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingAddressPostcode: String
  billingCountryCode: String
  billingDeliveryPointIdentifier: String

  # List of billing address lines.
  splitBillingAddress: [String]

  #
  # The billing address of this account, stored in the new
  # libaddressinput-based format.
  #
  # Note that `name` and `organization` are very unlikely to be
  # supplied here; the `billing_name` field on the account
  # itself is generally used for that purpose instead.
  #
  address: RichAddressType

  # A code that uniquely identifies the account.
  number: String

  # The portfolio this account is linked to.
  portfolio: PortfolioType

  # Ledgers provide the foundation of bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular customer account.
  ledgers(
    # The ledger to return
    ledgerId: ID

    # The ledger to return by its number
    ledgerNumber: String
  ): [LedgerType]

  # Metadata associated with the account.
  metadata: [Metadata]

  # Whether the account can request a credit refund.
  canRequestRefund: Boolean

  # Details about the eligibility status for requesting a refund.
  requestRefundEligibility: RequestRefundEligibilityType

  # The payments made into an account from a payment instruction.
  payments(
    # **WARNING: Will be mandatory in future versions**
    #
    # The ledger to return payments from.
    ledgerId: String
    status: AccountPaymentStatusOptions

    # Filter for payments that were taken for a particular reason.
    reason: PaymentReasonOptions

    # Whether to include payment promises (of any kind: made, broken or fulfilled) or not. The default is to include them.
    includePromises: Boolean = true
    before: String
    after: String
    first: Int
    last: Int
  ): AccountPaymentConnectionTypeConnection

  # The repayments that have been requested for this account.
  repayments(
    # Only return repayments whose status matches one of these statuses
    statuses: [AccountRepaymentStatusOptions]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountRepaymentConnectionTypeConnection

  # The schedules that describe how we would expect to take payments for an account on a given month.
  paymentSchedules(
    activeOnDate: Date
    active: Boolean

    # If false, we remove the currently valid schedule if it has already fulfilled its purpose and will have no further impact on customer payments, along with any schedules which are not valid from today.
    includeDormant: Boolean = true

    # The ledger to return transactions from.
    ledgerType: Int

    # The ledger id to return the payment schedules from.
    ledgerId: ID
    reason: PaymentScheduleReasonOptions
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentScheduleConnectionTypeConnection

  # A list displaying the payment forecast for an account. The list starts from today's date (inclusive).
  paymentForecast(
    # The end date to retrieve forecasts for. This end date is inclusive.
    dateTo: Date!

    # The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    ledgerId: Int
  ): [PaymentForecastType]
    @deprecated(
      reason: "The 'paymentForecast' field is deprecated.\n\nPlease use 'paginatedPaymentForecast' instead.\n\n- Marked as deprecated on 2024-01-03.\n- Will be removed on 2025-01-01."
    )

  # Paginated payment forecasts for an account. Starts from today's date (inclusive). The interface supports `last` but does not guarantee 'lastness'.
  paginatedPaymentForecast(
    # The end date to retrieve forecasts for. This end date is inclusive.
    dateTo: Date

    # The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    ledgerId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentForecastConnectionTypeConnection

  # The referrals created by this account.
  referrals(
    before: String
    after: String
    first: Int
    last: Int
  ): ReferralConnectionTypeConnection

  # Number of referrals created by this account.
  referralsCreated: Int

  # The rewards applied to this account.
  rewards: [RewardType]

  # The referral schemes currently active for this account.
  activeReferralSchemes: ReferralSchemeTypes

  # Fetch transactions that have taken place on the account.
  transactions(
    # Include only these specific transaction types in the result.
    transactionTypes: [TransactionTypeFilter] = []

    # Exclude these specific transaction types from the result.
    transactionTypesExcluded: [TransactionTypeFilter] = []

    # The ledger to return transactions from.
    ledgerId: Int

    # In a multi-ledger scenario, include all ledgers' transactions if `true`. Analogously, if `false` and no `ledgerId` argument is present, the list of transactions defaults to the main ledger (legacy behaviour).
    includeAllLedgers: Boolean

    #
    # Optional date representing the beginning of the postedDate range filter.
    # This date value is inclusive.
    #
    fromDate: Date

    #
    # Optional date representing the end of the postedDate range filter.
    # This date value is exclusive.
    #
    toDate: Date

    # The order in which to return the transactions.
    orderBy: TransactionsOrderBy = POSTED_DATE_DESC
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection
  provisionalTransactions(
    before: String
    after: String
    first: Int
    last: Int
  ): ProvisionalTransactionConnectionTypeConnection

  # Fetch annual statements for the account.
  annualStatements(
    before: String
    after: String
    first: Int
    last: Int
  ): AnnualStatementConnectionTypeConnection

  # Fetch issued bills (invoices/statements) for the account.
  bills(
    # Include bills without PDFs.
    includeBillsWithoutPDF: Boolean = false

    #
    # Include open statements. This flag needs to be used along with
    # includeBillsWithoutPDF=false otherwise results will prove unexpected.
    #
    includeOpenStatements: Boolean = false

    # Include held statements within the results.
    includeHeldStatements: Boolean = false

    # Include pre-Kraken / historical statements within the results.
    includeHistoricStatements: Boolean = true

    # Only include bills emailed to the current user's email.
    onlyCurrentEmail: Boolean = false

    # Optional date representing the beginning of the search results. This date value is inclusive.
    fromDate: Date

    # Optional date representing the end of the search results. This date value is exclusive.
    toDate: Date

    # Optional date representing the beginning of the search results based on issued date. This date value is inclusive.
    issuedFromDate: Date

    # Optional date representing the end of the search results based on issued date. This date value is exclusive.
    issuedToDate: Date

    # The order in which to return the bills.
    orderBy: BillsOrderBy = FROM_DATE_DESC
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): BillConnectionTypeConnection

  # Information about the account's billing cycle.
  billingOptions: BillingOptionsType

  # Fetch a specific issued bill (invoice/statement) for the account.
  bill(id: ID!, billType: BillTypeEnum): BillInterface

  # The direct debit instructions of the account
  directDebitInstructions(
    # Filter the direct debit instructions by status
    statuses: [DirectDebitInstructionStatus]
    before: String
    after: String
    first: Int
    last: Int
  ): DirectDebitInstructionConnectionTypeConnection

  # The account events that were recorded for the account.
  events(
    # Filter the account events by their type.
    eventTypes: [AccountEventType]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountEventConnectionTypeConnection

  # Applications by this account to become our customer. More recent applications will be listed first.
  applications(
    before: String
    after: String
    first: Int
    last: Int
  ): AccountApplicationConnectionTypeConnection

  # The type of account.
  accountType: AccountTypeChoices

  # The company type of a business account.
  businessType: BusinessTypeOptions
    @deprecated(
      reason: "The 'businessType' field is deprecated.\n\nUse `business.businessType` instead\n\n- Marked as deprecated on 2022-03-09.\n- Will be removed on 2024-01-01."
    )

  # Business info related to a business account.
  business: BusinessType

  # The method the account has specified they prefer we contact them
  commsDeliveryPreference: CommsDeliveryPreference
  communicationDeliveryPreference: String
    @deprecated(
      reason: "The 'communicationDeliveryPreference' field is deprecated.\n\nUse `commsDeliveryPreference` instead\n\n- Marked as deprecated on 2022-05-27.\n- Will be removed on 2024-01-01."
    )

  # The document accessibility preference of the account.
  documentAccessibility: DocumentAccessibilityChoices

  # Account references linked to this account.
  references: [AccountReferenceType]

  # Files attached to this account. Only available if categories defined in settings.
  fileAttachments: [AccountFileAttachment]

  # Files attached to this account.
  paginatedFileAttachments(
    # File attachment id.
    id: Int

    # File attachment category.
    category: String
    before: String
    after: String
    first: Int
    last: Int
  ): AccountFileAttachmentConnectionTypeConnection

  # The maximum amount a customer is allowed to request as a refund and the reason why that's the maximum amount.
  maximumRefund: MaximumRefundType

  # The campaigns associated with an account.
  campaigns: [AccountCampaignType]

  # True if there is an active Hardship Agreement for this account. False otherwise.
  isInHardship: Boolean

  # List of active hardship agreements for the user when is_in_hardship is True.
  activeHardshipAgreements: [HardshipAgreementType]

  # Notes for the account.
  notes: [AccountNoteType]

  # Contribution agreements for account.
  contributionAgreements: [ContributionAgreementType]

  # Assistance agreements for account.
  assistanceAgreements: [AssistanceAgreementType]

  # Debt collection proceedings for account.
  debtCollectionProceedings: [DebtCollectionProceedingType]

  # The datetime that the account was originally created.
  createdAt: DateTime

  # The language that the account preferred for communications.
  preferredLanguageForComms: String
}

enum AccountStatus {
  # A pending account is one that has been created but no registrations have started.
  PENDING

  # Account requires processes to be completed before supply can be set up
  INCOMPLETE

  # Withdrawn before supply started
  WITHDRAWN

  # Supply could have started, be ongoing or ended.
  ACTIVE

  # An error occurred when we tried to enroll a meter point. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  ENROLMENT_ERROR

  # Meter point enrollment was rejected. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  ENROLMENT_REJECTED

  # Dormant. Users should not be able to log into dormant accounts.
  DORMANT

  # Void. Account created in error.
  VOID
}

#
# A postal address.
#
# This data model is based on the structure used by Google's
# [libaddressinput library](https://github.com/google/libaddressinput)&mdash;so
# you can use it, or other libraries that use its data model
# and reference data, to accept input.
#
# All fields can be blank, except for ``country`` which must
# always be supplied.
#
type RichAddressType {
  # A personal name.
  name: String

  # The name of a business or organisation.
  organization: String

  #
  # The 'street address' component.
  #
  # This value can (and often will) contain newline characters
  # when appropriate.
  #
  # In some cases, data may appear in this field instead of the
  # below fields; e.g. a UK post town name may appear here
  # instead of in the `dependent_locality` field. This happens
  # when data has been migrated from a legacy format, and that
  # format had insufficient metadata to determine the
  # appropriate field.
  #
  # If `structured_street_address` is also set, the value of
  # this field will be a string generated from that value.
  #
  streetAddress: String

  #
  # The 'street address' component, in a structured format.
  #
  # This field stores the same value as `street_address`, but
  # with more detail; for instance, instead of `123 Example
  # Street` it might be `{'street_number': '123',
  # 'street_name': 'Example', 'street_type': 'Street'}`. In
  # many cases this will be blank; we only use this field for
  # Krakens where we need to supply this level of granularity
  # to some third-party service, like a bulk mail provider.
  #
  # The exact structure of this value depends on the country _of
  # the address_, which is not necessarily the same as the
  # country this Kraken is configured to serve. For addresses
  # outside of the countries listed below, this field will be
  # left blank.
  #
  # ### `AU`: Australia
  #
  # The following keys may be present; all are optional. All
  # keys have string values, and their meaning is the same as
  # their aseXML counterparts. (Note that, unlike aseXML, all
  # keys are provided at the top level, rather than being
  # nested.)
  #
  # - `flat_or_unit_type`
  # - `flat_or_unit_number`
  # - `floor_or_level_type`
  # - `floor_or_level_number`
  # - `building_or_property_name`
  # - `location_descriptor`
  # - `lot_number`
  # - `house_number_1`
  # - `house_number_suffix_1`
  # - `house_number_2`
  # - `house_number_suffix_2`
  # - `street_name`
  # - `street_type`
  # - `street_suffix`
  # - `postal_delivery_type`
  # - `postal_delivery_number_prefix`
  # - `postal_delivery_number_value`
  # - `postal_delivery_number_suffix`
  #
  # ### `JP`: Japan
  #
  # The following keys may be present; all are optional.
  # If keys are empty, they may be omitted from the response entirely.
  #
  # - `chome`
  # - `banchi`
  # - `go`
  # - `edaban`
  # - `kana_building_name`
  # - `kanji_building_name`
  # - `building_number`
  # - `room_number`
  # - `address_code`
  # - `physical_location_identifier`
  #
  structuredStreetAddress: GenericScalar

  #
  # UK dependent localities, or neighbourhoods or boroughs in
  # some other locations.
  #
  dependentLocality: String

  #
  # City or town portion of an address, e.g. US city, AU
  # suburb/town, IT comune, UK post town.
  #
  locality: String

  #
  # Top-level administrative subdivision, e.g. US state, AU
  # state/territory, IT region, JP prefecture.
  #
  # ### `AU`: Australia
  #
  # This must be one of `NSW`, `VIC`, `QLD`, `TAS`, `ACT`, `SA`,
  # `NT`, `WA`. For addresses not within these locations, use
  # the value that Australia Post uses, e.g. `ACT` for the
  # Jervis Bay Territory or `WA` for Christmas Island.
  #
  administrativeArea: String

  #
  # Postal code (ZIP code in the US).
  #
  postalCode: String

  #
  # Sorting code, e.g. FR CEDEX code. This field is not used in many countries.
  #
  sortingCode: String

  #
  # ISO 3166-1 alpha-2 code of the country this address belongs
  # to, e.g. `AU`, `GB`.
  #
  country: String

  #
  # Identifier used by the local postal service for this
  # address, e.g. AU DPID, GB postcode + Delivery Point Suffix,
  # US Zip-9 + Delivery Point.
  #
  # This is the value that gets encoded in the barcode printed
  # on the envelope by large-volume bulk mail providers.
  #
  deliveryPointIdentifier: String
}

# The `GenericScalar` scalar type represents a generic
# GraphQL scalar value that could be:
# String, Boolean, Int, Float, List or Object.
scalar GenericScalar

type PortfolioType {
  id: ID!
  number: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  billingName: String
  collectiveBilling: Boolean!

  # Operations team for this portfolio.
  operationsTeam: OperationsTeamType
}

type OperationsTeamType {
  id: Int
  teamName: String
  isOffline: Boolean
  isAcceptingCalls: Boolean
}

# Ledgers provide the foundation of Kraken’s bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular Kraken account.
type LedgerType implements LedgerInterface {
  id: ID

  # The display name of the ledger.
  name: String

  # The canonical name of the ledger.
  number: String

  # The ledger type code.
  ledgerType: String

  # The current balance on the ledger in minor units of currency.
  balance: Int

  # The amount owed from the customer perspective. A positive value implies the customer owes the business, while a negative amount implies the customer is in credit.
  amountOwedByCustomer: Int

  # Whether this ledger's balance contributes to the account's balance.
  affectsAccountBalance: Boolean

  # A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
  statements(
    # The id of billing document.
    statementId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): StatementBillingDocumentConnectionTypeConnection

  # An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
  invoices(
    # The id of the invoice.
    invoiceId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): InvoiceBillingDocumentConnectionTypeConnection
  transactions(
    # Return these transaction types only.
    transactionTypes: [TransactionTypeFilter] = []
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection

  # Repayment requests for a given ledger.
  repaymentRequests(
    before: String
    after: String
    first: Int
    last: Int
  ): RepaymentRequestConnectionTypeConnection

  # Refund requests for a given ledger.
  refundRequests(
    before: String
    after: String
    first: Int
    last: Int
  ): RefundRequestConnectionTypeConnection
  paymentAdequacy: PaymentAdequacyDetailsType
}

interface LedgerInterface {
  id: ID

  # The display name of the ledger.
  name: String

  # The canonical name of the ledger.
  number: String
  ledgerType: String

  # The current balance on the ledger in minor units of currency.
  balance: Int

  # The amount owed from the customer perspective. A positive value implies the customer owes the business, while a negative amount implies the customer is in credit.
  amountOwedByCustomer: Int

  # Whether this ledger's balance contributes to the account's balance.
  affectsAccountBalance: Boolean

  # A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
  statements(
    before: String
    after: String
    first: Int
    last: Int
  ): StatementBillingDocumentConnectionTypeConnection

  # An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
  invoices(
    before: String
    after: String
    first: Int
    last: Int
  ): InvoiceBillingDocumentConnectionTypeConnection
  transactions(
    # Return these transaction types only.
    transactionTypes: [TransactionTypeFilter] = []
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection

  # Repayment requests for a given ledger.
  repaymentRequests(
    before: String
    after: String
    first: Int
    last: Int
  ): RepaymentRequestConnectionTypeConnection

  # Refund requests for a given ledger.
  refundRequests(
    before: String
    after: String
    first: Int
    last: Int
  ): RefundRequestConnectionTypeConnection
  paymentAdequacy: PaymentAdequacyDetailsType
}

# A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
type StatementBillingDocumentConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [StatementBillingDocumentConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `StatementBillingDocumentConnectionType` and its cursor.
type StatementBillingDocumentConnectionTypeEdge {
  # The item at the end of the edge
  node: StatementBillingDocumentType

  # A cursor for use in pagination
  cursor: String!
}

# A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
type StatementBillingDocumentType {
  id: Int

  # The unique reference of the statement that can be used for identifying the statement externally.
  identifier: String

  # The start of the statement's period.
  startAt: DateTime!

  # The end of the statement's period.
  endAt: DateTime!

  # The date and time the statement was sent to the customer.
  firstIssuedAt: DateTime

  # The earliest charge date of the statement.
  earliestChargeAt: DateTime

  # The latest charge date of the statement.
  latestChargeAt: DateTime

  # URL to the PDF of the statement.
  pdfUrl: String

  # Billing document that annuls this statement.
  annulledBy: AnnulmentBillingDocumentType
}

# An annulment is a billing document that annuls another billing document.
type AnnulmentBillingDocumentType {
  id: Int!

  # ID of the billing document annulled by this annulment.
  annulledBillingDocumentId: Int!

  # First time the annulment was issued.
  firstIssued: DateTime

  # URL to the PDF of the annulment.
  pdfUrl: String
}

# An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
type InvoiceBillingDocumentConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [InvoiceBillingDocumentConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `InvoiceBillingDocumentConnectionType` and its cursor.
type InvoiceBillingDocumentConnectionTypeEdge {
  # The item at the end of the edge
  node: InvoiceBillingDocumentType

  # A cursor for use in pagination
  cursor: String!
}

# An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
type InvoiceBillingDocumentType {
  id: Int

  # First time the invoice was issued.
  firstIssued: DateTime

  # URL to the PDF of the Invoice.
  pdfUrl: String

  # Billing document that annuls this invoice.
  annulledBy: AnnulmentBillingDocumentType

  # The unique billing document's reference that can be used for identifying it externally.
  number: String
}

type TransactionConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [TransactionConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `TransactionConnectionType` and its cursor.
type TransactionConnectionTypeEdge {
  # The item at the end of the edge
  node: TransactionType

  # A cursor for use in pagination
  cursor: String!
}

# Transaction types which will be included or excluded, depending on the input argument.
enum TransactionTypeFilter {
  # For filtering/excluding issued transactions.
  ISSUED_TRANSACTIONS

  # For filtering/excluding energy charge transactions: Gas or Electricity.
  ENERGY_CHARGES

  # For filtering/excluding imported charge transactions.
  IMPORTED_CHARGES

  # For filtering/excluding imported credit transactions.
  IMPORTED_CREDITS

  # For filtering/excluding imported repayment transactions.
  IMPORTED_REPAYMENTS

  # For filtering/excluding imported payment transactions.
  IMPORTED_PAYMENTS
}

type RepaymentRequestConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [RepaymentRequestConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `RepaymentRequestConnectionType` and its cursor.
type RepaymentRequestConnectionTypeEdge {
  # The item at the end of the edge
  node: RepaymentRequestType

  # A cursor for use in pagination
  cursor: String!
}

type RepaymentRequestType {
  # The ID of the repayment request.
  requestId: String

  # The amount of money requested.
  amount: Int

  # Classifier code for repayment reason.
  reasonCode: String

  # The method by which the money will be transferred to the customer.
  method: RepaymentMethod

  # The payment instruction, if any, associated with the repayment request.
  instruction: PaymentInstructionType

  # The current status of the repayment request.
  status: RepaymentRequestStatus
}

#
#     Methods by which repayments can be sent to the customer.
#
enum RepaymentMethod {
  BANK_TRANSFER
  CHEQUE
  CARD
}

#
#     Possible status' for a repayment (or refund) request
#
enum RepaymentRequestStatus {
  REQUESTED
  ACCEPTED
  CANCELLED
  REJECTED
}

type RefundRequestConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [RefundRequestConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `RefundRequestConnectionType` and its cursor.
type RefundRequestConnectionTypeEdge {
  # The item at the end of the edge
  node: RefundPaymentRequestType

  # A cursor for use in pagination
  cursor: String!
}

type RefundPaymentRequestType {
  # The ID of the refund request.
  requestId: ID

  # The amount of money requested.
  amount: Int

  # The payment which is being refunded.
  payment: AccountPaymentType

  # Internal code for the reason the refund is being requested.
  reasonCode: String

  # The current status of the refund request.
  status: RepaymentRequestStatus
}

type AccountPaymentType {
  id: ID!

  # Amount of payment in pence
  amount: BigInt!

  # The date this payment is scheduled to be debited
  paymentDate: Date!
  reference: String!

  # The transaction type of the payment.
  transactionType: AccountPaymentTransactionTypeChoices

  # The current status of the payment
  status: AccountPaymentStatusOptions

  # Surcharge amount generated by this payment.
  surchargeAmount: Int
}

# An enumeration.
enum AccountPaymentTransactionTypeChoices {
  DD_FIRST_COLLECTION
  DD_REGULAR_COLLECTION
  DD_RE_PRESENTATION
  DD_FINAL_COLLECTION
  CREDIT_CARD
  DEBIT_CARD
  PREPAID_CARD
  AUSTRALIA_POST
  BACS_DEPOSIT
  BPAY
  BTRE
  BPOINT
  BRISTOL_POUND
  CASH
  CENTREPAY
  CHEQUE
  EAPA_VOUCHER
  ERRONEOUS_PAYMENT
  HEEAS
  IVR
  TRANSFER_FROM_SAP
  FUEL_DIRECT
  EFT
  URGS
  AGENCY
  PAYPOINT_CASH
  PAYPOINT_CARD
  PAYPOINT_CHEQUE
  ALLPAY_CASH
  ALLPAY_CARD
  ALLPAY_CHEQUE
  PAYZONE
  DWP
  POST_OFFICE_CASH
  POST_OFFICE_CHEQUE
  POST_OFFICE_SAVINGS_STAMPS
  POST_OFFICE_CARD
  DCA_COLLECTION
  PREPAY_KEY
  PREPAY_CARD
  PREPAY_TOKEN
  PREPAY_SMART
  PAYMENT_FEE
  FAILED_REPAYMENT_REVERSAL
  KONBINI
  PAGOPA_NOTICE
  UNKNOWN
}

# An enumeration.
enum AccountPaymentStatusOptions {
  # The payment has been scheduled for collection and the customer has been notified. While a payment is scheduled, it can still be deleted.
  SCHEDULED

  # The payment has been submitted. From this point it cannot be altered.
  PENDING

  # The payment has been approved by the merchant and added to your Kraken account.
  CLEARED

  # The payment failed permanently.
  FAILED

  # A payment promise has been created, but it has not left the customers bank account.
  PROMISED

  # The payment has been made successfully and applied to the Kraken balance.
  FULFILLED

  # The payment promise has been broken.
  PROMISE_BROKEN

  # Payments made in a previous system and then imported into Kraken.
  HISTORIC

  # Third Party payments are those recorded for financial purposes in a different system but should be added to statements.
  THIRD_PARTY

  # The initial state of a payment in Kraken. It should be scheduled with a payment vendor in the future.
  REQUESTED

  # This payment was deleted. From this point it cannot be altered.
  DELETED
}

# Payment adequacy adjusts fixed payment schedules to maintain a healthy ledger balance over a year.
type PaymentAdequacyDetailsType {
  # This ledger will be exempt from default Payment Adequacy. This may mean that it is completely exempt, or handled with special rules.
  isCurrentlyExempt: Boolean
}

type Metadata {
  # The key for the metadata.
  key: String!

  # The metadata value.
  value: JSONString
}

type RequestRefundEligibilityType {
  # Whether the account can request a refund.
  canRequestRefund: Boolean!

  # The reason why a refund cannot be requested.
  reason: String
}

type AccountPaymentConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [AccountPaymentConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `AccountPaymentConnectionType` and its cursor.
type AccountPaymentConnectionTypeEdge {
  # The item at the end of the edge
  node: AccountPaymentType

  # A cursor for use in pagination
  cursor: String!
}

enum PaymentReasonOptions {
  BALANCE_THRESHOLD_CROSSED
  BILL_ISSUED
  PAYMENT_PLAN
  REGULAR_SCHEDULE
}

type AccountRepaymentConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [AccountRepaymentConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `AccountRepaymentConnectionType` and its cursor.
type AccountRepaymentConnectionTypeEdge {
  # The item at the end of the edge
  node: AccountRepaymentType

  # A cursor for use in pagination
  cursor: String!
}

type AccountRepaymentType {
  id: ID!

  # Amount of payment in pence
  amount: BigInt!

  # The date this payment is scheduled to be debited
  paymentDate: Date!

  # The current status of the repayment
  status: AccountRepaymentStatusOptions
}

# An enumeration.
enum AccountRepaymentStatusOptions {
  # The request for a repayment has been received but not actioned yet.
  REQUESTED

  # The repayment has been approved but not made yet.
  APPROVED

  # The payment has been submitted to the merchant. It is still possible for this repayment to fail.
  SUBMITTED

  # The repayment failed permanently. This could be because of technical issues, or if the merchant rejects the payment for some reason. The payment will need to be retried by ops.
  FAILED

  # The repayment has been made to the merchant to be sent to the customer. This is a terminal state, we don't get any further confirmation.
  PAID

  # Third Party payments are those recorded for financial purposes in a different system but should be added to statements.
  THIRD_PARTY

  # Payments made in a previous system and then imported into Kraken.
  HISTORIC
}

type PaymentScheduleConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [PaymentScheduleConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `PaymentScheduleConnectionType` and its cursor.
type PaymentScheduleConnectionTypeEdge {
  # The item at the end of the edge
  node: PaymentScheduleType

  # A cursor for use in pagination
  cursor: String!
}

# An object that represents when we have agreed to take payments from a payment instruction.
type PaymentScheduleType {
  id: ID!

  # The supplementary ledger for this payment schedule, if it is on one
  supplementaryLedger: SupplementaryLedgerType
  validFrom: Date!
  validTo: Date

  # The reason the payment schedule was created.
  reason: PaymentScheduleReasonOptions
  paymentHolidayReason: String!
  paymentDay: Int

  # The frequency of the payment schedule
  paymentFrequency: PaymentFrequencyOptions
  paymentFrequencyMultiplier: Int!
  paymentAmount: Int!
  paymentAdequacyAdjustment: Int
  paymentAdequacyAdjustmentExpiryDate: Date
  isVariablePaymentAmount: Boolean!

  # The sum of the payment adequacy contributions on the payment schedule that are expected to be taken before the debt repayment is complete.
  totalDebtAmount: Int
  isPaymentHoliday: Boolean

  # The method of payment for the schedule.
  scheduleType: ScheduleType
}

# Ledgers provide the foundation of Kraken’s bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular Kraken account.
type SupplementaryLedgerType implements SupplementaryLedgerInterface {
  id: ID

  # The display name of the ledger.
  name: String
  ledgerType: String

  # The current final balance of the ledger in pence.
  currentBalance: Int
  paymentAdequacy: PaymentAdequacyDetailsType
}

interface SupplementaryLedgerInterface {
  id: ID

  # The display name of the ledger.
  name: String
  ledgerType: String

  # The current final balance of the ledger in pence.
  currentBalance: Int
  paymentAdequacy: PaymentAdequacyDetailsType
}

# An enumeration.
enum PaymentScheduleReasonOptions {
  # The default value for usual account payments.
  GENERAL_ACCOUNT_PAYMENT

  # A payment schedule created to take a payment around the supply start date of a meterpoint to help prevent accounts accruing debt.
  SSD_PAYMENT

  # A payment schedule created to take the final payment when an account is closed.
  FINAL_PAYMENT

  # A payment schedule created to take payments to pay back a debt. These schedules typically expire once the debt has been re-payed.
  DEBT_REPAYMENT_PLAN
}

# An enumeration.
enum PaymentFrequencyOptions {
  # Weekly
  Weekly

  # Monthly
  Monthly

  # Planned
  Planned
}

# An enumeration.
enum ScheduleType {
  BACS_TRANSFER
  CARD_PAYMENT
  DIRECT_DEBIT
  PAYMENT_SLIP
}

type PaymentForecastType {
  paymentNumber: Int
  date: Date
  amount: Int

  # The payment method used for the forecasted payment.
  method: ScheduleType
}

type PaymentForecastConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [PaymentForecastConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `PaymentForecastConnectionType` and its cursor.
type PaymentForecastConnectionTypeEdge {
  # The item at the end of the edge
  node: PaymentForecastType

  # A cursor for use in pagination
  cursor: String!
}

type ReferralConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [ReferralConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `ReferralConnectionType` and its cursor.
type ReferralConnectionTypeEdge {
  # The item at the end of the edge
  node: ReferralType

  # A cursor for use in pagination
  cursor: String!
}

# Details of an account referral
type ReferralType implements ReferralInterface {
  id: ID!
  paymentDate: Date

  # The type of reward scheme.
  schemeType: ReferralSchemeTypeChoices
  referredUserName: String
  paymentStatus: String
  referredUserJoinDate: DateTime
  code: String

  # Payment amount given to the referred account in pence.
  referredUserPaymentAmount: Int

  # Payment amount given to the referring account in pence.
  referringUserPaymentAmount: Int

  # The payment amount in pence received by the referrer and the referee combined.
  combinedPaymentAmount: Int
}

interface ReferralInterface {
  paymentDate: Date

  # The type of reward scheme.
  schemeType: ReferralSchemeTypeChoices
  referredUserName: String
  paymentStatus: String
  referredUserJoinDate: DateTime
  code: String

  # Payment amount given to the referred account in pence.
  referredUserPaymentAmount: Int

  # Payment amount given to the referring account in pence.
  referringUserPaymentAmount: Int

  # The payment amount in pence received by the referrer and the referee combined.
  combinedPaymentAmount: Int
}

# An enumeration.
enum ReferralSchemeTypeChoices {
  # Referral Reward.
  REFERRAL_REWARD

  # Signup Reward.
  SIGNUP_REWARD

  # Partner Reward.
  PARTNER_REWARD

  # Promo Reward.
  PROMO_REWARD

  # Legacy Referral.
  LEGACY_REFERRAL
}

#
#             A reward is based on a scheme that an account has applied for in order to be
#             eligible for a discount. Examples can include signup, promo, or partner codes that
#             were applied to an account.
#
type RewardType implements RewardInterface {
  id: ID!
  paymentDate: Date

  # The type of reward scheme.
  schemeType: ReferralSchemeTypeChoices

  # Reward amount given to the account in pence.
  rewardAmount: Int

  # The status of the reward payment.
  paymentStatus: ReferralStatusChoices
}

interface RewardInterface {
  paymentDate: Date

  # The type of reward scheme.
  schemeType: ReferralSchemeTypeChoices

  # Reward amount given to the account in pence.
  rewardAmount: Int

  # The status of the reward payment.
  paymentStatus: ReferralStatusChoices
}

# An enumeration.
enum ReferralStatusChoices {
  # Pending.
  Pending

  # Paid.
  Paid

  # Cancelled.
  Cancelled
}

type ReferralSchemeTypes {
  domestic: ReferralSchemeType
  business: ReferralSchemeType
  friendsAndFamily: ReferralSchemeType
    @deprecated(
      reason: "The 'friendsAndFamily' field is deprecated.\n\nPlease use domestic instead.\n\n- Marked as deprecated on 2020-03-05.\n- Will be removed on 2024-01-01."
    )
}

# A referral scheme is a way for one account to earn a reward for referring another. This is achieved by the referred account using a url (provided by the referring account) to sign up.
type ReferralSchemeType {
  # A fully qualified url give people to create accounts referred by this scheme.
  referralUrl: String

  # A referral url for display purposes.
  referralDisplayUrl: String

  # The reward amount received by the referrer.
  referrerRewardAmount: Int

  # The reward amount received by the referred party.
  referredRewardAmount: Int

  # The reward amount received by the referrer and the referee combined.
  combinedRewardAmount: Int

  # The number of loyalty points to be awarded to the referrer in addition to the reward amount.
  loyaltyPointsBonus: Int

  # Whether the current account is eligible to be referred under this scheme.
  canBeReferred: Boolean

  # The unique code for the scheme.
  code: String

  # The given name of the person making the referral.
  referrerGivenName: String

  # The family name of the person making the referral.
  referrerFamilyName: String
    @deprecated(
      reason: "The 'referringFamilyName' field is deprecated.\n\nOnly make use of the referrerGivenName for privacy reasons.\n\n- Marked as deprecated on 2022-11-07.\n- Will be removed on 2023-01-07."
    )

  # Scheme type of the referral scheme.
  schemeType: String
}

enum TransactionsOrderBy {
  POSTED_DATE_ASC
  POSTED_DATE_DESC
}

type ProvisionalTransactionConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [ProvisionalTransactionConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `ProvisionalTransactionConnectionType` and its cursor.
type ProvisionalTransactionConnectionTypeEdge {
  # The item at the end of the edge
  node: ProvisionalTransactionType

  # A cursor for use in pagination
  cursor: String!
}

# A provisional transaction represents some debit or credit to or from a customer's account which we cannot yet finalise for some reason, but which is still useful to keep a note of, and display to the customer. Provisional transactions are purely to give guidance in the absence of finalised information. We therefore only return provisional transactions that have not been finalised. When a transaction is finalised, it is available through the `transactions` field.
type ProvisionalTransactionType {
  id: ID!

  # A user readable string that indicates what this transaction relates to.
  title: String

  # The amount in pence for this provisional transaction. It will be negative for charges, positive for credits.
  amount: Int

  # The date at which the charge should be applied to the account.
  date: Date
}

type AnnualStatementConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [AnnualStatementConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `AnnualStatementConnectionType` and its cursor.
type AnnualStatementConnectionTypeEdge {
  # The item at the end of the edge
  node: AnnualStatementType

  # A cursor for use in pagination
  cursor: String!
}

# Annual statements that are sent to the account. They summarize important information about usage and tariffs.
type AnnualStatementType {
  periodStartsAt: DateTime!
  periodEndsAt: DateTime!
  id: ID
  pdfUrl: String
}

#
#
# This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
#
#
type BillConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [BillConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `BillConnectionType` and its cursor.
type BillConnectionTypeEdge {
  # The item at the end of the edge
  node: BillInterface

  # A cursor for use in pagination
  cursor: String!
}

interface BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  # Requesting this field generates a temporary URL at which bill is available.
  #         This URL will expire after approximately an hour.  It is intended for redirection purposes,
  #         NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  #         This field can raise an error with errorClass NOT_FOUND if the bill document has not
  #         been created/issued yet.
  #
  #
  #
  temporaryUrl: String

  # The date the bill was sent to the customer.
  issuedDate: Date
}

enum BillTypeEnum {
  STATEMENT
  INVOICE
  CREDIT_NOTE
  PRE_KRAKEN
}

enum BillsOrderBy {
  FROM_DATE_DESC
  ISSUED_DATE_DESC
}

# Information about an account's billing schedule.
type BillingOptionsType {
  # The day of the month on which the account's billing period should start.
  periodStartDay: Int
  periodLength: AccountBillingOptionsPeriodLength
  periodLengthMultiplier: Int

  # If true, this account is billed on specific day of a regular cycle. If false, the billing schedule is flexible, depending on when meter readings are submitted.
  isFixed: Boolean!

  # The date on which the current billing cycle started.
  currentBillingPeriodStartDate: Date

  # The date on which the current billing cycle will end. Null if the account is on flexible billing.
  currentBillingPeriodEndDate: Date

  # The next date on which this account will next be billed. This is the same as the start date for their next bill cycle. Null if the account is on flexible billing.
  nextBillingDate: Date
}

# An enumeration.
enum AccountBillingOptionsPeriodLength {
  # Monthly
  MONTHLY

  # Quarterly
  QUARTERLY
}

type DirectDebitInstructionConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [DirectDebitInstructionConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `DirectDebitInstructionConnectionType` and its cursor.
type DirectDebitInstructionConnectionTypeEdge {
  # The item at the end of the edge
  node: DirectDebitInstructionType

  # A cursor for use in pagination
  cursor: String!
}

# Direct Debit Instructions
type DirectDebitInstructionType {
  id: ID!
  status: String!
  sortCode: String!
  iban: String!
  accountHolder: String!
  instructionType: String!
  cardPaymentNetwork: String
  cardExpiryMonth: Int
  cardExpiryYear: Int

  # The last four digits of the account number.
  lastFourDigitsOfAccountNumber: String
    @deprecated(
      reason: "The 'lastFourDigitsOfAccountNumber' field is deprecated.\n\nUse 'maskedAccountIdentifier' for a masked reference to the instruction.\n\n- Marked as deprecated on 2021-12-23.\n- Will be removed on 2024-01-01."
    )

  # A masked reference to a recurring payment method.
  maskedAccountIdentifier: String

  # A masked version of the IBAN.
  maskedIban: String
}

# An enumeration.
enum DirectDebitInstructionStatus {
  # The instruction is active and can be used to take payments.
  ACTIVE

  # The instruction has not yet been set up.
  PROVISIONAL

  # The instruction could not be set up with the vendor.
  FAILED

  # The account for this instruction was closed.
  ACCOUNT_CLOSED
}

type AccountEventConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [AccountEventConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `AccountEventConnectionType` and its cursor.
type AccountEventConnectionTypeEdge {
  # The item at the end of the edge
  node: AccountEvent

  # A cursor for use in pagination
  cursor: String!
}

union AccountEvent = EmailEventType | PrintEventType

type EmailEventType implements Node {
  # The ID of the object
  id: ID!
  eventType: String!
  occurredAt: DateTime!

  # Email message of the email event. Returns null for message's sent/received by other user's on the account
  message: EmailType
}

# An object with an ID
interface Node {
  # The ID of the object
  id: ID!
}

# Represents an email communication
type EmailType {
  id: ID!
  channel: MessageChannel!
  toAddress: String!
  fromEmail: String!
  toNumber: String!
  fromNumber: String!
  templateCode: String!
  createdAt: DateTime!
  sentAt: DateTime

  # Attachments of the email message.
  attachments: [EmailAttachmentType]

  # Subject line of the email message.
  subject: String
  textBody: String
  htmlBody: String

  # Email sender
  sender: String

  # Email recipient
  recipient: String
}

# An enumeration.
enum MessageChannel {
  # Email
  EMAIL

  # SMS
  SMS

  # Print
  PRINT

  # Intercom
  INTERCOM

  # Junifer
  JUNIFER

  # Push Notification
  PUSH_NOTIFICATION
}

# Represents a file to attach to a email message.
type EmailAttachmentType {
  id: ID!
  filename: String!

  # Temporary URL at which the attachment is available. This URL will expire after approximately an hour. It is intended for redirection purposes, NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  temporaryUrl: String
}

type PrintEventType implements Node {
  # The ID of the object
  id: ID!
  eventType: String!
  occurredAt: DateTime!

  # Print message of the print event.
  message: PrintMessageType
}

# Represents a print communication.
type PrintMessageType implements Node {
  # The ID of the object
  id: ID!
  templateCode: String!
  account: AccountType

  # Attachments of the message.
  attachments: [PrintAttachmentType]

  # Comms that are marked as high priority.
  highPriority: Boolean
}

type SavingSessionsAccountReturnType {
  number: String!
}

# Represents a print attachment
type PrintAttachmentType {
  id: ID!
  filename: String!
  s3Bucket: String!
  s3Key: String!

  # Temporary URL at which the attachment is available. This URL will expire after approximately an hour. It is intended for redirection purposes, NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  temporaryUrl: String
}

# An enumeration.
enum AccountEventType {
  # The email messages that were sent by the account.
  EMAIL_SENT

  # The email messages that were received by the account.
  EMAIL_RECEIVED

  # The marketing email messages that were sent by the account.
  MARKETING_EMAIL_SENT

  # The print messages that were sent to the print partner by the account.
  PRINT_SENT

  # The print messages that failed to be delivered.
  PRINT_FAILED

  # The print messages that were returned to sender.
  PRINT_RETURNED

  # The print messages that were cancelled.
  PRINT_CANCELLED

  # The print messages that were sent by the print partner.
  PRINT_SUCCEEDED
}

type AccountApplicationConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [AccountApplicationConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `AccountApplicationConnectionType` and its cursor.
type AccountApplicationConnectionTypeEdge {
  # The item at the end of the edge
  node: AccountApplicationType

  # A cursor for use in pagination
  cursor: String!
}

type AccountApplicationType {
  status: AccountApplicationStatus!
  salesChannel: String!

  # The sales subchannel used when signing up. This could for example be a price comparison site.
  salesSubchannel: String

  # Date at which this account decided to switch to us.
  dateOfSale: Date

  # Last day of the cooling off period. Barring changes or objections, the account will be gained on the next business day after this date. This value will only be returned for current applications.
  coolingOffEndDate: Date

  # Whether this account application represents a migration into the current system or a regular gain.
  isMigrated: Boolean

  # The source system for a migrated account. This could be the previous supplier or the previous account management system.
  migrationSource: String
}

# An enumeration.
enum AccountApplicationStatus {
  # Current
  CURRENT

  # Failed
  FAILED

  # Historic
  HISTORIC

  # Withdrawn
  WITHDRAWN
}

# An enumeration.
enum AccountTypeChoices {
  # An account designed to supply/bill business premises.
  BUSINESS

  # An account designed to supply/bill domestic premises.
  DOMESTIC

  # An account created when we supply a business premises but do not have details for the occupants.
  BUSINESS_OCCUPIER

  # An account created when we supply a domestic premises but do not have details for the occupants.
  OCCUPIER

  # An account created when we supply domestic premises that are managed by a business, i.e., a B2B2C model.
  MANAGED

  # An account which is responsible for all other accounts in the portfolio, i.e. pays the bills for them.
  PORTFOLIO_LEAD

  # An account created when we supply a business premises and know there are definitely no occupants.
  BUSINESS_VACANT

  # An account created when we supply a domestic premises and know there are definitely no occupants.
  VACANT
}

# An enumeration.
enum BusinessTypeOptions {
  # A business account where the company type is sole trader.
  SOLE_TRADER

  # A business account where the company type is limited.
  LIMITED

  # A business account where the company type is proprietary limited.
  PROPRIETARY_LIMITED_COMPANY

  # A business account where the company type is partnership.
  PARTNERSHIP

  # A business account where the company type is charity.
  CHARITY

  # A business account where the company type is public limited.
  PUBLIC_LIMITED_COMPANY

  # A business account where the company type is limited liability partnership.
  LIMITED_LIABILITY_PARTNERSHIP

  # A business account where the company type is a trust.
  TRUST

  # A business account where the company has a trading name to carry out its business activities.
  TRADING_AS

  # A business account for a government institution.
  GOVERNMENT

  # A business account for a non-profit organisation.
  NON_PROFIT

  # A business account for a church or other religious organisation.
  CHURCH
}

type BusinessType {
  name: String!
  number: String!

  # The company type of a business account.
  businessType: BusinessTypeOptions
}

# The method the account has specified they prefer we contact them
enum CommsDeliveryPreference {
  EMAIL
  POSTAL_MAIL
}

# An enumeration.
enum DocumentAccessibilityChoices {
  # Large print documents are requested for this account.
  LARGE_PRINT

  # Braille documents are requested for this account.
  BRAILLE

  # Audio-accessible documents are requested for this account.
  AUDIO
}

type AccountReferenceType {
  namespace: String!
  value: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  account: AccountType!
}

type AccountFileAttachment implements Node & FileAttachment {
  # The ID of the object
  id: ID!
  filename: String!
  category: String!

  # Is the file uploaded to S3?
  isUploaded: Boolean

  # Is the file ready for use / downloadable?
  isReady: Boolean
  fetchUrl: String
  sizeInBytes: Int
}

interface FileAttachment {
  # Is the file uploaded to S3?
  isUploaded: Boolean

  # Is the file ready for use / downloadable?
  isReady: Boolean
  fetchUrl: String
  sizeInBytes: Int
}

type AccountFileAttachmentConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [AccountFileAttachmentConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `AccountFileAttachmentConnectionType` and its cursor.
type AccountFileAttachmentConnectionTypeEdge {
  # The item at the end of the edge
  node: AccountFileAttachment

  # A cursor for use in pagination
  cursor: String!
}

type MaximumRefundType {
  # The maximum amount available to be requested as a refund.
  amount: Int

  # The reason why a specific amount is the maximum available to be requested as a refund.
  reasonToRecommendAmount: MaximumRefundReasonChoices

  # The recommended minimum balance an account should have when asking for a refund.
  recommendedBalance: Int
}

# An enumeration.
enum MaximumRefundReasonChoices {
  # Maximum refund is equal to the current balance minus the account recommended balance.
  MAX_AVAILABLE_AMOUNT

  # Maximum refund is equal to the total amount the customer has paid using the current account Direct Debit instruction.
  TOTAL_AMOUNT_PAID_VIA_ACTIVE_DDI

  # Maximum refund is equal to the maximum refund amount allowed to be requested via the dashboard.
  MAX_ALLOWED_TO_REQUEST_VIA_DASHBOARD
}

type AccountCampaignType {
  # The date on which the associated campaign itself concludes.
  campaignExpiryDate: Date

  # The name of the campaign.
  name: String

  # The slug of the campaign.
  slug: String

  # The date on which the account's participation in the campaign ends.
  expiryDate: Date

  # The date that the account's link to the campaign started.
  startDate: Date
}

# Represents a Hardship Agreement for a particular Account.
type HardshipAgreementType {
  id: ID!
  hardshipType: HardshipAgreementHardshipType!

  # These are internal notes detailing the hardship.
  hardshipDetails: String!
  hardshipEntryReason: HardshipAgreementHardshipEntryReason
  paymentPlanDetails: String!
  startDate: Date!
}

# An enumeration.
enum HardshipAgreementHardshipType {
  # Death in the family
  DEATH_IN_FAMILY

  # Household illness
  HOUSEHOLD_ILLNESS

  # Family violence
  FAMILY_VIOLENCE

  # Unemployment
  UNEMPLOYMENT

  # Reduced income
  REDUCED_INCOME

  # Other
  OTHER
}

# An enumeration.
enum HardshipAgreementHardshipEntryReason {
  # Customer self-identified as being in hardship
  SELF_IDENTIFIED

  # Financial counsellor or external agent referral
  EXTERNAL_REFERENCE

  # Retailer referral
  RETAILER_REFERRAL
}

type AccountNoteType {
  body: String!
  isPinned: Boolean!
  createdAt: DateTime!
}

# A single Contribution Agreement.
type ContributionAgreementType {
  id: ID!

  # The scheme to which the agreement contributes.
  contributionScheme: ContributionSchemeType

  # The frequency of contributions.
  interval: Interval

  # The start datetime of the agreement.
  activeFrom: DateTime

  # The end datetime of the agreement, if any.
  activeTo: DateTime

  # The amount contributed per interval. Note, this is in the smallest domination that the currecy support. e.g. Pence, Cents, Yen, etc.
  amount: Int

  # The periods over which contributions have been made.
  periods(
    before: String
    after: String
    first: Int
    last: Int
  ): ContributionPeriodConnection
}

# A single Contribution Scheme.
type ContributionSchemeType {
  id: ID!
  code: String!
  displayName: String!

  # Are contributions to this scheme taxable?
  taxable: Boolean!

  # Is this scheme currently accepting contributions?
  acceptingContributions: Boolean!
}

#
#     The frequency at which contributations are made
#
enum Interval {
  MONTHLY
  QUARTERLY
}

# Pagination for contribution periods.
type ContributionPeriodConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [ContributionPeriodEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `ContributionPeriod` and its cursor.
type ContributionPeriodEdge {
  # The item at the end of the edge
  node: ContributionPeriodType

  # A cursor for use in pagination
  cursor: String!
}

# A single Contribution Period.
type ContributionPeriodType {
  id: ID!
  agreement: ContributionAgreementType!

  # When the contribution was fulfilled
  fulfilledAt: DateTime

  # The datetime the marks the beginning of the period.
  periodFrom: DateTime

  # The datetime the marks the end of the period.
  periodTo: DateTime
}

# A single Assistance Agreement.
type AssistanceAgreementType {
  # The type of assistance provided by the agreement.
  assistanceType: String

  # The start datetime of the agreement.
  activeFrom: Date

  # The end datetime of the agreement, if any.
  activeTo: Date
}

type DebtCollectionProceedingType {
  # The agency responsible for the collection proceedings.
  agency: DebtCollectionAgencyType

  # The campaign type of the collection proceedings.
  campaign: CollectionCampaignType
  amount: Int
  startedAt: DateTime!
  stoppedAt: DateTime
  stopReason: DebtCollectionProceedingStopReason
}

type DebtCollectionAgencyType {
  name: String!
  code: String!
  isActive: Boolean!
}

# An enumeration.
enum CollectionCampaignType {
  VULNERABLE_CUSTOMER
  HOME_VISIT
  TRACE
  DECEASED
  THIRD_PARTY
  FINAL_DEBT_COLLECTION
  FINAL_DEBT_COLLECTION_2
  OCCUPIER
  LITIGATION
  PERSISTENT_DEBT
  DEBT_COLLECTION_AGENCY
  LOW_RISK
  MEDIUM_RISK
  HIGH_RISK
  INSOLVENT
  TRACE_AND_COLLECT
  VULNERABILITY_VISIT
  LIVE_B2B
  FINAL_B2B
  B2B_DISCONNECTION_PROCESS
  SWITCH_TO_SMART_PAYG
}

# An enumeration.
enum DebtCollectionProceedingStopReason {
  # Bankrupt
  BANKRUPT

  # Deceased
  DECEASED

  # Gone away
  GONE_AWAY

  # In prison
  IN_PRISON

  # Negative trace
  NEGATIVE_TRACE

  # Paid in full
  PAID_IN_FULL

  # Process exhausted
  PROCESS_EXHAUSTED

  # Process exhausted - no contact
  PROCESS_EXHAUSTED_NO_CONTACT

  # Process exhausted - contact
  PROCESS_EXHAUSTED_CONTACT

  # Reduced settlement
  REDUCED_SETTLEMENT

  # Vulnerable
  VULNERABLE

  # Withdrawn
  WITHDRAWN

  # Write off
  WRITE_OFF

  # Payment arrangement
  PAYMENT_ARRANGEMENT

  # Payment plan agreed
  PAYMENT_PLAN_AGREED

  # Part payment
  PART_PAYMENT

  # PPM arrangement
  PPM_ARRANGEMENT

  # PPM requested
  PPM_REQUESTED

  # Arrears to client
  ARREARS_TO_CLIENT

  # High level complaint
  HIGH_LEVEL_COMPLAINT

  # Insolvencies dealing
  INSOLVENCIES_DEALING

  # Partial settlement
  PARTIAL_SETTLEMENT

  # PPM fitted
  PPM_FITTED

  # Refused to deal
  REFUSED_TO_DEAL

  # Live to final
  LIVE_TO_FINAL

  # COT / COS
  COT_COS

  # COS
  COS

  # COT proof seen
  COT_PROOF_SEEN

  # COT no proof
  COT_NO_PROOF

  # Enrolled in Error
  ENROLLED_IN_ERROR

  # Low balance
  LOW_BALANCE

  # Expired
  EXP

  # Unable to locate property
  UNABLE_TO_LOCATE_PROPERTY

  # Confirmed empty
  CONFIRMED_EMPTY

  # Demolished
  DEMOLISHED

  # Unable to trace
  UNABLE_TO_TRACE

  # Query
  QUERY
}

input ReplaceAgreementInput {
  # Account number.
  accountNumber: String!

  # MPxN of the related meter point to the agreement.
  mpxn: String!

  # Date to replace on, must be in future.
  replaceOnDate: Date!

  # Product code to replace with.
  newProductCode: String!
}

type InstallationType {
  # FIT ID of the installation.
  fitId: String

  # Meter inspection date
  inspectionAt: DateTime

  # Details of any meters attached to the installation.
  meters: [FitMeterType]

  # Address of the property linked to the installation.
  propertyAddress: PropertyAddressType
}

type FitMeterType {
  # Serial number of the meter.
  serialNumber: String

  # ID of the meter.
  id: String

  # The type of meter.
  type: String
  readings(
    before: String
    after: String
    first: Int
    last: Int
  ): FitReadingConnectionTypeConnection

  # Any installation capacities linked to the meter.
  installationCapacities: [InstallationCapacityType]

  # The maximum read volume expected for the current datetime, including any extra tolerance allowed.
  maxExpectedRead: Decimal

  # MPAN of the meter point linked to the meter.
  mpan: String
}

type FitReadingConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [FitReadingConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

# A Relay edge containing a `FitReadingConnectionType` and its cursor.
type FitReadingConnectionTypeEdge {
  # The item at the end of the edge
  node: FitReadingType

  # A cursor for use in pagination
  cursor: String!
}

type FitReadingType {
  value: Decimal!
  readAt: DateTime!
  isBiennial: Boolean
}

type InstallationCapacityType {
  declaredNetCapacity: Decimal!
  extensionReference: String!
  installedCapacity: Decimal!
}

type PropertyAddressType {
  addressLine1: String!
  addressLine2: String!
  town: String!
  county: String!
  country: String!
  postcode: String!
}

type FitScheduleType {
  # Unique Identifier of the schedule.
  scheduleId: UUID

  # Datetime the schedule was sent.
  sentAt: DateTime

  # Datetime the schedule was accepted.
  acceptedAt: DateTime

  # URLs for any schedule PDFs. URLs are temporary and will expire in approximately one hour. They are intended for redirection purposes only; they are not persistent in any form (eg. in emails or a web page body).
  temporaryDownloadUrls: [String]
}

# Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
# in fields, resolvers and input.
scalar UUID

# The possible errors that can be raised are:
#
# - KT-GB-6812: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type FitCreateMeterReadings {
  possibleErrors: [PossibleErrorType]
  readingsSubmitted: Boolean
}

input FitMeterReadingInput {
  installations: [FitInstallationInput]!
}

input FitInstallationInput {
  fitId: String!
  meters: [FitMeterInput]!
}

input FitMeterInput {
  id: Int!
  reading: FitReadingInput!
}

input FitReadingInput {
  value: Decimal!
  readAt: DateTime!
  isBiennial: Boolean
}

# FiT customers need to be able to accept their FiT schedules.
# There are a number of conditions that need to be met for a schedule:
#     - It must have been sent
#     - It must not have been accepted
#     - It must not be in the future
#
# The possible errors that can be raised are:
#
# - KT-GB-6813: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type FitAcceptSchedule {
  possibleErrors: [PossibleErrorType]

  # The accepted schedule.
  fitSchedule: FitScheduleType
}

input FitAcceptScheduleInput {
  # The ID of the schedule to accept.
  scheduleId: UUID!

  # The account number associated with this schedule.
  accountNumber: String!
}

type LivePaymentAdequacyQuery {
  # The suggested monthly payment amount in pence following the payment adequacy review.
  recommendedPayment: PaymentBreakdown

  # How much balance we expect the account to have at this time of year.
  currentBalance: Int

  # How much balance we expect the account to have at this time of year.
  targetBalance: Int

  # Breakdown of customer's usage per source and per month.
  estimatedConsumption: [ConsumptionBreakdown]

  # The date that we used to calculate the review of the account.
  reviewedOn: Date
}

type PaymentBreakdown {
  # Total to pay: ongoing + adjustment.
  total: Int

  # Amount which covers ongoing usage.
  ongoing: Int

  # Temporary amount to cover debt.
  adjustment: Int
}

type ConsumptionBreakdown {
  # Human readable name of what the usage is for.
  sourceName: String

  # Unique identifier of the source of the usage.
  sourceId: String

  # Monthly usage in pence. First month is January.
  usage: [Int]
}

type SEGInstallationType {
  # Whether the SEG installation is valid according to MCS.
  isValid: Boolean!
}

type ElectricityConsumptionType {
  # The estimated Electricity Annual Consumption measured in kWh.
  eac: Float

  # The date from which the EAC is calculated.
  eacEffectiveFromDate: Date

  # The current supplier for the meterpoint.
  supplierName: String

  # The date the meterpoint switched to the current supplier.
  supplierEffectiveFromDate: Date

  # A flag stating if the meterpoint has ever had an erroneous transfer of supplier.
  hasErroneousTransfer: Boolean
}

type GasConsumptionType {
  # The estimated Annual Quantity measured in kWh.
  aq: Int

  # The current supplier for the meterpoint.
  supplierName: String

  # The date the meterpoint switched to the current supplier.
  supplierEffectiveFromDate: Date

  # The date from which the AQ is calculated.
  aqEffectiveFromDate: Date
}

# Mutation to disable the token used to call this mutation. Requires a valid token
# for authentication to avoid a potential denial-of-service issue. The token used
# for authentication will be the token disabled.
type DisableToken {
  message: String
}

type APIKeyAuthentication {
  # The DRF token to be used for authentication.
  token: String
  errors: [ErrorType]
}

type EmailAuthentication {
  # The DRF token to be used for authentication.
  token: String
  errors: [ErrorType]
}

type ErrorType {
  field: String!
  messages: [String!]!
}

type HeatPumpGoodsQuote {
  # Account associated to quote.
  accountNumber: String

  # Quote code.
  code: String!

  # ID of the quote.
  quoteId: Int!

  # Quoted product details.
  quotedProduct: GoodsQuotedProduct!

  # Contact details stored in hubspot.
  contactDetails: ContactDetails!

  # Property details stored in hubspot.
  addressDetails: AddressDetails!
}

type GoodsQuotedProduct {
  # Product code.
  product: String

  # Number of units.
  numberOfUnits: Int

  # Price per unit.
  pricePerUnit: Int

  # Net amount.
  netAmount: Int

  # Currency.
  currency: String
}

type ContactDetails {
  # First name.
  firstName: String!

  # Last name.
  lastName: String!

  # Email.
  email: String!

  # Phone.
  phone: String!
}

type AddressDetails {
  # Unique Property Reference Number.
  uprn: String

  # First address line.
  addressLine1: String!

  # Second address line.
  addressLine2: String

  # Third address line.
  addressLine3: String

  # Fourth address line.
  addressLine4: String

  # Fifth address line.
  addressLine5: String

  # Postcode.
  postcode: String!
}

type UPRNAddressLookup {
  # Unique Property Reference Number.
  uprn: String

  # First address line.
  addressLine1: String

  # Second address line.
  addressLine2: String

  # Third address line.
  addressLine3: String

  # Fourth address line.
  addressLine4: String

  # Fifth address line.
  addressLine5: String

  # Postcode.
  postcode: String!

  # The complete and human-legible address in a single string.
  display: String!

  # The non-human-legible address in a single string.
  addressKey: String!
}

type UPRNLookup {
  # Unique Property Reference Number.
  uprn: String
}

# Create a Goods quote for heat pumps.
#
# This augments the standard goods quote with additional heat pump information.
type CreateHeatPumpGoodsQuote {
  # Generated heat pump quote.
  quote: HeatPumpGoodsQuote
}

input CreateHeatPumpGoodsQuoteInput {
  # Account to associate quote to.
  accountNumber: String

  # ID of the product to quote.
  productId: Int!

  # Details of the address.
  addressDetails: AddressDetailsInput!

  # Details to pass to hubspot.
  contactDetails: ContactDetailsInput!

  # Details of the property, used for eligiblity checks.
  propertyDetails: PropertyDetailsInput!
}

input AddressDetailsInput {
  # Unique Property Reference Number.
  uprn: String

  # First address line.
  addressLine1: String!

  # Second address line.
  addressLine2: String!

  # Third address line.
  addressLine3: String

  # Fourth address line.
  addressLine4: String

  # Fifth address line.
  addressLine5: String

  # Postcode.
  postcode: String!
}

input ContactDetailsInput {
  # First name.
  firstName: String!

  # Last name.
  lastName: String!

  # Email.
  email: String!

  # Phone.
  phone: String!

  # Consent to MBNA.
  consentToMbna: Boolean
}

input PropertyDetailsInput {
  # Property type.
  propertyType: HeatPumpPropertyType!

  # Heat type.
  heatType: HeatPumpHeatType!

  # Whether the property has outdoor space for a heat pump.
  hasOutdoorSpaceForHeatPump: Boolean

  # Whether the property has indoor space for a cylinder.
  hasIndoorSpaceForCylinder: Boolean

  # Whether the property is undergoing a home renovation.
  isHomeRenovation: Boolean
}

# An enumeration.
enum HeatPumpPropertyType {
  END_OF_TERRACE
  SEMI_DETACHED
  DETACHED
  TERRACE
  FLAT
  OTHER
  FLAT_GROUND_FLOOR
}

# An enumeration.
enum HeatPumpHeatType {
  MAINS_GAS_BOILER
  LPG_BOILER
  ELECTRIC_BOILER
  ELECTRIC_RADIATOR
  OIL_BOILER
  ELECTRIC_STORAGE_HEATER
  OTHER
}

# Create an EV Public Charging agreement.
#
# The possible errors that can be raised are:
#
# - KT-CT-4123: Unauthorized.
# - KT-CT-5811: Active agreement already exists.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateEvPublicChargingAgreement {
  possibleErrors: [PossibleErrorType]
  agreement: Agreement
}

# The input type for creating an EV Public Charging agreement.
input CreateEvPublicChargingAgreementInput {
  # The account number.
  accountNumber: String!

  # Identifier of an account in the external system.
  externalAccountId: String!

  # The start time of the agreement.
  validFrom: DateTime!
}

# Add an EV Public Charging token.
#
# The possible errors that can be raised are:
#
# - KT-CT-5817: Invalid data.
# - KT-CT-5812: Token with this value already exists within this period.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type AddEvPublicChargingToken {
  possibleErrors: [PossibleErrorType]
  token: Token
}

type Token {
  # Token's identifying value.
  value: String!
  validFrom: DateTime!
  validTo: DateTime
}

# The input type for adding an EV Public Charging token.
input AddEvPublicChargingTokenInput {
  # Identifier of an account in the external system.
  externalAccountId: String!

  # Token identifier.
  tokenValue: String!

  # The start time of token's validity.
  validFrom: DateTime!
}

# Expire an EV Public Charging token.
#
# The possible errors that can be raised are:
#
# - KT-CT-5817: Invalid data.
# - KT-CT-5818: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type ExpireEvPublicChargingToken {
  possibleErrors: [PossibleErrorType]
  token: Token
}

# The input type for expiring an EV Public Charging token.
input ExpireEvPublicChargingTokenInput {
  # Identifier of an account in the external system.
  externalAccountId: String!

  # Token identifier.
  tokenValue: String!

  # The end time of token's validity.
  validTo: DateTime!
}

# Initiate a standalone payment and return the client secret required to complete it.
#
# The possible errors that can be raised are:
#
# - KT-CT-5813: Invalid data.
# - KT-CT-5814: Invalid data.
# - KT-CT-5815: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type PostEVPublicChargingCharge {
  possibleErrors: [PossibleErrorType]
  accountCharge: AccountChargeType
}

# The input type for post an EV Public Charging charge.
input PostEVPublicChargingChargeInput {
  # The value of the token used for this session.
  tokenValue: String!

  # The line items for the new charge.
  lineItems: [EVPCLineItem!]!

  # The tax items for the new charge.
  taxItems: [EVPCTaxItem!]!
}

input EVPCLineItem {
  # The amount (excl. tax) in smallest units of currency.
  amount: Int!

  # The start of the public charging session.
  periodStartAt: DateTime!

  # The end of the public charging session.
  periodEndAt: DateTime!

  # The rate band of this line item.
  band: ProductRateBands!

  # JSON containing any additional metadata.
  metadata: JSONString
}

# The product rate band of a line item.
enum ProductRateBands {
  # CONSUMPTION.
  CONSUMPTION

  # TIME.
  TIME

  # FEE.
  FEE
}

input EVPCTaxItem {
  # The amount in smallest units of currency.
  amount: Int!

  # The amount (excl. tax) that this tax was calculated from, in smallest units of currency.
  amountTaxed: Int!

  # The rate at which tax was applied.
  rate: Decimal!

  # The unit of the tax rate.
  unitType: TaxUnitType!

  # The type of tax (e.g. 'VAT').
  taxType: String!

  # JSON containing any additional metadata.
  metadata: JSONString
}

# The dimension of the tax rate.
#
# e.g. a sales tax is a `PROPORTION` tax with a rate of 0.25, CCL is a `CURRENCY_PER_KWH` tax
# with a value of 0.5.
enum TaxUnitType {
  PROPORTION
  CURRENCY_PER_KWH
}

# The possible errors that can be raised are:
#
# - KT-CT-5816: Invalid data.
# - KT-CT-5817: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type PostEVPublicChargingCredit {
  possibleErrors: [PossibleErrorType]

  # Posts an EV Public charging credit.
  credit: Credit
}

# A credit to the customer from the energy retailer.
type Credit implements TransactionType {
  id: ID
  postedDate: Date

  # The date time when the transaction is created.
  createdAt: DateTime

  # Unique identifier of the account the transaction belongs to.
  accountNumber: String

  # Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  amount: Int
    @deprecated(
      reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01."
    )

  # The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  amounts: TransactionAmountType

  # The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  balanceCarriedForward: Int

  # Deprecated.
  isCredit: Boolean
    @deprecated(
      reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Deprecated.
  isAccountCharge: Boolean
    @deprecated(
      reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Deprecated.
  isAccountPayment: Boolean
    @deprecated(
      reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  isHeld: Boolean

  # Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  isIssued: Boolean
  title: String

  # The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  billingDocumentIdentifier: ID

  # Returns None if a statement is not linked with the transaction.
  statementId: ID
    @deprecated(
      reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01."
    )
  isReversed: Boolean!

  # Returns True if the transaction is linked with a statement.
  hasStatement: Boolean

  # Returns the note field value for the transaction, which contains additional info.
  note: String
}

# Transactions are a record of money being added or subtracted from the overall account balance
interface TransactionType {
  id: ID
  postedDate: Date

  # The date time when the transaction is created.
  createdAt: DateTime

  # Unique identifier of the account the transaction belongs to.
  accountNumber: String

  # Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  amount: Int
    @deprecated(
      reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01."
    )

  # The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  amounts: TransactionAmountType

  # The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  balanceCarriedForward: Int

  # Deprecated.
  isCredit: Boolean
    @deprecated(
      reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Deprecated.
  isAccountCharge: Boolean
    @deprecated(
      reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Deprecated.
  isAccountPayment: Boolean
    @deprecated(
      reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15."
    )

  # Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  isHeld: Boolean

  # Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  isIssued: Boolean
  title: String

  # The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  billingDocumentIdentifier: ID

  # Returns None if a statement is not linked with the transaction.
  statementId: ID
    @deprecated(
      reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01."
    )
  isReversed: Boolean!

  # Returns True if the transaction is linked with a statement.
  hasStatement: Boolean

  # Returns the note field value for the transaction, which contains additional info.
  note: String
}

# The `Date` scalar type represents a Date
# value as specified by
# [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
scalar Date

type TransactionAmountType {
  # The net amount (in minor currency units).
  net: Int

  # The amount of tax (in minor currency units).
  tax: Int

  # The gross amount (in minor currency units).
  gross: Int
}

input PostEVPublicChargingCreditInput {
  # The external account identifier.
  externalAccountId: String!

  # The net amount of the credit to be added. Amount should be posted in the smallest unit of currency.
  netAmount: Int!

  # The tax amount of the credit to be added. Amount should be posted in the smallest unit of currency.
  taxAmount: Int!

  # The reason why the credit is added.
  reason: AccountCreditReasonType!

  # Optional short note about the credit, to be displayed to the user.
  displayNote: String
}

# Create an Electric Juice agreement for an account.
type CreateElectricJuiceAgreement {
  agreement: Agreement
}

type Agreement {
  id: ID!
}

# The input type for creating an Electric Juice agreement.
input CreateElectricJuiceAgreementInput {
  # The account number.
  accountNumber: String!

  # The time from which the new agreement is valid (default: now).
  validFrom: DateTime
}

# Create a new Electric Juice charge card for an account.
type CreateElectricJuiceChargeCard {
  chargeCard: ChargeCardType
}

type ChargeCardType {
  id: ID!
  uid: String!
  nameOnCard: String!
}

# The input type for creating a new Electric Juice charge card.
input CreateElectricJuiceChargeCardInput {
  # The UID on the charge card.
  chargeCardUid: String!

  # The name printed on the charge card.
  nameOnCard: String!

  # The account number of the account this charge card should be associated with.
  accountNumber: String!
}

type Query {
  # Get all messages from the Chatbot MVP.
  getInkChatbotMessages(
    # A message's relay id, to filter out older messages.
    latestMessageRelayId: String

    # The account number.
    accountNumber: String!
  ): [InkMessage]!

  # Get a meter point via it's associated mpan or mprn.
  meterPoints(
    # The MPAN for the electricity meterpoint to return.
    mpan: ID

    # The MPRN for the gas meterpoint to return.
    mprn: ID
  ): MeterPointInterface
  applicableRates(
    accountNumber: String!
    mpxn: String!
    startAt: DateTime!
    endAt: DateTime!
    before: String
    after: String
    first: Int
    last: Int
  ): ApplicableRateConnectionTypeConnection

  # This is a work in progress and not in use yet.
  quoteRequest(
    # Code of the quote request.
    quoteCode: String!
  ): QuoteRequest

  # Follow on product.
  followOnProduct(
    # Kraken account number.
    accountNumber: String!

    # Electricity agreement Kraken ID.
    electricityAgreementId: ID

    # Gas agreement Kraken ID.
    gasAgreementId: ID
    validAt: DateTime!
  ): FollowOnProductType

  # Available energy product, whose display name has the given prefix.
  availableProductFromDisplayName(
    # Display name of the product.
    displayName: String!
  ): EnergyProductType

  # A list of product codes that are the currently available products for a meter point.
  availableProductsForMeterPoint(
    # Kraken account number.
    accountNumber: String!

    # A list of MPxNs.
    mpxns: [String]!
    availableAt: DateTime!
  ): [MPxNProductType]

  # Check meter point eligibility for an energy product.
  meterPointProductEligibility(
    # Kraken account number.
    accountNumber: String!

    # MPXN of a meter point.
    mpxn: String!

    # Energy product code.
    productCode: String!
  ): ProductEligibilityForMeterPoint

  # Get an energy product that matches the given code.
  energyProduct(
    # Code for the energy product.
    code: String!
  ): EnergyProductType

  # Get all products for a given brand and postcode. The supplied postcode will ensure that there are tariffs available on the product for the GSP.
  energyProducts(
    # Postcode to search energy products for.
    postcode: String!

    # Filter by a specific energy brand.
    brand: String

    # Filter by these brands.
    brands: [String]

    # Filter for available or unavailable products only.
    availability: EnergyProductAvailability

    # Filter by the type of energy product.
    filterBy: [EnergyProductFilters]
    before: String
    after: String
    first: Int
    last: Int
  ): EnergyProductConnectionTypeConnection
  electricityPrepayLedgers(
    accountNumber: String!
    mpan: String!
    serialNumber: String!
  ): PrepayLedgersType
  gasPrepayLedgers(
    accountNumber: String!
    mprn: String!
    serialNumber: String!
  ): PrepayLedgersType

  # Payments made to add credit to the account's smart prepay meters.
  prepayPayments(
    accountNumber: String!
    before: String
    after: String
    first: Int
    last: Int
  ): PrepayPaymentConnectionTypeConnection

  #  Get an electricity agreement.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  electricityAgreement(id: ID!): AgreementInterface

  #  Get an gas agreement.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  gasAgreement(id: ID!): AgreementInterface

  # Get the details of a product enrolment.
  productEnrolment(
    # The account to which the enrolment belongs.
    accountNumber: String!

    # The ID for the enrolment.
    enrolmentId: ID!
  ): ProductEnrolmentType

  # Get all of the enrolments for an account.
  productEnrolments(
    # The account to find all the enrolments for.
    accountNumber: String!
  ): [ProductEnrolmentType]

  # Validate a bank account.
  validateBankAccount(
    accountNumber: String!
    sortCode: String!
    vendor: PaymentsVendorChoices = SMARTDEBIT
  ): ValidateBankAccount

  # Earliest possible payment date from today for which the first direct debit payment can be made.
  earliestPossibleDirectDebitPaymentDate: EarliestPossibleDirectDebitPaymentDate

  # Get the default payment instruction for the account's Electric Juice Network ledger.
  defaultElectricJuicePaymentInstruction(
    # The account number.
    accountNumber: String!
  ): DefaultElectricJuicePaymentInstructionType

  # Heat pump goods quote.
  heatPumpGoodsQuote(
    # Quote code.
    code: String!
  ): HeatPumpGoodsQuote

  # List of addresses associated with the postcode.
  getAddressesByPostcode(
    # The postcode of the addresses to return.
    postcode: String!
  ): [UPRNAddressLookup]

  # Get uprn associated with mpan.
  getUprnByMpan(
    # The mpan of the address.
    mpan: String!
  ): UPRNLookup

  # The annual electricity consumption data for an MPAN.
  annualElectricityConsumption(
    # The MPAN of the meterpoint to return.
    mpan: String!
  ): ElectricityConsumptionType!

  # The annual gas consumption data for an MPRN.
  annualGasConsumption(
    # The MPRN of the meterpoint to return.
    mprn: String!
  ): GasConsumptionType!

  # The validity of a SEG installation via the MCS installation database.
  segInstallation(
    # The MCS certificate number.
    mcsCertificateNumber: String!
  ): SEGInstallationType!

  # Get up to date payment adequacy data.
  livePaymentAdequacy(
    # Kraken account number.
    accountNumber: String!
  ): LivePaymentAdequacyQuery

  # Get details about FIT installations attached to an account, including any meters and previous readings.
  fitInstallations(
    # Account to query for FIT installations.
    accountNumber: String!
  ): [InstallationType]

  # Get details about a FIT schedule attached to an account.
  fitSchedule(
    # The number of the account responsible for this FIT schedule.
    accountNumber: String!

    # Unique identifier for the schedule.
    scheduleId: String!
  ): FitScheduleType

  # All active campaigns with offers for the given account.
  activeCampaignOffers(accountNumber: String!): [CampaignType]

  # List URLs for an account.
  accountUrls(accountNumber: String!): [AccountUrl]
    @deprecated(
      reason: "The 'accountUrls' field is deprecated.\n\nPlease access the URLs through the support site.\n\n- Marked as deprecated on 2021-10-12.\n- Will be removed on 2024-01-01."
    )

  # List Wheel of Fortune URLs for an account.
  wofUrls(accountNumber: String!): [AccountUrl]
    @deprecated(
      reason: "The 'wofUrls' field is deprecated.\n\nPlease use `urls` query instead.\n\n- Marked as deprecated on 2021-10-12.\n- Will be removed on 2024-01-01."
    )

  # URLs for an account.
  urls(
    # The account number of the URLs' account.
    accountNumber: String!
  ): Urls

  # The balance forecast for an account.
  balanceForecast(
    # Kraken account number.
    accountNumber: String!
  ): BalanceForecastType

  # Data concerning accounts charity donations.
  charityDonationHistory(accountNumber: String!): CharityDonationHistoryType

  # The history of field sales visits to a specific address.
  fieldSalesVisits(
    # The postcode of the addresses to return.
    postcode: String!
    before: String
    after: String
    first: Int
    last: Int
  ): FieldSalesVisitConnectionTypeConnection!

  # Query relating to OctoPoints.
  octoPoints(
    # Kraken account number.
    accountNumber: String
  ): OctoPointsType
    @deprecated(
      reason: "The 'octoPoints' field is deprecated.\n\nPlease use the loyaltyPointLedgers query instead\n\n- Marked as deprecated on 2024-02-06.\n- Will be removed on 2024-05-06."
    )

  # Returns the info required to request and display live usage information for the cared-for account meter: the meter device ID and 1st address line of the property.
  octocareUsageInfo(
    # Cared-for account number.
    accountNumber: String!
  ): OctocareUsageInfo

  # Returns the info required to start the onboarding process for a Mini in the cared-for account's property, by the cared.
  octocareOnboardingInfo(
    # Cared-for account number.
    accountNumber: String!
  ): OctocareOnboardingInfo

  # The account numbers of the accounts that the user is caring for.
  caredForAccounts: [String!]!

  # Octoplus Snap constantines currently available for a given account_user.
  getConstantines(
    # Account number for the Octoplus-enrolled account.
    accountNumber: String!
  ): ConstantineSpawnData

  # Get snap for given account user.
  getSnaps(
    # Account number for the Octoplus-enrolled account.
    accountNumber: String!
  ): GetSnapsResponseType

  # Octoplus information for a given account.
  octoplusAccountInfo(
    # Kraken account number.
    accountNumber: String!
  ): OctoplusAccountInfoType

  # Feature flags for the octoplus campaign
  octoplusFeatureFlags: OctoplusFeatureFlagsType

  # Octoplus Rewards for a given account user
  octoplusRewards(
    # Id for the reward being queried.
    rewardId: Int

    # Account number for the Octoplus-enrolled account.
    accountNumber: String

    # Slug of the offer being queried.
    offerSlug: String
  ): [OctoplusRewardType]

  # Octoplus Offers available for a given account_user and account combination
  octoplusOffers(
    # Account number for the Octoplus-enrolled account.
    accountNumber: String!

    # Slug of the offer being queried.
    slug: String
  ): [OctoplusOfferType]

  # Octoplus Offer Groups available for a given account_user and account combination.
  octoplusOfferGroups(
    # Account number for the Octoplus-enrolled account.
    accountNumber: String!

    # ID of the Offer Group being queried.
    id: Int
    before: String
    after: String
    first: Int
    last: Int
  ): OctoplusOfferGroupConnectionTypeConnection

  # Describes availability of Shoptopus Vouchers for given Octopoint amounts.
  shoptopusVoucherAvailability(
    # The values (in Octopoints) for which to return voucher availability (maximum 5 values).
    voucherValues: [Int]!
  ): [ShoptopusVoucherAvailabilityType]

  # Validate referral claim code.
  validateReferralClaimCode(
    # Referral claim code value.
    value: String!
  ): ReferralClaimCodeType

  # Saving sessions queries for an account.
  savingSessions(
    # Kraken account number.
    accountNumber: String
  ): SavingSessionsType

  # Compare consumption costs for different smart tariffs.
  smartTariffComparison(
    # MPAN of the import meter point linked to the meter.
    mpan: String
  ): SmartTariffComparisonType

  # Whether the account is meets the vulnerability criteria to receive a blanket.
  doesAccountMeetVulnerabilityCriteria(
    # The account number to check.
    accountNumber: String!
  ): Boolean

  # Whether the account has already received a blanket.
  hasAlreadyReceivedBlanket(
    # The account number to check.
    accountNumber: String!
  ): Boolean

  # Whether there are still blankets available.
  areBlanketsAvailable: Boolean

  # Whether the account has already received a discount code.
  hasReceivedADiscountCode(
    # Kraken account number.
    accountNumber: String!
  ): Boolean

  # Whether or not there are remaining discount codes available at the time of querying.
  areDiscountCodesAvailable: Boolean

  # The discount code for this account, if one exists.
  discountCode(
    # Kraken account number.
    accountNumber: String!
  ): String

  # A list of wizards for onboarding devices for an account and property.
  smartFlexOnboardingWizards(
    # The account number, e.g. A-12345678.
    accountNumber: String!

    # Only list wizards for this property.
    propertyId: Int
  ): [SmartFlexOnboardingWizard!]

  # Auth details (e.g. OAuth 2.0 URI) for the provider (if available).
  providerAuthDetails(
    # The provider to get the auth details for.
    provider: ProviderChoices!

    # The device type to get the auth details for (as providers may support multiple).
    deviceType: KrakenFlexDeviceTypes!

    # The client type the request originated from. Used when oauth_uri is different between web and app.
    clientType: ClientType = APP

    # The account number that will be associated with the device. Required for some providers.
    accountNumber: String

    # The ID of the property the device belongs to.
    propertyId: Int
  ): ProviderAuthDetailsType

  # Determines whether an account is eligible to register devices with Intelligent Octopus.
  accountIoEligibility(
    # Account number.
    accountNumber: String!
  ): AccountIoEligibility

  # Virtual key details (e.g. certificate public key) for the provider (if available).
  providerVirtualKeyDetails(
    # The provider to get the virtual key details for.
    provider: ProviderChoices!

    # The device type to get the virtual key details for (as providers may support multiple).
    deviceType: KrakenFlexDeviceTypes!
  ): ProviderVirtualKeyDetailsType

  # A list of devices registered to an account.
  devices(
    # The account number, e.g. A-12345678.
    accountNumber: String!

    # Only list devices registered to this property.
    propertyId: ID

    # Only list the device with this ID.
    deviceId: String
  ): [SmartFlexDeviceInterface!]

  # A list of device types that are eligible for registration.
  eligibleDeviceTypes(
    # The account number, e.g. A-12345678.
    accountNumber: String!
  ): [KrakenFlexDeviceTypes]

  # The user specific generated OCPP details.
  ocppDetails(accountNumber: String!): OCPPDetailsType

  # To confirm whether a device is connected to OCPP.
  ocppConnection(accountNumber: String!): OCPPConnectionType

  # Vehicle charging preference details.
  vehicleChargingPreferences(
    accountNumber: String!
  ): VehicleChargingPreferencesType
    @deprecated(
      reason: "The 'vehicleChargingPreferences' field is deprecated.\n\nPlease use 'devices.chargingPreferences' instead.\n\n- Marked as deprecated on 2024-04-23.\n- Will be removed on 2024-11-01."
    )

  # A device registered with KrakenFlex for a given account.
  registeredKrakenflexDevice(accountNumber: String!): KrakenFlexDeviceType
    @deprecated(
      reason: "The 'registeredKrakenflexDevice' field is deprecated.\n\nPlease use 'devices' instead.\n\n- Marked as deprecated on 2024-04-23.\n- Will be removed on 2024-11-01."
    )

  # All planned device dispatches 24 hours ahead, (usually) in time order.
  plannedDispatches(accountNumber: String!): [UpsideDispatchType]

  # All completed device dispatches 12 hours behind, in reverse time order.
  completedDispatches(accountNumber: String!): [UpsideDispatchType]

  # Aggregated cost of charge for an EV device.
  costOfCharge(
    accountNumber: String!

    # Frequency by day, week, month or year.
    frequency: DataFrequency!

    # The start date of the results required. Overrides report date (end date) if provided.
    startDate: Date
  ): [CostOfChargeType]

  # All charge point devices.
  chargePointDevices: [ChargePointDevicesType]
    @deprecated(
      reason: "The 'chargePointDevices' field is deprecated.\n\nPlease use chargePointVariants instead of this query.\n\n- Marked as deprecated on 2023-05-10.\n- Will be removed on 2024-01-01."
    )

  # All charge points variants.
  chargePointVariants: [ChargePointVariantType]

  # All electric vehicle types and their details.
  electricVehicles(
    # Only return vehicle types for the specified make.
    make: String

    # Only return vehicle types supported by the specified provider, e.g. Tesla.
    supportedProvider: ProviderChoices

    # Only return vehicles that are currently integrated.
    isIntegrationLive: Boolean
  ): [ElectricVehicleType]

  # The user specific Enode link session details.
  enodeLinkSession(
    accountNumber: String
    vendor: EnodeVendors
  ): EnodeLinkSessionType

  # A list of vehicles available to the user.
  userVehicles(
    accountNumber: String

    # The provider used to authenticate the device (default Enode).
    supportedProvider: ProviderChoices

    # The authentication details required given the chosen provider.
    authentication: AuthenticationInput
  ): [UserVehiclesType]

  # The currently active heat pump device.
  heatPumpDevice(accountNumber: String!, propertyId: Int!): HeatPumpDeviceType

  # A heat pump registered with KrakenFlex for a given account
  heatPumpStatus(accountNumber: String!): HeatPumpStatusType

  # All heat pumps and their details.
  heatPumpVariants(
    # Only return heat pumps of a specific make.
    make: String

    # Only return (non-) deprecated heat pumps.
    isDeprecated: Boolean
  ): [HeatPumpVariantsType]

  # Retrieve the heat pump controller device status.
  heatPumpControllerStatus(accountNumber: String!, euid: ID!): ControllerStatus

  # Retrieve the heat pump controller device status.
  octoHeatPumpControllerStatus(
    accountNumber: String!
    euid: ID!
  ): ControllerStatus

  # Heat pump controller, zones and sensor configuration.
  heatPumpControllerConfiguration(
    accountNumber: String!
    euid: ID!
  ): ControllerAndZoneConfiguration

  # Heat pump controller, zones and sensor configuration.
  octoHeatPumpControllerConfiguration(
    accountNumber: String!
    euid: ID!
  ): ControllerAndZoneConfiguration

  # Heat pump controller EUIDs associated with an account.
  controllerEuids(accountNumber: String): [String]

  # Heat pump controller EUIDs associated with an account.
  octoHeatPumpControllerEuids(accountNumber: String): [String]

  # Heat pump controllers attached to an account at a given location.
  octoHeatPumpControllersAtLocation(
    accountNumber: String!
    propertyId: ID!
  ): [ControllerAtLocation]

  # Latest telemetry values from the heat pump.
  octoHeatPumpLivePerformance(euid: ID!): LiveTelemetry

  # Latest telemetry values from the heat pump.
  octoHeatPumpLifetimePerformance(euid: ID!): LifetimeTelemetry

  # Heat pump performance data over a specified period in time buckets.
  octoHeatPumpTimeSeriesPerformance(
    euid: ID!
    startAt: DateTime!
    endAt: DateTime!
    performanceGrouping: PerformanceGrouping!
  ): [HeatPumpPerformanceGroupingNode]

  # Heat pump performance data between two specific dates.
  octoHeatPumpTimeRangedPerformance(
    euid: ID!
    startAt: DateTime!
    endAt: DateTime!
  ): HeatPumpTimeRangedPerformance

  # The currently active battery device.
  batteryDevice(accountNumber: String!, propertyId: Int!): BatteryDeviceType

  # All supported batteries and their details.
  batteryVariants(
    # Only return batteries of a specific make.
    make: String
  ): [BatteryVariantsType]

  #  Retrieve the number of available Wheel of Fortune spins, per energy type, of an account by the account number.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  wheelOfFortuneSpins(
    # The account number for which the available spins are gathered.
    accountNumber: String!
  ): AvailableSpinsType!

  #  Retrieve the segments to be displayed on the Wheel of Fortune.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  wheelOfFortuneSegments: WheelSegmentsType!

  # Get current status, historic discounts and future projections for a Fan Club source.
  fanClubStatus(
    # The account number.
    accountNumber: String

    # The ID of the property.
    propertyId: Int
  ): [FanClubStatus]

  # A forecast of how green the electricity generation is predicted to be (do not assume a fixed length, that the periods are contiguous or in time order).
  greennessForecast: [GreennessForecastPeriod]

  # Get account status information given its number.
  weeklyUsageInsights(
    # The account number to search for.
    accountNumber: String!
  ): WeeklyUsageInsightsType

  # Get contribution schemes.
  contributionSchemes: [ContributionSchemeType]

  # Get the Loyalty Point ledger entries for the passed user.
  loyaltyPointLedgers: [LoyaltyPointLedgerEntryType]

  # Get the Ink conversation for a given account.
  inkConversation(
    # The account number.
    accountNumber: String

    # The conversation's relay id.
    conversationRelayId: String
  ): InkConversation!

  # Get the content for a given message.
  inkMessage(
    # The message's relay id.
    messageRelayId: String!
  ): InkMessage!

  # Get the status of a background task.
  taskResult(taskId: String!, accountNumber: String!): TaskResult

  #  A property with the given ID. Usually associated with supply points.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  property(id: ID!): PropertyType

  # Search for properties that are already in Kraken and match the search term.
  propertiesSearch(
    # The search term. It can be an address or a meter point identifier.
    searchTerm: String!
  ): [PropertySearchResult!]!

  # Search for properties that are already in Kraken and match the search term.
  propertySearch(
    # The search term. It can be an address or a meter point identifier.
    searchTerm: String!
  ): [PropertyType]
    @deprecated(
      reason: "The 'propertySearch' field is deprecated.\n\nThis query is being deprecated in favour of `propertiesSearch`. The latter returns not only the matched properties but the level of confidence in the results through the `score` field.\n\n- Marked as deprecated on 2023-05-23.\n- Will be removed on 2024-01-01."
    )

  # Get all loyalty cards for the given account user.
  loyaltyCards(
    # Account user id.
    accountUserId: String!
  ): [LoyaltyCardType]

  # Get print batch details, including messages in the batch.
  printBatch(
    # The print batch ID.
    batchId: ID
  ): PrintBatchType!

  # Get details about an embedded network.
  embeddedNetwork(id: ID!): EmbeddedNetworkType

  # Link object for an affiliate organization.
  affiliateLink(
    # The affiliate link subdomain.
    subdomain: String!
  ): AffiliateLinkType!

  # Return the details of a given affiliate organization, if any exists.
  affiliateOrganisation(
    # The affiliate organisation ID.
    id: Int!
  ): AffiliateOrganisationType

  # Return the current active referral reward scheme of a given affiliate organisation, if any exists.
  activeAffiliateReferralScheme(
    # The affiliate link subdomain.
    subdomain: String!
  ): ReferralSchemeType

  # The current version of kraken.
  krakenVersion: KrakenVersionType

  # Get the active terms and conditions for a product.
  termsAndConditionsForProduct(productCode: String!): TermsAndConditionsType

  # Return a signup referral reward scheme with the given code, if it's active.
  domesticSignupRewardScheme(
    # Reward code for the scheme.
    code: String!
  ): ReferralSchemeType

  # Return a joining reward scheme with the given code, if it's active. A joining reward can be a signup reward or a promotional reward.
  domesticJoiningRewardScheme(
    # Reward code for the scheme.
    code: String!
  ): ReferralSchemeType

  # Return a referral reward scheme for the given account referral code.
  domesticAccountReferralRewardScheme(
    # Friend referral code.
    code: String!
  ): ReferralSchemeType

  # Return the current active signup referral reward scheme with the given code, if any exists.
  activeDomesticSignupRewardScheme: ReferralSchemeType

  # Information about rate limit for viewer.
  rateLimit: RateLimitInformation
    @deprecated(
      reason: "The 'rateLimit' field is deprecated.\n\n`rateLimit` has been replaced by 'rateLimitInfo', which contains more detailed info about rate limit than the former one\n\n- Marked as deprecated on 2024-07-17.\n- Will be removed on 2025-01-01."
    )

  # Combined information about points-allowance rate limiting and request-specific rate limiting.
  rateLimitInfo: CombinedRateLimitInformation

  # Get the complexity of a query.
  queryComplexity(
    # Query and relevant variables required to calculate the complexity.
    input: QueryComplexityInputType!
  ): QueryComplexityOutputType

  # Get deposit agreements for a given account.
  depositAgreements(accountNumber: String!): [DepositAgreementOutput]

  # Get the default payment instruction for the account's main ledger.
  defaultPaymentInstruction(
    # The account number.
    accountNumber: String!

    # Provide an option to get either a CARD or DIRECT_DEBIT instruction.
    instructionType: PaymentType
  ): PaymentInstructionType
  smartMeterDataPreferences(
    accountNumber: String!
  ): SmartMeterDataPreferencesType

  # Retrieve smartmeter devices connected to the same Home Area Network.
  smartDeviceNetwork(
    # The deviceId of one of the devices on the Home Area Network.
    deviceId: String!
  ): SmartMeterDeviceNetworkType

  #
  # Query telemetry data collected by the CAD associated with the provided
  # ESME or GSME device ID.
  #
  # If only the smart meter device ID is provided, the latest data
  # available will be returned.
  #
  # Additionally including the range options (start, end, and grouping) will
  # return the data for that time period, at the desired granularity.
  #
  smartMeterTelemetry(
    # The ESME or GSME's EUI64 ID, e.g. '12-34-5A-FF-FF-6B-C7-89'
    deviceId: String!

    # The start time of the range of readings (inclusive), e.g. '2022-01-28T16:33:22+00:00'. If no UTC timezone offset is included, UTC (+00:00) will be assumed.
    start: DateTime

    # The end time of the range of readings (exclusive), e.g. '2022-01-28T16:34:42+00:00'. If no UTC timezone offset is included, UTC (+00:00) will be assumed.
    end: DateTime

    # The granularity of the returned data. The representative data item (e.g. consumption) for each group (e.g. every 5 minutes) will be the mean value over that period.
    grouping: TelemetryGrouping
  ): [SmartMeterTelemetryType]

  # Retrieve a snapshot of a prepay device balance at a moment in time.
  prepayBalanceSnapshot(
    # The ESME or GSME's EUI64 ID, e.g. '12-34-5A-FF-FF-6B-C7-89'.
    deviceId: String!
  ): PrepayBalanceSnapshotType

  # Links (urls) for the affiliate organizations.
  affiliateLinks(
    # Email address of the affiliate agent.
    agentContactEmail: String!
  ): [AffiliateLinkType!]!

  #  The currently authenticated third party.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  thirdPartyViewer: ThirdPartyOrganizationType

  # Get account status information given its number.
  accountStatusSearchByNumber(
    # The account number to search for.
    accountNumber: String!
  ): AccountWithStatusInfoType

  # Verify eligibility for a smart product.
  smartProductEligibility(
    # Product code of the smart product to verify eligibility for.
    productCode: String!

    # Vehicle to verify eligibility for.
    vehicle: VehicleEligibilityInputType!
  ): SmartProductEligibilityType

  # Get siteworks booking information for an account given its number.
  siteworksBookingAccountSearchByNumber(
    # The account number to search for.
    accountNumber: String!
  ): SiteworksBookingAccountType

  # Get siteworks booking information for an account given an MPAN.
  siteworksBookingAccountSearchByMpan(
    # The MPAN to search for.
    mpan: String!
  ): SiteworksBookingAccountType

  # Get siteworks booking information for an account given an MPRN.
  siteworksBookingAccountSearchByMprn(
    # The MPRN to search for.
    mprn: String!
  ): SiteworksBookingAccountType

  # Get siteworks booking information for accounts at a given postcode.
  siteworksBookingAccountSearchByPostcode(
    # The postcode to search for.
    postcode: String!

    # Filter the accounts by status.
    statuses: [AccountStatusChoices]
    before: String
    after: String
    first: Int
    last: Int
  ): SiteworksBookingAccountConnectionTypeConnection

  # Siteworks appointments for the provided postcode.
  siteworksAppointments(
    postcode: String!

    # Filter the Siteworks appointments by status.
    statuses: [SiteworksAppointmentStatus]!
    before: String
    after: String
    first: Int
    last: Int
  ): SiteworksAppointmentConnectionTypeConnection

  # Siteworks appointments for the provided postcode.
  externalSiteworksAppointments(
    postcode: String!

    # Filter the Siteworks appointments by status.
    statuses: [SiteworksAppointmentStatus]!
    before: String
    after: String
    first: Int
    last: Int
  ): SiteworksAppointmentConnectionTypeConnection

  # Likelihood that a smart meter at the given postcode will get a stable network connection.
  wanCoverage(postcode: String!): WANCoverageStrengths

  # Detailed WAN coverage report for a given post code and optional address identifier
  wanCoverageDetail(
    postcode: String!
    addressIdentifier: String
  ): [WanCoverageDetail]

  # Returns set of available siteworks appointment slots for the given property.
  siteworksAppointmentSlots(
    propertyId: ID!
    calculationId: String
    fromDate: Date
    agentReference: String
    slotDuration: SlotDuration
  ): SiteworksAppointmentSlotsType

  # Setting to determine delay in first poll when fetching async timeslots (in ms).
  siteworksCoconutAppointmentPollDelay: Int

  # Setting to determine interval when fetching async timeslots (in ms).
  siteworksCoconutAppointmentPollInterval: Int

  # Setting to determine how many times at most to fetch async timeslots.
  siteworksCoconutAppointmentPollMaxCount: Int

  # If a quote code and product id are supplied, this returns that quote. Otherwise it returns an empty quote. This is a convenient way to expose both existing quotes, as well as the OFGEM consumption profiles are creating a quote.
  quote(code: String): QuoteType

  # Consumption estimates based on ofgem statistics.
  consumptionEstimates: ConsumptionEstimates

  #  Fetch electricity meter readings for a given account and meter
  #
  #
  #
  # This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
  #
  #
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  electricityMeterReadings(
    accountNumber: String!
    meterId: String!
    eventTypes: [MeterReadingEventType]
    before: String
    after: String
    first: Int
    last: Int
  ): ElectricityMeterReadingConnectionTypeConnection

  #  Fetch gas meter readings for a given account and meter
  #
  #
  #
  # This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
  #
  #
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  gasMeterReadings(
    accountNumber: String!
    meterId: String!
    eventTypes: [MeterReadingEventType]
    before: String
    after: String
    first: Int
    last: Int
  ): GasMeterReadingConnectionTypeConnection

  # Get the auto top-up configs for a device. Ordered by effective from date, latest first.
  autoTopupConfigs(
    # Target device ID, e.g. 'A1-BC-D2-00-01-23-EF-4G'.
    deviceId: String!

    # Target account number, e.g. 'A-A1B2C3D4'.
    accountNumber: String!

    # The datetime from which the auto top-up is effective, e.g. '2024-01-01T00:00:00+00:00'.
    effectiveFrom: DateTime
    before: String
    after: String
    first: Int
    last: Int
  ): AutoTopupConfigConnectionTypeConnection

  # Get auto top-up trigger events for an auto topup config. Ordered by triggered_at datetime, latest first.
  autoTopupTriggers(
    # Target auto top-up config ID, e.g. '123'.
    autoTopupConfigId: ID!

    # Filter by datetime (inclusive) from which trigger events have occurred, e.g. '2024-01-01T00:00:00+00:00'.
    triggersFrom: DateTime

    # Filter by status of the auto top-up trigger event.
    status: SmartDeviceAutoTopupTriggerStatus

    # Filter by source of the auto top-up trigger event.
    source: SmartDeviceAutoTopupTriggerSources

    # Filter by failure reason of the auto top-up trigger event.
    failureReason: SmartDeviceAutoTopupTriggerFailureReasons
    before: String
    after: String
    first: Int
    last: Int
  ): AutoTopupTriggerConnectionTypeConnection
  node(
    # The ID of the object
    id: ID!
  ): Node

  # Looks up an occupier account based on postcode and last 4 digits of the account number
  occupierAccount(postcode: String!, shortcode: String!): OccupierAccount

  # The properties attached to the given account.
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  properties(accountNumber: String!, active: Boolean): [PropertyType]
  addresses(
    postcode: String!
    searchDomesticOnly: Boolean
    useDes: Boolean
    dataSource: DataSource
    before: String
    after: String
    first: Int
    last: Int
  ): AddressConnectionTypeConnection
  multipleElectricityMeterPointsForAddress(
    address: AddressSearchType
    searchDomesticOnly: Boolean
    useDes: Boolean
  ): ElectricityMeterPointForAddressType

  # Cost of usage recorded by the meter.
  costOfUsage(
    # Account number.
    accountNumber: String

    # The electricity or gas meter ID.
    meterId: String

    # The energy type, i.e. ELECTRICITY or GAS.
    fuelType: FuelType

    # Datetime the data should be queried from.
    startAt: DateTime

    # Aggregate cost according to this grouping.
    grouping: ConsumptionGroupings!

    # Timezone to use for grouping.
    timezone: String
  ): CostOfUsageType

  # Get mobile screen details to render.
  backendScreen(
    # The ID of the screen to return.
    screenId: ID!

    # List of key-value pairs (strings) to pass as parameters to the screen.
    params: [BackendScreenParamInputType]

    # The maximum version of backend screens supported by the client.
    maxVersionSupported: Int = 1
  ): BackendScreenType

  # Get a dashboard screen to render in the form of a json list of sections containing cards or grouped cards each with an order attribute.
  dashboardScreen(
    # The ID of the dashboard type screen to return.
    dashboardId: ID!

    # The account number of the user.
    accountNumber: String!

    # The maximum version of dahshboard type screens supported by the client.
    maxVersionSupported: Int! = 1

    # The ledger id associated to the account.
    ledgerId: String

    # The property id associated to the account.
    propertyId: String

    # List of key-value pairs (strings) to pass as parameters to the screen.
    params: [BackendScreenParamInputType]
  ): Dashboard

  # Get all registered backend screen IDs.
  backendScreenIds: [String]

  # Get all registered backend screen event IDs.
  backendScreenEventIds: [String]

  # Metadata for a linked object.
  metadata(linkedObjectType: LinkedObjectType, identifier: String!): [Metadata]

  # Metadata for a linked object with key.
  metadataForKey(
    linkedObjectType: LinkedObjectType
    identifier: String!
    key: String!
  ): Metadata

  # Details associated with a LeaveSupplier process.
  leaveSupplierProcess(
    # The leave supplier process ID.
    leaveSupplierProcessId: ID!
  ): LeaveSupplierProcessType

  # Get all lifecycle processes associated with an account.
  lifecycleProcesses(
    # A flag to filter out only active/current processes.
    onlyActive: Boolean

    # The account number, e.g. A-12345678.
    accountNumber: String!
  ): LifecycleProcessesType

  # List quotes given an account number or retrieve a Goods quote given a quote code.
  goodsQuotes(
    # The account number.
    accountNumber: String

    # The quote code.
    quoteCode: String
  ): [GoodsQuote]

  # List Goods products given a market.
  goodsProducts(
    # Market name of the products to list.
    marketName: String!

    # Types of the products to filter by.
    productType: [String]

    # Code of the products to filter by.
    code: [String]
    before: String
    after: String
    first: Int
    last: Int
  ): GoodsProductConnectionTypeConnection

  # List purchases for an account.
  goodsPurchases(
    # The account number.
    accountNumber: String!
  ): [GoodsPurchase]

  # The current energy generation mix.
  energyMixData: EnergyMixDataType

  # Get the customer feedback survey question.
  question(formId: Int!): String

  # Get default raw score for a customer feedback form.
  defaultRawScore(formId: Int!): Int

  # Get a connection containing API Exceptions.
  apiExceptions(
    # Fields to filter for. Otherwise don't filter at all.
    input: APIExceptionQueryInput
    before: String
    after: String
    first: Int
    last: Int
  ): APIExceptionConnectionTypeConnection

  # Check validity of a password reset token.
  isPasswordResetTokenValid(
    # Base64 encoded user id.
    userId: String!

    # Password reset token to check.
    token: String!
  ): Boolean

  # The help text of all configured password validators as plain-text or html. Defaults to plain-text.
  passwordValidatorHelpTexts(
    # Return the results as html instead of plain-text. Defaults to False.
    asHtml: Boolean = false
  ): [String]

  # List of matching account references.
  accountReference(value: String): [AccountReferenceType]

  #  The currently authenticated user.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  viewer: AccountUserType

  # Available reasons for use in account credit mutations.
  accountCreditReasons: [CreditReasonType]

  # Available reasons for use in account charge mutations.
  accountChargeReasons: [ChargeReasonType]

  # Get details about an account.
  account(accountNumber: String!): AccountType

  # Get details about multiple accounts.
  accounts(
    # A phone number to find accounts associated with.
    phoneNumber: String

    # A portfolio number to find accounts associated with.
    portfolioNumber: String
  ): [AccountType]

  # Search for account that are already in Kraken and match the search terms.
  accountsSearch(
    # Search operators.
    searchTerms: AccountSearchInputType

    # The maximum number of results to return.
    maxResults: Int = 20
  ): [AccountSearchItemType]
}

# Dovetailing rates applicable for an account / meter point combination over a given time period.
type ApplicableRateConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [ApplicableRateConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `ApplicableRateConnectionType` and its cursor.
type ApplicableRateConnectionTypeEdge {
  # The item at the end of the edge
  node: ApplicableRate

  # A cursor for use in pagination
  cursor: String!
}

type ApplicableRate {
  value: Decimal
  validFrom: DateTime
  validTo: DateTime
}

type QuoteRequest {
  # List of electricity supply points and their quoted products.
  electricitySupplyPoints: [ElectricitySupplyPoint]

  # List of gas supply points and their quoted products.
  gasSupplyPoints: [GasSupplyPoint]
  createdAt: DateTime

  # The code of the created quote.
  code: String!
}

type ElectricitySupplyPoint {
  # The Mpan of the suply point.
  mpan: String

  # Current active agreement on this supply point.
  agreement: ElectricityAgreementType

  # Annual consumption of the supply point. The type of ElectricityConsumption depends on the rateType.
  annualConsumption: ElectricityConsumption!

  # A list of quoted products and the corresponding tariff information.
  quotedProducts: [ElectricityQuotedProduct]!

  # Rate type.
  rateType: RateTypeChoices!
}

union ElectricityConsumption =
    ElectricityConsumptionStandard
  | ElectricityConsumptionLabelEco7
  | ElectricityConsumptionThreeRate

type ElectricityConsumptionStandard {
  consumption: Int
  isEstimate: Boolean
}

type ElectricityConsumptionLabelEco7 {
  day: Int
  night: Int
  isEstimate: Boolean
}

type ElectricityConsumptionThreeRate {
  day: Int
  night: Int
  offPeak: Int
  isEstimate: Boolean
}

type ElectricityQuotedProduct {
  # The ID of the quoted product.
  id: Int
  label: String

  # Energy product quoted.
  product: EnergyProductType!

  # Estimated cost in pence of the product over a year based on the quoted usage.
  annualAmount: Int!

  # Estimated cost in pence of the product per month based on the quoted usage.
  monthlyAmount: Int!

  # Electricity tariff information label (TIL) provides standardised information between suppliers about a tariff.  The type of ElectricityProductTariffInformationLabel depends on the rateType of the ElectricitySupplyPoint.
  electricityTariffInformationLabel: ElectricityProductTariffInformationLabel!
}

# An EnergyProduct models a group of tariffs for both electricity and gas.
type EnergyProductType {
  id: ID!
  fullName: String!

  # This name will be shown to customers during sign-up
  displayName: String!

  # This will be shown to customers during sign-up
  description: String!
  availableFrom: DateTime!
  availableTo: DateTime

  # Whether to hide this product from the direct registration journey
  isHidden: Boolean!
  code: String!

  # Whether the product is an import or export product.
  direction: EnergyProductDirection

  # These are internal notes to explain why this product exists
  notes: String!
  isVariable: Boolean!
  isGreen: Boolean!
  isBusiness: Boolean!
  isChargedHalfHourly: Boolean!
  isPrepay: Boolean!
  isDefault: Boolean
  isOccupier: Boolean

  # Duration of agreements using this product in months
  term: Int

  # A list of tariffs per product for a given postcode.
  tariffs(
    postcode: String!

    # Optional parameter to filter for a tariff's unit rates with a specific payment method.
    paymentMethod: PaymentMethodChoices = DIRECT_DEBIT
    before: String
    after: String
    first: Int
    last: Int
  ): EnergyTariffConnectionTypeConnection
  isAvailable: Boolean
  isUnavailable: Boolean
  isFixed: Boolean
  isDomestic: Boolean

  # Does the product have EPG applied on the unit rates.
  includesEpgReduction: Boolean

  # The exit fee applied per fuel if the agreement is ended early. Total value is determined by exit fee type, i.e. this value is either a flat cost or cost per year/month remaining on the agreement.
  exitFees: Int

  # Determines how the exit fee is calculated.
  exitFeesType: String

  # Tags associated with the product.
  tags: [String]
}

enum EnergyProductDirection {
  IMPORT
  EXPORT
}

#
#
# This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
#
#
type EnergyTariffConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [EnergyTariffConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `EnergyTariffConnectionType` and its cursor.
type EnergyTariffConnectionTypeEdge {
  # The item at the end of the edge
  node: EnergyTariffType

  # A cursor for use in pagination
  cursor: String!
}

union EnergyTariffType =
    StandardTariff
  | DayNightTariff
  | ThreeRateTariff
  | GasTariffType

enum PaymentMethodChoices {
  DIRECT_DEBIT
  NON_DIRECT_DEBIT
  PREPAYMENT
}

union ElectricityProductTariffInformationLabel =
    ProductTariffInformationLabelStandard
  | ProductTariffInformationLabelEco7
  | ProductTariffInformationThreeRate

type ProductTariffInformationLabelStandard {
  supplier: String!
  tariffFullName: String!
  tariffDisplayName: String!
  tariffType: String!
  tariffCode: String!
  tariffEndsOn: String!
  paymentMethod: PaymentMethods!
  priceGuaranteedUntil: String!
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Decimal
  estimatedAnnualCost: Int
  annualStandingCharge: Decimal!
  standingCharge: Decimal!
  unitRate: Decimal!
  assumedAnnualConsumption: Int!
}

# An enumeration.
enum PaymentMethods {
  DIRECT_DEBIT
  CREDIT_CARD
  PAY_ON_RECEIPT
}

type ProductTariffInformationLabelEco7 {
  supplier: String!
  tariffFullName: String!
  tariffDisplayName: String!
  tariffType: String!
  tariffCode: String!
  tariffEndsOn: String!
  paymentMethod: PaymentMethods!
  priceGuaranteedUntil: String!
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Decimal
  estimatedAnnualCost: Int
  annualStandingCharge: Decimal!
  standingCharge: Decimal!
  unitRateDay: Decimal!
  unitRateNight: Decimal!
  assumedAnnualConsumptionDay: Int!
  assumedAnnualConsumptionNight: Int!

  # Some tariffs expect customers to alter their usage patterns (e.g. EV tariffs) so will redistribute total consumption accordingly.
  consumptionDistributionCoefficients: ConsumptionDistributionCoefficients
}

type ConsumptionDistributionCoefficients {
  day: Decimal!
  night: Decimal!
}

type ProductTariffInformationThreeRate {
  supplier: String!
  tariffFullName: String!
  tariffDisplayName: String!
  tariffType: String!
  tariffCode: String!
  tariffEndsOn: String!
  paymentMethod: PaymentMethods!
  priceGuaranteedUntil: String!
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Decimal
  estimatedAnnualCost: Int
  annualStandingCharge: Decimal!
  standingCharge: Decimal!
  unitRateDay: Decimal!
  unitRateNight: Decimal!
  unitRateOffPeak: Decimal!
  assumedAnnualConsumptionDay: Int!
  assumedAnnualConsumptionNight: Int!
  assumedAnnualConsumptionOffPeak: Int!
}

# An enumeration.
enum RateTypeChoices {
  # Standard.
  STANDARD

  # Economy7.
  ECONOMY7

  # Three-rate.
  THREE_RATE
}

type GasSupplyPoint {
  # The Mprn of the suply point.
  mprn: String

  # Current active agreement on this supply point.
  agreement: GasAgreementType

  # Annual consumption of the supply point
  annualConsumption: GasConsumption!

  # A list of quoted products and the corresponding tariff information.
  quotedProducts: [GasQuotedProduct]!

  # Gas has only STANDARD rate type.
  rateType: String!
}

type GasConsumption {
  consumption: Int
  isEstimate: Boolean
}

type GasQuotedProduct {
  # The ID of the quoted product.
  id: Int
  label: String

  # Energy product quoted.
  product: EnergyProductType!

  # Estimated cost in pence of the product over a year based on the quoted usage.
  annualAmount: Int!

  # Estimated cost in pence of the product per month based on the quoted usage.
  monthlyAmount: Int!

  # Gas tariff information label (TIL) provides standardised information between suppliers about a tariff.
  gasTariffInformationLabel: ProductTariffInformationLabelStandard!
}

type FollowOnProductType {
  activeFrom: DateTime!
  activeTo: DateTime

  # The type of account.
  accountType: AccountTypeChoices

  # The payment method for the product.
  paymentMethod: PaymentMethods
  renewalProducts: [RenewalProductType]
  createdAt: DateTime!
}

type RenewalProductType {
  slug: String!
  product: EnergyProductType
}

type MPxNProductType {
  # Identifier for meter point.
  mpxn: String!

  # List of available products for the meter point.
  products: [EnergyProductType]
}

type ProductEligibilityForMeterPoint {
  # Whether meter point is eligible for product enrolment.
  isEligible: Boolean!

  # Meter point ineligibility reason.
  ineligibilityReason: ProductIneligibilityForMeterPointDetails
}

type ProductIneligibilityForMeterPointDetails {
  # Description on why meter point is ineligible.
  description: String

  # Code indicating why the meter point is ineligible.
  code: String
}

#
#
# This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
#
#
type EnergyProductConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [EnergyProductConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `EnergyProductConnectionType` and its cursor.
type EnergyProductConnectionTypeEdge {
  # The item at the end of the edge
  node: EnergyProductType

  # A cursor for use in pagination
  cursor: String!
}

enum EnergyProductAvailability {
  AVAILABLE
  UNAVAILABLE
}

# An enumeration.
enum EnergyProductFilters {
  # Display our prepayment products.
  PREPAY

  # Display our business products.
  BUSINESS

  # Display our domestic products.
  DOMESTIC

  # Display our variable-term products.
  VARIABLE

  # Display our fixed-term products.
  FIXED

  # Display our smart (charged half-hourly) products.
  SMART

  # Display our greenest products.
  GREEN
}

type PrepayPaymentConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [PrepayPaymentConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `PrepayPaymentConnectionType` and its cursor.
type PrepayPaymentConnectionTypeEdge {
  # The item at the end of the edge
  node: PrepayPaymentType

  # A cursor for use in pagination
  cursor: String!
}

type ProductEnrolmentType {
  id: ID!
  account: AccountType!
  status: EnrolmentStatus!

  # The product associated with the enrolment.
  product: EnergyProductType

  # The electricity meter point associated with the enrolment.
  electricityMeterPoint: ElectricityMeterPointType

  # The gas meter point associated with the enrolment.
  gasMeterPoint: GasMeterPointType

  # The stages that are part of the enrolment.
  stages: [ProductEnrolmentStageType]
}

# An enumeration.
enum EnrolmentStatus {
  # Not started
  NOT_STARTED

  # In progress
  IN_PROGRESS

  # Completed
  COMPLETED

  # Cancelled
  CANCELLED

  # Failed
  FAILED

  # Errored
  ERRORED
}

type ProductEnrolmentStageType {
  # The name of the stage.
  name: String

  # The current status of the stage.
  status: EnrolmentStepStatus

  # The steps that are part of the enrolment stage.
  steps: [ProductEnrolmentStepType]
}

# An enumeration.
enum EnrolmentStepStatus {
  SKIPPED
  COMPLETED
  PENDING
  IN_PROGRESS
  STALLED
  CANCELLED
  FAILED
  ERRORED
}

type ProductEnrolmentStepType {
  # The name of the step.
  displayName: String

  # The current status of the step.
  status: EnrolmentStepStatus

  # The date time that the step was last updated.
  updatedAt: DateTime
}

type ValidateBankAccount {
  bankName: String
  branch: String
  county: String
  line1: String
  line2: String
  line3: String
  line4: String
  town: String
  postcode: String
}

enum PaymentsVendorChoices {
  SMARTDEBIT
  GOCARDLESS
  STRIPE
  WESTPAC
  BOTTOMLINE_PTX
}

type EarliestPossibleDirectDebitPaymentDate {
  earliestPossibleDirectDebitPaymentDate: Date
}

type SmartMeterDataPreferencesType {
  # The reading frequency for the smart meter.
  readingFrequency: SmartMeterReadingFrequencyChoices

  # Has the user given consent that their readings can be used for further analysis?
  readingsAnalysisConsentProvided: Boolean

  # The datetime when the user gave consent that their readings can be used for further analysis.
  readingsAnalysisConsentUpdatedDatetime: DateTime
}

#
#     Meter reading frequency choices for smart meters.
#
#     Please note: these labels are exposed in the API documentation.
#
enum SmartMeterReadingFrequencyChoices {
  # Daily
  DAILY

  # Monthly
  MONTHLY

  # Half hourly
  HALF_HOURLY
}

type SmartMeterTelemetryType {
  # The start_at time of the telemetry data. E.g if querying in 30 minute intervals the reading may have been taken anywhere between 00:00:00 and 00:29:59 and represents the maximum reading taken in the time period.
  readAt: DateTime

  # Total energy consumed by the meter measured in Wh.
  consumption: Decimal

  # Energy being demanded by the meter measured in W.
  demand: Decimal

  # Energy consumption in Wh between the read_at and the next reading.
  consumptionDelta: Decimal

  # Energy cost for the consumption delta in pence.
  costDelta: Decimal

  # Energy cost including VAT for the consumption delta in pence.
  costDeltaWithTax: Decimal
}

enum TelemetryGrouping {
  TEN_SECONDS
  ONE_MINUTE
  FIVE_MINUTES
  HALF_HOURLY
  HOURLY
}

# A snapshot of a prepay meter's credit and debt balance at a given point in time.
type PrepayBalanceSnapshotType {
  creditInPence: Int!
  debtInPence: Int!
  emergencyCreditInPence: Int
  asAt: DateTime!
}

# Type for the third party organization.
type ThirdPartyOrganizationType {
  name: String!
}

# An object holding a subset of account.
type AccountWithStatusInfoType {
  number: String!

  # The current status of the account.
  status: AccountStatus

  # Properties linked to the account now and in the future
  properties(
    # Returns properties that have an effective period that ends at or after the given activeFrom datetime.
    activeFrom: DateTime
  ): [PropertyType]

  # The current balance of the account.
  balance: Int

  # The active payment method for the account.
  activePaymentMethod: String
}

# Verify whether vehicle is eligibile for smart product.
type SmartProductEligibilityType {
  # Whether vehicle is eligibile for smart product.
  isEligible: Boolean
}

input VehicleEligibilityInputType {
  # Registration number of a car.
  registrationNumber: String
}

# An object holding information about an account and its associated users, properties and meter points, used for administering siteworks bookings.
type SiteworksBookingAccountType {
  number: String!

  # The current status of the account.
  status: AccountStatus
  users: [AccountUserType!]!

  # Name for this account. If one exists, the billing name of the portfolio will prepend this.
  billingName: String!
  accountType: String!

  # Properties linked to the account now and in the future.
  properties: [SiteworksBookingPropertyType]

  # Siteworks requests associated to an account.
  siteworksRequests: [SiteworksRequestType]

  # Active campaigns for the account.
  activeCampaigns: [SiteworksCampaignType]

  # The interest of an account in procuring smart meters.
  smets2Interest: SmartMeterInterestChoices

  # The brand of the account.
  brand: String!
}

# This type is used by partner organisations to retrieve information about a property and its meter points that is used to book siteworks.
type SiteworksBookingPropertyType {
  id: ID!
  postcode: String!

  # Retrieve any smartmeter devices connected to the property.
  smartDeviceNetworks: [SmartMeterDeviceNetworkType]
  isChangeOfTenancyOngoing: Boolean

  # Indicates if the property meets smart meter install preconditions.
  isSmets2InstallationAllowed: Boolean

  # Retrieve the details of an electricity meter-point.
  electricityMeterPoints: [SiteworksBookingElectricityMeterPointType]

  # Retrieve the details of a gas meter-point.
  gasMeterPoints: [SiteworksBookingGasMeterPointType]

  # List of address lines.
  splitAddress: [String]
}

# This type holds information about an electricity meter point that is used by partner organisations to book siteworks.
type SiteworksBookingElectricityMeterPointType implements SiteworksBookingMeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mpan: String!

  # Standard settlement configuration
  ssc: String!
  energisationStatus: String!
  dccServiceFlag: String!
  status: String!
  isOnSupply: Boolean!

  # The latest supply period of the meterpoint.
  latestSupplyPeriod: SupplyPeriodType

  # Whether this meter point has a meter which is due a reading.
  isMeterReadingDue(maxReadingAge: Int): Boolean!
  meters(id: Int, includeInactive: Boolean): [ElectricityMeterType]

  # The distribution network the grid supply point falls under
  gspGroupId: String

  # A list of agents responsible for management of the meterpoint.
  agentContracts(
    # Filter the contracts by status.
    statuses: [AgentContractStatusType]
  ): [ElectricityAgentContractType]
}

# Interface for common fields for SiteworksBookingMeterpoints.
interface SiteworksBookingMeterPointInterface {
  status: String!
  isOnSupply: Boolean!

  # The latest supply period of the meterpoint.
  latestSupplyPeriod: SupplyPeriodType

  # Whether this meter point has a meter which is due a reading.
  isMeterReadingDue(maxReadingAge: Int): Boolean!
}

type SupplyPeriodType {
  # The start date of the supply period.
  supplyStartAt: DateTime

  # The end date of the supply period.
  supplyEndAt: DateTime
}

# This type holds information about a gas meter point that is used by partner organisations to book siteworks.
type SiteworksBookingGasMeterPointType implements SiteworksBookingMeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mprn: String
  status: String!
  isOnSupply: Boolean!

  # The latest supply period of the meterpoint.
  latestSupplyPeriod: SupplyPeriodType

  # Whether this meter point has a meter which is due a reading.
  isMeterReadingDue(maxReadingAge: Int): Boolean!
  meters(id: Int, includeInactive: Boolean): [GasMeterType]

  # A list of agents responsible for management of the meterpoint.
  agentContracts(
    # Filter the contracts by status.
    statuses: [AgentContractStatusType]
  ): [GasAgentContractType]
}

type SiteworksRequestType {
  # Siteworks appointments associated to a request.
  appointments: [ActiveAppointmentType]
}

type ActiveAppointmentType {
  id: UUID!
  agent: SiteworksAppointmentAgent

  # The current status of the Siteworks application.
  status: SiteworksAppointmentStatus
  appointmentDate: Date!
  timeSlotStart: Time
  timeSlotEnd: Time
  createdAt: DateTime!

  # The category of work the appointment has been booked for.
  workCategory: WorkCategory
  date: Date
  requestId: String
  agentReference: String
}

# An enumeration.
enum SiteworksAppointmentAgent {
  # Smart Metering Systems
  SMS

  # AES Smart Metering
  AES

  # Octopus Energy Services
  OES

  # Providor Ltd
  PROVIDOR

  # Morrison Data Services
  MDS

  # E.on Metering
  EON_METERING

  # Lowri Beck Services Ltd
  LOWRI_BECK

  # MeterPlus
  METERPLUS

  # Enterprise Managed Services Ltd
  ENTERPRISE_MANAGED

  # Midlands Electricity plc
  MIDS_ELEC

  # Northern Powergrid
  N_POWERGRID

  # Electricity North West Limited
  ELEC_NW

  # National Grid
  NATIONAL_GRID

  # SGN Metering Services
  SGN

  # Energy Assets Ltd
  ENERGY_ASSETS

  # Siemens Metering Services
  SIEMENS

  # EDF Energy Customers Ltd
  LONDON

  # EDF Energy Customers PLC
  ECM

  # Octopus Energy Services Ltd
  OESL
}

# An enumeration.
enum SiteworksAppointmentStatus {
  # The Siteworks appointment that has been booked.
  BOOKED

  # The Siteworks work that has been completed.
  COMPLETED

  # The Siteworks appointment that has been aborted.
  ABORTED

  # The Siteworks appointment that has been cancelled.
  CANCELLED
}

#
#     Categories of work that a Siteworks appointment is booked for.
#
enum WorkCategory {
  # Exchange.
  EXCHANGE

  # Move.
  MOVE

  # New Connection.
  NEW_CONNECTION

  # Remove.
  REMOVE

  # Reinstall.
  REINSTALL

  # Investigate Fault.
  INVESTIGATE_FAULT

  # Ihd Install.
  IHD_INSTALL

  # Commission.
  COMMISSION

  # Comms Hub Power Cycle.
  COMMS_HUB_POWER_CYCLE

  # Comms Hub Replacement.
  COMMS_HUB_REPLACEMENT

  # Meter Tails Upgrade.
  METER_TAILS_UPGRADE

  # Isolator Switch Install.
  ISOLATOR_SWITCH_INSTALL

  # Accuracy Test.
  ACCURACY_TEST

  # Bracket Installation.
  BRACKET_INSTALLATION

  # Confirm Meter Details.
  CONFIRM_METER_DETAILS

  # Replace Seals.
  REPLACE_SEALS

  # Energise.
  ENERGISE

  # De Energise.
  DE_ENERGISE
}

type SiteworksCampaignType {
  name: String!
  slug: String!
}

type SiteworksBookingAccountConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [SiteworksBookingAccountConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `SiteworksBookingAccountConnectionType` and its cursor.
type SiteworksBookingAccountConnectionTypeEdge {
  # The item at the end of the edge
  node: SiteworksBookingAccountType

  # A cursor for use in pagination
  cursor: String!
}

# An enumeration.
enum AccountStatusChoices {
  # A pending account is one that has been created but no registrations have started.
  PENDING

  # Account requires processes to be completed before supply can be set up
  INCOMPLETE

  # Withdrawn before supply started
  WITHDRAWN

  # Supply could have started, be ongoing or ended.
  ACTIVE

  # An error occurred when we tried to enroll a meter point. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  ENROLMENT_ERROR

  # Meter point enrollment was rejected. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  ENROLMENT_REJECTED

  # Dormant. Users should not be able to log into dormant accounts.
  DORMANT
}

type SiteworksAppointmentConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [SiteworksAppointmentConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `SiteworksAppointmentConnectionType` and its cursor.
type SiteworksAppointmentConnectionTypeEdge {
  # The item at the end of the edge
  node: SiteworksAppointmentType

  # A cursor for use in pagination
  cursor: String!
}

type SiteworksAppointmentType {
  activeAppointment: ActiveAppointmentType
  account: AccountType
  property: PropertyType
}

type WanCoverageDetail {
  postcode: String
  addressIdentifier: String
  isCoverageAvailable: Boolean
  anticipatedCoverageAt: String
  wanTechnology: String
  auxiliaryEquipment: String
  connectivityLikelihood: String
  additionalInformation: String
}

type SiteworksAppointmentSlotsType {
  calculationId: String
  slots: [SiteworksAppointmentSlotType]
  expectedJobDurationMinutes: Int
}

type SiteworksAppointmentSlotType {
  appointmentDate: Date
  startTime: Time
  endTime: Time
  agentReference: String
  siteId: String
  slotId: String
  calculationId: String
  promiseId: String
}

enum SlotDuration {
  TWO_HOUR
  AM_PM
}

type QuoteType {
  code: String
  postcode: String!
  gspGroupId: String
  includesElectricity: Boolean!
  includesGas: Boolean!
  isBusiness: Boolean!

  # The meter type for the quote.
  meterType: MeterTypes
  mpan: String!
  paymentMethod: QuotePaymentMethod!

  # In kWh
  elecAnnualConsumptionStandard: Int

  # In kWh
  elecAnnualConsumptionDay: Int

  # In kWh
  elecAnnualConsumptionNight: Int
  elecEstimate: Boolean!

  # In kWh
  gasAnnualConsumption: Int
  gasEstimate: Boolean!
  partnerProductId: Int
  latitude: Float
  longitude: Float
  address: QuoteAddressType
  consumptionEstimates: ConsumptionEstimates

  # A list of the products that have been quoted for the usage provided at the time the quote was created.
  quotedProducts(id: String): [QuotedProductType]
  termsAndConditions: TermsAndConditionsType
  mprn: String
}

# An enumeration.
enum MeterTypes {
  NO_METER
  STANDARD
  ECONOMY7
  SMART
  SMART_ECONOMY7
  SMART_FLAT_ECONOMY7
  FLAT_ECONOMY7
  THREE_RATE
  FLAT_THREE_RATE
  OTHER
}

# An enumeration.
enum QuotePaymentMethod {
  # Direct Debit
  DIRECTDEBIT

  # Credit card
  CREDITCARD

  # Pay on receipt of bill
  ONRECEIPT

  # Prepayment
  PREPAYMENT
}

type QuoteAddressType {
  addressLine1: String
  addressLine2: String
  addressLine3: String
}

type ConsumptionEstimates {
  low: ConsumptionEstimate
  medium: ConsumptionEstimate
  high: ConsumptionEstimate
}

type ConsumptionEstimate {
  elecAnnualConsumptionStandard: Int
  elecAnnualConsumptionDay: Int
  elecAnnualConsumptionNight: Int
  gasAnnualConsumption: Int
}

type QuotedProductType {
  id: ID!
  name: String!
  description: String!
  product: EnergyProductType
  recommended: Boolean!

  # Estimated cost in pence of the product per month based on the quoted usage.
  monthlyAmount: Int

  # Estimated cost in pence of the product over a year based on the quoted usage.
  annualAmount: Int

  # Estimated saving in pence vs the 'Big 6' of the product over a year based on the quoted usage.
  annualSaving: Int
  elecTariffCode: String!
  gasTariffCode: String!

  # Electricity tariff information label (TIL) provides standardised information between suppliers about a tariff.
  electricityTariffInformationLabel: TariffInformationLabelType

  # Gas tariff information label (TIL) provides standardised information between suppliers about a tariff.
  gasTariffInformationLabel: TariffInformationLabelStandard

  # Whether or not this is a variable product.
  isVariable: Boolean

  # A list of dates allowable to start supply of the quoted product.
  allowedSupplyStartDates: [Date]

  # The amount of co2 saved per year when this product is chosen
  co2SavingInKg: Int

  # The number of trees it would take to offset the amount of co2 that is saved per year when this product is chosen
  treesSaving: Int
  includesCarbonOffsetting: Boolean
}

union TariffInformationLabelType =
    TariffInformationLabelStandard
  | TariffInformationLabelEco7
  | TariffInformationLabelThreeRate

type TariffInformationLabelStandard {
  supplier: String
  tariffName: String
  tariffType: String
  tariffCode: String
  paymentMethod: String
  tariffEndsOn: String
  priceGuaranteedUntil: String
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Float
  standingCharge: Float
  estimatedAnnualCost: Int
  annualStandingCharge: Float
  unitRate: Float
  assumedAnnualConsumption: Int
}

type TariffInformationLabelEco7 {
  supplier: String
  tariffName: String
  tariffType: String
  tariffCode: String
  paymentMethod: String
  tariffEndsOn: String
  priceGuaranteedUntil: String
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Float
  standingCharge: Float
  estimatedAnnualCost: Int
  annualStandingCharge: Float
  unitRateDay: Float
  unitRateNight: Float
  assumedAnnualConsumptionDay: Int
  assumedAnnualConsumptionNight: Int
}

type TariffInformationLabelThreeRate {
  supplier: String
  tariffName: String
  tariffType: String
  tariffCode: String
  paymentMethod: String
  tariffEndsOn: String
  priceGuaranteedUntil: String
  exitFees: Int
  exitFeesType: String
  additionals: String
  tariffComparisonRate: Float
  standingCharge: Float
  estimatedAnnualCost: Int
  annualStandingCharge: Float
  unitRateDay: Float
  unitRateNight: Float
  unitRateOffPeak: Float
  assumedAnnualConsumptionDay: Int
  assumedAnnualConsumptionNight: Int
  assumedAnnualConsumptionOffPeak: Int
}

# Represents groupings of meter reading events Meter readings can be filtered by these event types.
enum MeterReadingEventType {
  CUSTOMER
  SMART_METER
  ESTIMATE
  CHANGE_OF_SUPPLY
  METER_EXCHANGE
  PREPAY
  PRE_SUPPLIER
  DATA_COLLECTOR
}

# GraphQL output type for querying nodes of auto top-up configs.
#
# Using this class instead of AutoTopupConfigType directly allows for pagination.
type AutoTopupConfigConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [AutoTopupConfigConnectionTypeEdge]!
}

# A Relay edge containing a `AutoTopupConfigConnectionType` and its cursor.
type AutoTopupConfigConnectionTypeEdge {
  # The item at the end of the edge
  node: AutoTopupConfigType

  # A cursor for use in pagination
  cursor: String!
}

# GraphQL output type for querying auto top-up configs.
type AutoTopupConfigType {
  id: ID!

  # The account number, e.g.: 'A-A1B2C3D4'.
  accountNumber: String!

  # Alphanumber code identifying the device, e.g.: 'A1-BC-D2-00-01-23-EF-4G'.
  deviceId: String!

  # Auto top-up amount in the lowest currency unit. i.e. USA cents / GBP pence / etc.
  topupAmount: Int!

  # The date and time when the config became effective.
  effectiveFrom: DateTime!

  # The date and time when the config stopped being effective.
  effectiveTo: DateTime
}

# GraphQL output type for querying nodes of auto top-up trigger events.
#
# Using this class instead of AutoTopupTriggerType directly allows for pagination.
type AutoTopupTriggerConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [AutoTopupTriggerConnectionTypeEdge]!
}

# A Relay edge containing a `AutoTopupTriggerConnectionType` and its cursor.
type AutoTopupTriggerConnectionTypeEdge {
  # The item at the end of the edge
  node: AutoTopupTriggerType

  # A cursor for use in pagination
  cursor: String!
}

# GraphQL output type for querying auto top-up trigger events.
type AutoTopupTriggerType {
  id: ID!

  # Integer ID of the related AutoTopupConfig, e.g. '123'.
  autoTopupConfigId: ID!

  # DateTime when auto topup was triggered, e.g. '2024-01-01T00:00:00+00:00'.
  triggeredAt: DateTime!

  # Status of the auto top-up trigger event.
  status: SmartDeviceAutoTopupTriggerStatus!

  # Source of the auto top-up trigger event.
  source: SmartDeviceAutoTopupTriggerSources!

  # Reason auto top-up trigger event failed, if any.
  failureReason: SmartDeviceAutoTopupTriggerFailureReasons

  # DateTime when the trigger event was created, e.g. '2024-01-01T00:00:00+00:00'.
  createdAt: DateTime!

  # DateTime when the trigger event was last updated, e.g. '2024-01-01T00:00:00+00:00'.
  updatedAt: DateTime!
}

# An enumeration.
enum SmartDeviceAutoTopupTriggerStatus {
  INITIATED
  COMPLETED
  FAILED
}

# An enumeration.
enum SmartDeviceAutoTopupTriggerSources {
  LOW_CREDIT_BALANCE
}

# An enumeration.
enum SmartDeviceAutoTopupTriggerFailureReasons {
  NO_IMPORT_METER
  FAILED_TO_COLLECT_PAYMENT
  PAYMENT_NOT_SUCCESSFUL
  FAILED_TO_TRIGGER_ADD_CREDIT_TO_METER
}

type OccupierAccount {
  account: String!
  address: String!
  date: String!
  propertyId: Int!

  # A Kraken Token that can be used to call the 'occupy' mutation for the account.
  occupyToken: String!
}

#
#
# This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
#
#
type AddressConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [AddressConnectionTypeEdge]!

  # Total number of nodes.
  totalCount: Int!

  # Number of nodes in the edge.
  edgeCount: Int!
}

# A Relay edge containing a `AddressConnectionType` and its cursor.
type AddressConnectionTypeEdge {
  # The item at the end of the edge
  node: AddressType

  # A cursor for use in pagination
  cursor: String!
}

type AddressType {
  # A unique ID per address using part of the address with spaces removed.
  addressKey: String!

  # The type of address (domestic, business or unknown).
  addressType: AddressTypeEnum

  # The complete and human-legible address in a single string.
  display: String!

  # The ID of the Grid Supply Point Group that the address belongs to.
  gspGroupId: String!

  # Line 1 of the address. This is generally the house number and street name.
  line1: String!

  # Line 2 of the address. This is generally the area or village.
  line2: String!

  # Line 3 of the address. This is generally the area or village.
  line3: String!

  # Line 4 of the address. This is generally the city.
  line4: String!

  # Line 5 of the address. This is generally the county.
  line5: String!
  postcode: String!

  # The identifier for a property. The house number consists of the part of line 1 of the address that is not the street name. This includes sub-building names, building names, deliver point aliases and building numbers. For example, the house number for the property 'Flat 12 100 Example St' would be 'Flat 12 100'.
  houseNumber: String

  # The street name for a property. The street name consists of the part of line 1 of the address that is not the house number. For example, the house number for the property 'Flat 12 100 Example St' would be 'Example St'.
  streetName: String
  hasPrepaidMeters: Boolean!
  gasMeterPoints: [AddressAPIGasMeterPointType]
  electricityMeterPoints: [AddressAPIElectricityMeterPointType]
}

# An enumeration.
enum AddressTypeEnum {
  DOMESTIC
  BUSINESS
  UNKNOWN
}

type AddressAPIGasMeterPointType {
  mprn: String
}

type AddressAPIElectricityMeterPointType {
  mpan: String
  profileClass: String
}

enum DataSource {
  CACHE
  LIVE
}

type ElectricityMeterPointForAddressType {
  addressHasMoreThanOneElectricityMeterPoint: Boolean!

  # List of meterpoints associated with the address. Only returned if address_has_more_than_one_electricity_meter_point is True.
  electricityMeterPoints: [String]

  # Line 1 of the address returned from the search
  addressLine1: String

  # Line 2 of the address returned from the search
  addressLine2: String

  # The postcode of the address returned from the search
  postcode: String
}

input AddressSearchType {
  addressLine1: String!
  addressLine2: String!
  addressLine3: String!
  town: String!
  county: String!
  postcode: String!
}

type CostOfUsageType {
  # Whether cost of usage can be displayed for a user.
  costEnabled: Boolean

  # Energy product direction, e.g. IMPORT or EXPORT.
  direction: String

  # Cost of usage for given period.
  details(
    # The meter ID.
    meterId: String

    # The energy type, i.e. ELECTRICITY or GAS.
    fuelType: FuelType
    startAt: DateTime

    # Aggregate cost according to this grouping.
    grouping: ConsumptionGroupings!

    # Timezone to use for grouping.
    timezone: String
    before: String
    after: String
    first: Int
    last: Int
  ): CostOfUsageConnectionTypeConnection
}

# Dovetailing usage and cost for an account / meter combination over a given time period.
type CostOfUsageConnectionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!

  # Contains the nodes in this connection.
  edges: [CostOfUsageConnectionTypeEdge]!

  # Overall cost of nodes in the edge.
  cost: Int

  # Overall usage of nodes in the edge.
  usageKwh: Decimal!
}

# A Relay edge containing a `CostOfUsageConnectionType` and its cursor.
type CostOfUsageConnectionTypeEdge {
  # The item at the end of the edge
  node: IntervalCostOfUsageType

  # A cursor for use in pagination
  cursor: String!
}

# Usage and cost between two points in time.
type IntervalCostOfUsageType {
  # Interval start datetime.
  startAt: DateTime

  # Interval end datetime.
  endAt: DateTime

  # Cost per time interval.
  cost: Int

  # Usage per time interval.
  usageKwh: Decimal
}

# An enumeration.
enum FuelType {
  # Electricity.
  ELECTRICITY

  # Gas.
  GAS

  # Dual Fuel.
  DUAL_FUEL
}

# Payment Instructions
type DefaultElectricJuicePaymentInstructionType {
  id: ID!
  instructionType: String!
  cardPaymentNetwork: String
  cardExpiryMonth: Int
  cardExpiryYear: Int
  validFrom: DateTime!

  # The provider to use for this DDI. Most accounts would have SmartDebit as their provider, Iresa customers use GoCardless
  vendor: String!
  cardNumber: String!
  cardType: String
}

# Store a new card instruction for Electric Juice from an embedded form.
#
# The possible errors that can be raised are:
#
# - KT-CT-3923: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type StoreElectricJuicePaymentInstruction {
  possibleErrors: [PossibleErrorType]
  paymentInstruction: PaymentInstructionType
}

# The GraphQL error type for displaying information about
# GraphQL errors that might be raised from the API.
type PossibleErrorType {
  # The error message that might be returned from the query/mutation.
  message: String

  # The error code that might be returned from the query/mutation.
  code: String

  # The error type that might be returned from the query/mutation.
  type: String

  # The error description that might be returned from the query/mutation.
  description: String
}

# Payment Instructions
type PaymentInstructionType {
  id: ID!
  status: String!
  sortCode: String!
  iban: String!
  accountHolder: String!
  instructionType: String!
  cardPaymentNetwork: String
  cardExpiryMonth: Int
  cardExpiryYear: Int
  bankCode: String
  accountType: String
  validFrom: DateTime!

  # The provider to use for this DDI. Most accounts would have SmartDebit as their provider, Iresa customers use GoCardless
  vendor: String!
  cardNumber: String!
  cardType: String

  # A masked reference to a recurring payment method.
  maskedAccountIdentifier: String
}

# The input for storing a new card instruction from an embedded form.
input StoreElectricJuicePaymentInstructionInput {
  # The account number.
  accountNumber: String!

  # The datetime from which the instruction is vaild.
  validFrom: DateTime!

  # The vendor's reference for this payment method.
  vendorReference: String!
}

type Mutation {
  # Register an Ink message from OEGB chatbot.
  # This mutation has been created specifically designed for the MVP
  # It can be removed once a better implementation is found
  createInkChatbotMessage(
    input: CreateInkChatbotMessageInput!
  ): CreateInkChatbotMessagePayload

  # Calculate the deposit amount. Record the deposit amount and return the key
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  calculateDepositAmount(
    calculateDepositAmountInput: CalculateDepositAmountInput!
  ): CalculateDepositAmount

  # Create and retrieve a business credit risk analysis.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-10701: Unable to fetch company's credit data.
  # - KT-CT-10702: Company not found.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  checkBusinessCreditRisk(
    # Input for checking business credit risk.
    checkBusinessCreditRiskInput: CheckBusinessCreditRiskInput!
  ): CheckBusinessCreditRisk

  # Create product rate(s) for a certain product.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-9514: No available product found.
  # - KT-GB-9518: Invalid input data for product rate(s).
  # - KT-GB-9519: Unable to create product rate(s).
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createProductRates(
    # List of rates to be created for the specified product.
    input: CreateProductRatesInputType!

    # Code of the product for which the rates are being created.
    productCode: String!
  ): CreateProductRates

  # DO NOT USE: WIP Create a quote for new meter points for products with passed in tag.
  quoteNewMeterPoints(input: QuoteNewMeterPointsInput!): QuoteNewMeterPoints

  # DO NOT USE: WIP Create a quote for new meter points on passed in products with bespoke rates. This is an acquisition quote mutation only to be used by authenticated third party organisations for bespoke quoting.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4616: Unable to create a quote.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  quoteNewMeterPointsOnBespokeProducts(
    input: QuoteNewMeterPointsOnBespokeProductsInput!
  ): QuoteNewMeterPointsOnBespokeProducts

  # Create a quote for an existing account for the specified meterpoints on the passed in products.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4616: Unable to create a quote.
  # - KT-GB-4614: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  quoteAccountOnProducts(
    input: QuoteAccountOnProductsInput!
  ): QuoteAccountOnProducts

  # Create a renewal quote request.
  createRenewalQuoteRequest(
    input: CreateRenewalQuoteRequestInput!
  ): CreateRenewalQuoteRequest

  # Create a renewal quote request for specified products without persisting to the database.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4624: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createQuoteRequestForProducts(
    input: CreateQuoteRequestForProductsInput!
  ): CreateQuoteRequestForProducts

  # Create an acquisition quote request for requested products without persisting to the database.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4625: Unable to create quote request.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  createAcquisitionQuoteRequestForProducts(
    input: CreateAcquisitionQuoteRequestForProductsInput!
  ): CreateAcquisitionQuoteRequestForProducts

  # Add a refund request to an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4127: Unable to send refund request confirmation email.
  # - KT-GB-4121: Unable to process refund request.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createRefundRequest(
    # Input fields for creating a refund request.
    input: RefundRequestInput!
  ): CreateRefundRequest

  # Update smart meter data preferences of an account. Includes updating reading frequency and readings analysis consent.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4023: Unauthorized.
  # - KT-GB-4015: Cannot update smart meter reading frequency preferences.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateSmartMeterDataPreferences(
    # Input fields for updating smart meter data preferences.
    input: UpdateSmartMeterDataPreferencesInput!
  ): UpdateSmartMeterDataPreferences

  # Joins a device to a HAN (Home Area Network).
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4019: This device type is not currently supported.
  # - KT-GB-4020: Error sending the request to join the device to the Home Area Network.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  joinDeviceToNetwork(
    # Device ID of the CHF (Communications Hub Function).
    chfDeviceId: String!

    # Code that authorises joining of the device to the HAN.
    installCode: String

    # MPAN/MPRN of the meter or HCALCS to join to the HAN.
    mpxn: String

    # Device ID of the device to join to the HAN.
    newDeviceId: String!

    # Type of device that is being joined to the HAN.
    newDeviceType: JoinableDeviceType!
  ): JoinDeviceToNetwork

  # Commissions the device after the meter has been physically installed.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4021: Invalid MPxN.
  # - KT-GB-4022: MPxN not recognised.
  # - KT-GB-4023: Error sending the request to commission the device.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  commissionMeter(
    # Input fields for commission meters.
    input: CommissionMeterInput!
  ): CommissionMeter

  # Decommissions a device using SmartPear's 'remove device' orchestration.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4024: The provided device ID does not match any devices known by Kraken.
  # - KT-GB-4025: Error sending the request to decommission the device.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  decommissionSmartDevice(
    # Input fields for decommission meters.
    input: DecommissionSmartDeviceInput!
  ): DecommissionSmartDevice

  # Notify Kraken to run the relevant prenotifications for a new device.
  registerSmartDevice(
    # Specifies device metadata to use for prenotifications.
    input: RegisterSmartDeviceInput!
  ): RegisterSmartDevice

  # Update the status of the CHF (Communictions Hub).
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4026: Either the mpxn or mpan input must be provided.
  # - KT-GB-4027: If both mpxn and mpan are provided, they must match.
  # - KT-GB-4028: Please input a valid MPxN.
  # - KT-GB-4029: Meter point not found for MPAN.
  # - KT-GB-4030: Meter point not found for MPRN.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateCommsHubStatus(
    # Input fields for updating the status of the communications hub.
    input: UpdateCommsHubStatusInput!
  ): UpdateCommsHubStatus

  # Triggers the orchestration to join the PPMID, IHD, CAD or Alt HAN device to the ESME, GSME, GPF and/or CHF. This should be called after a meter has been commissioned.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4053: Fuel type should not be specified for Alt HAN device.
  # - KT-GB-4031: Error sending the request to join the device to the CHF.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  joinConsumerDevice(
    # Input fields for join device.
    input: JoinConsumerDeviceInput!
  ): JoinConsumerDevice

  # Triggers the orchestration to remove the CAD device to the ESME, GSME, GPF and CHF.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4012: Unable to find the CAD device.
  # - KT-GB-4032: Error sending the request to remove the device.
  # - KT-GB-4013: Received invalid device type to remove other than CAD.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  removeConsumerDevice(
    # Input fields for remove device.
    input: RemoveConsumerDeviceInput!
  ): RemoveConsumerDevice

  # Add credit to a smart prepay meter
  addCreditToSmartMeter(
    # Controls which meter to top-up and by how much.
    input: SmartPrepayMeterAmountInput!
  ): AddCreditToSmartMeter

  # Request an ad hoc read of the meters consumption data, which will arrive asynchronously
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4033: No electricity device found matching device ID.
  # - KT-GB-4034: Error requesting consumption data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  requestConsumptionData(
    # Input fields for requesting consumption data.
    input: RequestConsumptionDataInput!
  ): RequestConsumptionData

  # Replace an existing Communications Hub with a new one and move existing devices to the new Hub.
  replaceCommsHub(
    # Input fields for replacing a Communications Hub.
    input: ReplaceCommsHubInput!
  ): ReplaceCommsHub

  # Triggers an asynchronous request to check the connection of a device. The request reference is returned, which can be used to track the status of the request.
  checkDeviceConnection(
    # Input field for checking device connection.
    input: CheckDeviceConnectionInput!
  ): CheckDeviceConnection

  # Add details to an existing occupier account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-6622: Account not found.
  # - KT-GB-6623: Property not found.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  occupy(input: OccupyInput!): OccupyOutputType

  # Perform a move out of a property for an account.
  #
  # Optionally provide details of the new tenant and a property to perform a move in to.
  #
  #
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-6624: An error occurred when trying to process this house move.
  # - KT-GB-6625: An error occurred when trying to process this house move.
  # - KT-GB-6626: There was an error processing the PSR data.
  # - KT-GB-6627: There are missing agent appointments.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  performMoveOut(input: MoveOutInput!): PerformMoveOut

  # Create a shell/payment account.
  createShellAccount(input: CreateShellAccountInput!): CreateShellAccountPayload

  # Update account communication delivery preference.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4123: Unauthorized.
  # - KT-CT-4136: Cannot set comms preference to email when account has no email.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateCommsDeliveryPreference(
    # Input fields for updating comms delivery preferences for an account
    input: UpdateCommsDeliveryPreferenceInput!
  ): UpdateCommsDeliveryPreference

  # Update account billing email.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4123: Unauthorized.
  # - KT-CT-4122: Invalid email.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateAccountBillingEmail(
    # Input fields for updating billing email for an account.
    input: UpdateAccountBillingEmailInput!
  ): UpdateAccountBillingEmail

  # The possible errors that can be raised are:
  #
  # - KT-CT-4123: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  addCampaignToAccount(
    # Input variables needed for adding a campaign to an account.
    input: AddCampaignToAccountInput!
  ): AddCampaignToAccount

  # Update the account billing address.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4145: Invalid address.
  # - KT-CT-7123: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateAccountBillingAddress(
    # Input variables needed for updating an account billing address.
    input: AccountBillingAddressInput!
  ): UpdateAccountBillingAddress

  # Add a note to an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4123: Unauthorized.
  # - KT-CT-4180: Account note must be a valid string.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createAccountNote(
    # Input variables needed for adding a note to an account.
    input: CreateAccountNoteInput!
  ): CreateAccountNote

  # Renew agreements for an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4125: Invalid data.
  # - KT-GB-4111: Unable to renew agreements for tariff renewal.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  renewAgreements(input: RenewAgreementsInput): RenewAgreements

  # Renew agreement for a meter point.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4112: Unable to renew agreements for meter point at this time. Please try again later.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  renewAgreementForMeterPoint(
    input: RenewAgreementForMeterPointInput!
  ): RenewAgreementForMeterPoint

  # Renew a list of agreements for an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4113: At least one list of agreements to renew is required.
  # - KT-GB-4126: Electricity and gas agreement input is invalid.
  # - KT-GB-4114: Unable to renew agreements.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  renewAgreementsForAccount(
    input: RenewAgreementsForAccountInput
  ): RenewAgreementsForAccount

  # Set stated interest in procuring a smart meter for an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4115: Could not create smart meter interest for account.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  smets2Interest(
    input: UpdateAccountSmartMeterInterestInput
  ): UpdateAccountSmartMeterInterest

  # Start smart onboarding process for an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4102: Unable to start smart onboarding process.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  startOnboardingProcess(
    input: StartSmartOnboardingProcessInput
  ): StartSmartOnboardingProcess

  # Start export onboarding process for an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4103: Unable to start export onboarding process.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  startExportOnboardingProcess(
    input: StartExportOnboardingProcessInput
  ): StartExportOnboardingProcess

  # Update SSD.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4101: Unable to update SSD for account.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateSsd(input: UpdateSsdInput): UpdateSsd

  # Create a Siteworks event.
  createSiteworksEvent(
    # Input fields for creating a new Siteworks event.
    input: CreateSiteworksEventInput!
  ): CreateSiteworksEvent

  # Allow external parties to create a Siteworks event.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4222: The provided 'siteworksRequestId' is not a valid UUID.
  # - KT-GB-4223: Siteworks request not found. Check the provided 'siteworksRequestId' is correct.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createSiteworksEventExternal(
    # Input fields for creating a new Siteworks event.
    input: CreateSiteworksEventInput!
  ): CreateSiteworksEventExternal

  # Create or update a Siteworks appointment.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1112: 'Authorization' header not provided.
  # - KT-CT-4231: Unauthorized.
  # - KT-GB-4230: Invalid data.
  # - KT-GB-4224: Error processing siteworks appointment.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createOrUpdateSiteworksAppointment(
    # Input fields for creating or updating siteworks appointments.
    input: CreateOrUpdateSiteworksAppointmentInput!
  ): CreateOrUpdateSiteworksAppointment

  # Cancel a Siteworks appointment.
  cancelSiteworksAppointment(
    # Input fields for cancelling a siteworks appointment.
    input: CancelSiteworksAppointmentInput!
  ): CancelSiteworksAppointment

  # Confirm an appointment slot returned by the appointment slots query.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4219: Property does not exist.
  # - KT-GB-4220: No account currently active at property.
  # - KT-GB-4221: Could not confirm duplicate property.
  # - KT-GB-4228: Cannot currently book appointments for legacy prepay meters.
  # - KT-GB-4229: A smart meter exchange appointment for this date already exists.
  # - KT-GB-4210: Bookings not supported for agent appointed at property.
  # - KT-GB-4211: Timeslot no longer available.
  # - KT-GB-4212: Missing or invalid data for account or property.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  confirmSiteworksAppointmentSlot(
    # Input fields for booking a siteworks appointment slot
    input: ConfirmSiteworksAppointmentSlotInput!
  ): ConfirmSiteworksAppointmentSlot

  # Report details, readings and balances of meters removed during install.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4213: Application not found.
  # - KT-GB-4231: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  reportRemovedMeterDetails(
    # Input fields for removed meter details.
    input: ReportRemovedMeterDetailsInput!
  ): ReportRemovedMeterDetails

  # Update or create special circumstances for the user, which may entitle them to specialist services
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-5411: Failed to update special circumstance record.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateSpecialCircumstances(
    input: UpdateSpecialCircumstancesInput!
  ): UpdateSpecialCircumstances

  # **DEPRECATED: Please use updatePaymentSchedulePaymentDay instead**
  #
  # Update monthly Direct Debit payment day
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  directDebitPaymentDayUpdate(
    input: DirectDebitPaymentDayUpdateInput!
  ): DirectDebitPaymentDayUpdate
    @deprecated(
      reason: "The 'directDebitPaymentDayUpdate' field is deprecated.\n\n\nPlease use the 'updatePaymentSchedulePaymentDay' mutation instead.\n\n\n- Marked as deprecated on 2020-10-02.\n- Will be removed on 2023-04-06."
    )

  # Update monthly Direct Debit payment day. Permitted values: 1-28. Not available for business accounts
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-3918: Account not found.
  # - KT-GB-3910: This feature is not available to business accounts.
  # - KT-GB-3911: Your payment day cannot be changed at this time.
  # - KT-GB-3912: Unable to update payment day.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  updatePaymentSchedulePaymentDay(
    input: UpdatePaymentSchedulePaymentDayInput!
  ): UpdatePaymentSchedulePaymentDay

  # Update monthly Direct Debit payment amount. Enter amount in pence
  #
  # Lower limit: 100p (£1), Upper limit: 100,000p (£1,000)
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-3919: Invalid payment schedule amount.
  # - KT-GB-3920: Cannot update payment schedule amount.
  # - KT-CT-3923: Unauthorized.
  # - KT-CT-3941: Invalid data.
  # - KT-CT-3942: An unexpected error occurred.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updatePaymentSchedulePaymentAmount(
    input: UpdatePaymentSchedulePaymentAmountInput!
  ): UpdatePaymentSchedulePaymentAmount

  # Create new direct debit instruction
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3940: Invalid data.
  # - KT-CT-3923: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createDirectDebitInstruction(
    # Input fields for creating a new direct debit instruction.
    input: CreateDirectDebitInstructionInput!
  ): CreateDirectDebitInstruction

  # Create a monthly payment schedule for a fixed amount.
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-3917: No statement in last 60 days.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  createPaymentSchedule(input: PaymentScheduleInput!): CreatePaymentSchedule

  # Create warm home discount application with given qualifying requirements and account.
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  createWarmHomeDiscountApplication(
    accountNumber: String
    applicationInputs: WarmHomeDiscountApplicationInputType
  ): WarmHomeDiscountApplicationOutputType

  # Create electricity meter reading(s) with the given value(s) for the given meter(s).
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  createElectricityMeterReading(
    mpan: String
    readAt: Date
    readings: [ReadingInputType]
    serialNumber: String
  ): CreateMeterReadingOutputType

  # Create gas meter reading with the given value for the given meter.
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  createGasMeterReading(
    mprn: String
    readAt: Date
    reading: Int
    serialNumber: String
  ): CreateMeterReadingOutputType

  # Amend unbilled electricity readings.
  amendUnbilledElectricityReading(
    # Input fields for amending unbilled electricity reading.
    input: AmendUnbilledReadingInput!
  ): AmendUnbilledElectricityReading

  # Create a new auto top-up config for SPAYG meter.
  createAutoTopupConfig(
    # Input fields for creating an auto top-up config.
    input: CreateAutoTopupConfigInput!
  ): CreateAutoTopupConfig

  # Disable auto top-up for SPAYG meter.
  disableAutoTopup(
    # Input fields for disabling auto top-up.
    input: DisableAutoTopupInput!
  ): DisableAutoTopup

  # Create a quote for the given set of meter points for the supplied consumption.
  createQuote(input: CreateQuoteInput!): CreateQuoteOutputType

  # Refresh quote with updated products for a quote code.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4612: Unable to refresh quote - quote not found.
  # - KT-GB-4613: Error generating quote.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  refreshQuote(input: RefreshQuoteInput!): RefreshQuote

  # Requote for an account property.
  requote(input: RequoteInput!): Requote

  # Bill to latest smart meter snapshot.
  billToLatestSmartMeterSnapshot(
    # Input fields for billing to latest smart meter snapshot.
    input: BillToLatestSmartMeterSnapshotInput!
  ): BillToLatestSmartMeterSnapshot

  # Switch the specified meter points to the chosen product.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-4116: Invalid data.
  # - KT-GB-4617: Quoted product not found.
  # - KT-CT-4623: Unauthorized.
  # - KT-GB-4117: Unable to process product switch.
  # - KT-GB-4119: Meter point already on another account.
  # - KT-GB-4120: MPxN has no active agreement.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  switchMeterPointProducts(
    input: SwitchMeterPointProductsInput
  ): SwitchMeterPointProducts

  # Add a charge for Electric Juice.
  createElectricJuiceCharge(
    # Input fields for creating an account charge.
    input: CreateElectricJuiceChargeInput!
  ): CreateElectricJuiceCharge

  # Add a credit for Electric Juice
  createElectricJuiceCredit(
    # Input fields for creating an Electric Juice credit.
    input: CreateElectricJuiceCreditInput!
  ): CreateElectricJuiceCredit

  # Store a new card instruction for Electric Juice from an embedded form.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3923: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  storeElectricJuicePaymentInstruction(
    # Input fields for storing a new card instruction from an embedded form.
    input: StoreElectricJuicePaymentInstructionInput!
  ): StoreElectricJuicePaymentInstruction

  # Create an Electric Juice agreement for an account.
  createElectricJuiceAgreement(
    # Input fields for creating an Electric Juice agreement for an account.
    input: CreateElectricJuiceAgreementInput!
  ): CreateElectricJuiceAgreement

  # Create an Electric Juice charge card for an account.
  createElectricJuiceChargeCard(
    # Input fields for creating an Electric Juice charge card.
    input: CreateElectricJuiceChargeCardInput!
  ): CreateElectricJuiceChargeCard

  # Post a charge for an EV public charging session.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5813: Invalid data.
  # - KT-CT-5814: Invalid data.
  # - KT-CT-5815: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  postEvPublicChargingCharge(
    # Input fields for initiating a standalone payment.
    input: PostEVPublicChargingChargeInput!
  ): PostEVPublicChargingCharge

  # Post an EV Public Charging credit.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5816: Invalid data.
  # - KT-CT-5817: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  postEvPublicChargingCredit(
    # Input fields for creating a credit.
    input: PostEVPublicChargingCreditInput!
  ): PostEVPublicChargingCredit

  # Create EV public charging agreement.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4123: Unauthorized.
  # - KT-CT-5811: Active agreement already exists.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createEvPublicChargingAgreement(
    # Input fields for creating an agreement.
    input: CreateEvPublicChargingAgreementInput!
  ): CreateEvPublicChargingAgreement

  # Add EV public charging token.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5817: Invalid data.
  # - KT-CT-5812: Token with this value already exists within this period.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  addEvPublicChargingToken(
    # Input fields for adding a token.
    input: AddEvPublicChargingTokenInput!
  ): AddEvPublicChargingToken

  # Expire EV Public charging token.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5817: Invalid data.
  # - KT-CT-5818: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  expireEvPublicChargingToken(
    # Input fields for expiring a token.
    input: ExpireEvPublicChargingTokenInput!
  ): ExpireEvPublicChargingToken

  # Create a new heat pump goods quote.
  createHeatPumpGoodsQuote(
    input: CreateHeatPumpGoodsQuoteInput
  ): CreateHeatPumpGoodsQuote

  # Provide username and password to receive a token. The token should be used as the `Authorization` header for any authenticated requests.
  emailAuthentication(email: String!, password: String!): EmailAuthentication
    @deprecated(
      reason: "The 'emailAuthentication' field is deprecated.\n\nPlease use obtainKrakenToken instead of this mutation.\n\n- Marked as deprecated on 2021-09-03.\n- Will be removed on 2024-01-01."
    )

  # You probably want email authentication instead of this. Provide user's API Key to receive a token. The token should be used as the `Authorization` header for any authenticated requests. This form of authentication is used when the interface in question already has the API Key and it would be inappropriate to show the user a login screen.
  apiKeyAuthentication(apiKey: String!): APIKeyAuthentication
    @deprecated(
      reason: "The 'apiKeyAuthentication' field is deprecated.\n\nPlease use obtainKrakenToken instead of this mutation.\n\n- Marked as deprecated on 2021-09-03.\n- Will be removed on 2024-01-01."
    )

  # Deactivate the auth token used to authenticate the current request.
  disableToken: DisableToken
    @deprecated(
      reason: "The 'disableToken' field is deprecated.\n\nPlease use obtainKrakenToken instead of this mutation.\n\n- Marked as deprecated on 2024-05-23.\n- Will be removed on 2024-06-30."
    )

  # Submit meter readings for any FIT installations associated with a particular account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-6812: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  fitCreateMeterReadings(input: FitMeterReadingInput!): FitCreateMeterReadings

  # Accept a FIT schedule for a particular account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-6813: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  fitAcceptSchedule(input: FitAcceptScheduleInput!): FitAcceptSchedule

  # Create a quote for a campaign offer.
  quoteCampaignOffer(input: QuoteCampaignOfferInput): QuoteCampaignOffer

  # Replace an agreement for an account with a new product.
  replaceAgreement(input: ReplaceAgreementInput): ReplaceAgreement

  # Generate PAN for a smart prepay meter
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  generatePaymentAllocationNumber(
    # Identifies the meter to generate a PAN for.
    input: SmartMeterDeviceInput!
  ): GeneratePaymentAllocationNumber

  # Create a temporary provisioning cert in krakenflex
  createTempProvisioningClaim: CreateProvisioningClaim

  # Redeem the maximum possible number of OctoPoints as account credit
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-GB-5011: Not enough OctoPoints for redemption.
  # - KT-GB-5010: Error redeeming OctoPoints.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  redeemOctoPointsForAccountCredit(
    # Input fields for redeeming OctoPoints.
    input: RedeemOctoPointsInput!
  ): RedeemOctoPointsForAccountCredit
    @deprecated(
      reason: "The 'redeemOctoPointsForAccountCredit' field is deprecated.\n\nPlease use the RedeemLoyaltyPointsForAccountCredit mutation instead\n\n- Marked as deprecated on 2024-02-06.\n- Will be removed on 2024-05-06."
    )

  # Creates a new Snap for the given account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-9316: Account is not Octoplus-enrolled.
  # - KT-GB-9325: Invalid constantine slug.
  # - KT-GB-9326: Invalid spawn ID.
  # - KT-GB-9319: This feature is not currently available.
  # - KT-GB-9327: Snap failed to create.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  createSnap(
    # The account number to attach the snap to.
    accountNumber: String!

    # The unique identifier for the constantine.
    spawnId: String!
  ): CreateSnap

  # Enrolls an account in the Octoplus campaign.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-GB-9310: Account ineligible for joining Octoplus.
  # - KT-GB-9311: Error joining campaign.
  # - KT-GB-9312: Account already signed up to Octoplus.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  joinOctoplusCampaign(
    # Kraken account number.
    accountNumber: String

    # Options to enrol the account in Saving Sessions after joining Octoplus.
    savingSessionsEnrolmentOptions: SavingSessionsEnrolmentOptions
  ): JoinOctoplusCampaign

  # Claim a Shoptopus Voucher using Octopoints.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  # - KT-GB-9313: Not enough Octopoints.
  # - KT-GB-9314: Reward could not be processed.
  # - KT-GB-9315: Reward of this type unavailable.
  # - KT-GB-9316: Account is not Octoplus-enrolled.
  # - KT-GB-9319: This feature is not currently available.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  claimShoptopusVoucher(
    # The account number for the Octoplus-enrolled account
    accountNumber: String!

    # The number of Octopoints to exchange for a reward.
    points: Int!
  ): ClaimShoptopusVoucher

  # Claim an Octoplus Reward.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  # - KT-GB-9313: Not enough Octopoints.
  # - KT-GB-9314: Reward could not be processed.
  # - KT-GB-9315: Reward of this type unavailable.
  # - KT-GB-9316: Account is not Octoplus-enrolled.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  claimOctoplusReward(
    # The account number for the Octoplus-enrolled account
    accountNumber: String!

    # The unique string identifier for the offer to be claimed.
    offerSlug: String!
  ): ClaimOctoplusReward

  # Create a link to the customer contact form for this account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  # - KT-GB-9319: This feature is not currently available.
  # - KT-GB-9323: Could not create contact link.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createOctoplusRewardContactLink(
    # The account number for the Octoplus-enrolled account
    accountNumber: String!
  ): CreateOctoplusRewardContactLink

  # Accept the terms and conditions.
  acceptTermsAndConditions(
    # Input fields for accepting terms and conditions
    input: AcceptTermsAndConditionsInput!
  ): AcceptTermsAndConditions

  # Sign account up to Saving Sessions campaign.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-GB-5110: Campaign not found.
  # - KT-GB-5111: Meter point not found.
  # - KT-GB-5112: Error joining campaign.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  joinSavingSessionsCampaign(
    # Input fields for joining the Saving Sessions campaign.
    input: JoinSavingSessionsCampaignInput!
  ): JoinSavingSessionsCampaign

  # Opt account in to a Saving Sessions event.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-GB-5114: Saving Sessions event not found.
  # - KT-GB-5116: Account is not part of a Saving Sessions campaign.
  # - KT-GB-5117: Account ineligible to join Saving Sessions event.
  # - KT-GB-5115: Error joining event.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  joinSavingSessionsEvent(
    # Input fields for joining a Saving Sessions event.
    input: JoinSavingSessionsEventInput!
  ): JoinSavingSessionsEvent

  # Orders a blanket to be delivered to the account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-6013: Account is not eligible to order a blanket.
  # - KT-GB-6014: An error occurred placing the order.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  orderBlanket(
    # The account number to send the blanket to.
    accountNumber: String
  ): OrderBlanket

  # Assign discount code to account and account user if available and eligible. A confirmation email will be sent to the user with the discount code.
  #
  # The possible errors that can be raised are:
  #
  # - KT-GB-5911: We have assigned all electric blanket discount codes.
  # - KT-GB-5912: Account already has a discount code assigned.
  # - KT-GB-5913: An error occurred assigning a discount code.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  assignDiscountCode(
    # The account number to assign the code to.
    accountNumber: String
  ): AssignDiscountCode

  # De-authenticate a device.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-4350: Unable to de-authenticate device.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  deauthenticateDevice(input: DeAuthenticationInput): DeauthenticateDevice

  # Register a device (EV, battery or heat pump) for smart control.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4324: Device already registered error.
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-4312: Unable to register device.
  # - KT-CT-4363: No capable devices found.
  # - KT-CT-4364: Multiple devices found.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  deviceRegistration(input: DeviceRegistrationInput): DeviceRegistration

  # Completes the registration of a device if the contract is eligible and the device registration valid.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-4322: Unable to complete registration error.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  thirdPartyCompleteDeviceRegistration(
    input: CompleteDeviceRegistrationInput
  ): ThirdPartyCompleteDeviceRegistration

  # Create a wizard for onboarding a device with SmartFlex.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  startSmartFlexOnboarding(
    input: StartSmartFlexOnboardingInput!
  ): StartSmartFlexOnboarding

  # Cancel onboarding of a device with SmartFlex.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4371: Onboarding wizard ID is invalid.
  # - KT-CT-4372: Simultaneous attempts to update onboarding process.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  cancelSmartFlexOnboarding(
    input: CancelSmartFlexOnboardingInput!
  ): CancelSmartFlexOnboarding

  # Suspends or resumes the smart control of a specific device.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4358: Unable to suspend device control.
  # - KT-CT-4359: Unable to resume device control.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  updateDeviceSmartControl(
    # The input to action the desired device control, i.e. suspend or unsuspend a device.
    input: SmartControlInput!
  ): SmartFlexDeviceInterface

  # Register a device for an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4335: Another device registration is already in progress.
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-4314: Unable to get provider details.
  # - KT-CT-4351: Provider authentication error.
  # - KT-CT-4312: Unable to register device.
  # - KT-CT-4363: No capable devices found.
  # - KT-CT-4364: Multiple devices found.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  registerDevice(input: RegisterDeviceInput): RegisterDevice
    @deprecated(
      reason: "The 'registerDevice' field is deprecated.\n\nPlease use `DeviceRegistration` instead of this endpoint.\n\n- Marked as deprecated on 2024-01-08.\n- Will be removed on 2024-07-01."
    )

  # Delete connection details for a device.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-4352: Unable to delete connection details.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  deleteDeviceConnectionDetails(
    input: AccountNumberInput
  ): DeleteDeviceConnectionDetails
    @deprecated(
      reason: "The 'deleteDeviceConnectionDetails' field is deprecated.\n\nPlease use `DeauthenticateDevice` instead of this endpoint.\n\n- Marked as deprecated on 2023-08-11.\n- Will be removed on 2024-01-01."
    )

  # Reauthenticate an already registered device.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4313: Could not find KrakenFlex device.
  # - KT-CT-4314: Unable to get provider details.
  # - KT-CT-4315: Unable to re-authenticate device.
  # - KT-CT-4363: No capable devices found.
  # - KT-CT-4364: Multiple devices found.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  reauthenticateDevice(input: ReauthenticateDeviceInput): ReauthenticateDevice
    @deprecated(
      reason: "The 'reauthenticateDevice' field is deprecated.\n\nThis is no longer a supported operation. Please deauthenticate and then re-register the device instead.\n\n- Marked as deprecated on 2024-07-22.\n- Will be removed on 2024-12-01."
    )

  # Set charging preferences for your electric vehicle.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-4353: An error occurred while trying to update your charging preferences.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  setVehicleChargePreferences(
    input: VehicleChargingPreferencesInput
  ): SetVehicleChargingPreferences

  # Initiate a test charge of an electric vehicle (EV).
  #
  # This is to ensure that the EV or EVSE (charge point) can be controlled remotely and successfully charged for a
  # short period.
  #
  # If it is not possible to initiate a test charge, a KT-CT-4355 error will be returned. It may have a
  # `testChargeRefusalReasons` extension which lists the reasons why the test charge was refused. Possible reasons
  # include:
  #
  # - `TC_DEVICE_LIVE` (device is already live)
  # - `TC_DEVICE_ONBOARDING_IN_PROGRESS` (test dispatch already in progress)
  # - `TC_DEVICE_RETIRED` (device is retired)
  # - `TC_DEVICE_SUSPENDED` (device is suspended)
  # - `TC_DEVICE_DISCONNECTED` (device is disconnected)
  # - `TC_DEVICE_AWAY_FROM_HOME` (device is away from home)
  # - `TC_DEVICE_NO_LOCATION_CONFIGURED` (device has no location configured)
  # - `TC_DEVICE_LOCATION_UNABLE_TO_IDENTIFY` (unable to identify device location)
  # - `TC_DEVICE_LOCATION_MISSING` (device location is missing)
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-4355: Unable to trigger charge.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  triggerTestCharge(input: AccountNumberInput): PerformTestCharge

  # Initiate a boost charge for an electric vehicle (EV).
  #
  # This will start charging the EV and will not stop until the battery reaches 100% charged.
  #
  # If it is not possible to initiate a boost charge, a KT-CT-4357 error will be returned.
  # It may have a `boostChargeRefusalReasons` extension which lists the reasons why the boost
  # charge was refused. Possible reasons include:
  #
  # - `BC_DEVICE_NOT_YET_LIVE` (device is not yet live)
  # - `BC_DEVICE_RETIRED` (device is retired)
  # - `BC_DEVICE_SUSPENDED` (device is suspended)
  # - `BC_DEVICE_DISCONNECTED` (device is disconnected)
  # - `BC_DEVICE_NOT_AT_HOME` (device is not at home)
  # - `BC_BOOST_CHARGE_IN_PROGRESS` (boost charge already in progress)
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4356: A boost charge cannot currently be performed.
  # - KT-CT-4357: Unable to trigger boost charge.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  triggerBoostCharge(input: AccountNumberInput): PerformBoostCharge

  # Stop any active boost charging.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-4354: Unable to cancel boost charge.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  deleteBoostCharge(input: DeleteBoostChargeInput): DeleteBoostCharge

  # Suspend control of the device.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-4358: Unable to suspend device control.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  suspendControl(input: AccountNumberInput): SuspendDeviceControl

  # Resume control of the device.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-4359: Unable to resume device control.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  resumeControl(input: AccountNumberInput): ResumeDeviceControl

  # Trigger OCPP authentication.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-4310: Unable to register OCPP authentication details.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  ocppAuthentication(input: OCPPAuthenticationInput): OCPPAuthentication

  # Turn a hot water device on or off.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4329: Invalid data.
  # - KT-CT-4346: Unable to set the room temperature.
  # - KT-CT-7223: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  setRoomTemperature(input: RoomTemperatureInput): SetRoomTemperature

  # Turn a hot water device on or off.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4336: Unable to set hot water state.
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  setHotWaterState(input: HotWaterStateInput): SetHotWaterState

  # Turn a hot water device on or off.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4337: Unable to set climate control state.
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  setClimateControlState(
    input: ClimateControlStateInput
  ): SetClimateControlState

  # Register a heat pump for an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4316: Unable to get provider details.
  # - KT-CT-4317: Unable to register device.
  # - KT-CT-4330: Invalid data.
  # - KT-CT-4331: Invalid data.
  # - KT-CT-4335: Another device registration is already in progress.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  registerHeatPump(input: RegisterHeatPumpInput): RegisterHeatPump
    @deprecated(
      reason: "The 'registerHeatPump' field is deprecated.\n\nPlease use `DeviceRegistration` instead of this endpoint.\n\n- Marked as deprecated on 2024-01-08.\n- Will be removed on 2024-07-01."
    )

  # Request a certificate to provision a heating controller.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4332: Invalid data.
  # - KT-CT-4304: Error in preprovisioning step for Octopus Heat Pump.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  requestProvisioningClaimCertificate(
    accountNumber: String!

    # The primary key of a property you would like to associate with this controller.
    propertyId: ID

    # Parameters requested by the app from the controller, required for Kraken Flex to authenticate the device.
    requestParameters: ProvisioningClaimRequestParameters!
  ): RequestProvisioningClaimCertificate

  # Request a certificate to provision a heating controller.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4332: Invalid data.
  # - KT-CT-4304: Error in preprovisioning step for Octopus Heat Pump.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpRequestProvisioningClaimCertificate(
    accountNumber: String!

    # The primary key of a property you would like to associate with this controller.
    propertyId: ID

    # Parameters requested by the app from the controller, required for Kraken Flex to authenticate the device.
    requestParameters: ProvisioningClaimRequestParameters!
  ): RequestProvisioningClaimCertificate

  # Turn a specific heating controller zone ON/OFF, set it to AUTO mode or give it a BOOST.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4333: Invalid data.
  # - KT-CT-4306: Error setting mode for heat pump controller zone.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  setZoneMode(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The parameters required to instruct a specific zone operation.
    operationParameters: SetZoneModeParameters!
  ): SetZoneMode

  # Turn a specific heating controller zone ON/OFF, set it to AUTO mode or give it a BOOST.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4333: Invalid data.
  # - KT-CT-4306: Error setting mode for heat pump controller zone.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpSetZoneMode(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The parameters required to instruct a specific zone operation.
    operationParameters: SetZoneModeParameters!
  ): SetZoneMode

  # De-provision a heating controller device.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4307: Error deprovisioning an Octopus heat pump.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  deprovisionHeatingController(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!
  ): DeprovisionHeatingController

  # De-provision a heating controller device.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4307: Error deprovisioning an Octopus heat pump.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpDeprovisionHeatingController(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!
  ): DeprovisionHeatingController

  # Add schedules for a heating controller zone.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4334: Invalid data.
  # - KT-CT-4308: Error setting schedule(s) for heat pump controller zone.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  setZoneSchedules(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The parameters required to add schedule(s) for a specific zone.
    zoneScheduleParameters: SetZoneSchedulesParameters!
  ): SetZoneSchedules

  # Add schedules for a heating controller zone.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4334: Invalid data.
  # - KT-CT-4308: Error setting schedule(s) for heat pump controller zone.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpSetZoneSchedules(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The parameters required to add schedule(s) for a specific zone.
    zoneScheduleParameters: SetZoneSchedulesParameters!
  ): SetZoneSchedules

  # Remove a sensor from a heating controller device.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4309: Error trying to remove sensor from heat pump controller.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  removeSensor(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The sensor ID of heat pump controller's sensor to be removed.
    sensorId: String!
  ): RemoveSensor

  # Remove a sensor from a heating controller device.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4309: Error trying to remove sensor from heat pump controller.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpRemoveSensor(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The sensor ID of heat pump controller's sensor to be removed.
    sensorId: String!
  ): RemoveSensor

  # Update the display name of a sensor.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  updateSensorDisplayName(
    # The account number.
    accountNumber: String!

    # The new display name.
    displayName: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The code of the sensor to rename (such as 'SENSOR01').
    sensorCode: String!
  ): UpdateSensorDisplayName

  # Update the display name of a sensor.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpUpdateSensorDisplayName(
    # The account number.
    accountNumber: String!

    # The new display name.
    displayName: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The code of the sensor to rename (such as 'SENSOR01').
    sensorCode: String!
  ): UpdateSensorDisplayName

  # Set the temperature for the hot water.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  updateWaterSetpoint(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The temperature to set the water to.
    setpoint: Int!
  ): UpdateWaterSetpoint

  # Set the temperature for the hot water.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpUpdateWaterSetpoint(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The temperature to set the water to.
    setpoint: Int!
  ): UpdateWaterSetpoint

  # Update the display name of multiple sensors.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  bulkUpdateSensorDisplayName(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # A list of sensor codes and display names to set.
    updates: [SensorDisplayNameUpdate]!
  ): BulkUpdateSensorDisplayName

  # Update the display name of multiple sensors.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpBulkUpdateSensorDisplayName(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # A list of sensor codes and display names to set.
    updates: [SensorDisplayNameUpdate]!
  ): BulkUpdateSensorDisplayName

  # Reboot the given heating controller.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpRebootController(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!
  ): RebootHeatingController

  # Set the primary sensor for a zone.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpSetZonePrimarySensor(
    # The account number.
    accountNumber: String!

    # The EUID of the heat pump controller.
    euid: ID!

    # The parameters required to set a new primary sensor for a zone.
    operationParameters: SetZonePrimarySensorParameters!
  ): SetZonePrimarySensor

  # Update the flow temperature settings for the heat pump.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  octoHeatPumpUpdateFlowTemperatureConfiguration(
    # The EUID of the heat pump controller.
    euid: ID!

    # Flow temperature configuration parameters.
    flowTemperatureInput: FlowTemperatureInput!
  ): UpdateFlowTemperatureConfiguration

  # Set charging preferences for a home battery.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4321: Serializer validation error.
  # - KT-CT-4301: Unable to find device for given account.
  # - KT-CT-4353: An error occurred while trying to update your charging preferences.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  setBatteryChargingPreferences(
    input: BatteryChargingPreferencesInput
  ): SetBatteryChargingPreferences
  createAccountFileAttachment(
    input: CreateAccountFileAttachmentInput!
  ): CreateAccountFileAttachmentPayload!

  # The possible errors that can be raised are:
  #
  # - KT-CT-8710: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  triggerPostUploadOperations(s3Key: String!): TriggerPostUploadOperations!

  # Submit a spin of the Wheel of Fortune for the given account and supply type.
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7011: Terms must be accepted.
  # - KT-CT-7023: Unauthorized.
  # - KT-CT-7010: The account does not have any available submissions.
  # - KT-CT-7012: Wheel of Fortune submission error.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  spinWheelOfFortune(
    # Input fields for creating a Wheel of Fortune submission.
    input: WheelOfFortuneSpinInput!
  ): SpinWheelOfFortune

  # Enroll account up to Fan Club.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-CT-8104: Account already enrolled.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  enrollFanClubAccount(
    # Input fields for joining the Fan Club.
    input: JoinFanClubInput!
  ): EnrollFanClubAccount

  # Send notification of likely Fan Club discount.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-8106: No catchments provided.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  fanClubDiscountNotification(
    # Input fields for sending Fan Club discount notifications.
    input: FanClubDiscountNotificationInput!
  ): FanClubDiscountNotification

  # Send comms for Fan Club sign-ups from non-Octopus customers.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-8107: Invalid eligibility status.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  fanClubNonOctopusCustomerComms(
    # Input fields for sending comms to non-Octopus users.
    input: FanClubNonOctopusCustomerCommsInput!
  ): FanClubNonOctopusCustomerComms

  # Do a product switch for a user.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-4619: Quote with given code not found.
  # - KT-CT-4624: Unable to accept the given product code.
  # - KT-CT-4626: No product selected for the given quote code.
  # - KT-CT-4719: No supply point found for identifier provided.
  # - KT-CT-4922: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  initiateProductSwitch(
    # Instigate a product switch for a specific supply point given a valid product and account number.
    input: InitiateProductSwitchInput!
  ): InitiateProductSwitch

  # Create a lead.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-8901: Unable to create lead.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createNewLead(
    # Input fields for creating a lead.
    input: NewLeadInputType!
  ): CreateNewLead

  # Publish a trigger within the transactional messaging service.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-9901: Invalid trigger type code.
  # - KT-CT-9902: Invalid trigger type params.
  # - KT-CT-9903: Trigger type cannot be published externally.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  publishTransactionalMessagingTrigger(
    # Input fields to publish a transactional messaging trigger.
    input: PublishTransactionalMessagingTriggerInput!
  ): PublishTransactionalMessagingTrigger

  # Create a contribution agreement for an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4123: Unauthorized.
  # - KT-CT-9601: Invalid data.
  # - KT-CT-9602: Unable to create contribution agreement.
  # - KT-CT-9605: Contribution amount cannot be 0 or negative.
  # - KT-CT-9606: Scheme is not accepting contributions at this time.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createContributionAgreement(
    # Input variables needed for creating a contribution agreement on an account.
    input: CreateContributionAgreementInput!
  ): CreateContributionAgreement

  # End a contribution agreement for an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-9603: Unable to find contribution agreement.
  # - KT-CT-4123: Unauthorized.
  # - KT-CT-9604: Unable to end contribution agreement.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  endContributionAgreement(
    # Input variables needed for ending a contribution agreement on an account.
    input: EndContributionAgreementInput!
  ): EndContributionAgreement

  # Redeem the passed number of Loyalty Points as account credit.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-9201: No Loyalty Point ledger found for the user.
  # - KT-CT-9202: Loyalty Points adapter not configured.
  # - KT-CT-9203: No ledger entries for the ledger.
  # - KT-CT-9205: Insufficient Loyalty Points.
  # - KT-CT-9206: Indivisible points.
  # - KT-CT-9204: Negative or zero points set.
  # - KT-CT-9208: Invalid posted at datetime.
  # - KT-CT-9209: Negative Loyalty Points balance.
  # - KT-CT-9210: Unhandled Loyalty Points exception.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  redeemLoyaltyPointsForAccountCredit(
    # Input fields for redeeming Loyalty Points.
    input: RedeemLoyaltyPointsInput!
  ): RedeemLoyaltyPointsForAccountCredit

  # Transfer Loyalty Point from one account user to another.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-9205: Insufficient Loyalty Points.
  # - KT-CT-9204: Negative or zero points set.
  # - KT-CT-9208: Invalid posted at datetime.
  # - KT-CT-9209: Negative Loyalty Points balance.
  # - KT-CT-9210: Unhandled Loyalty Points exception.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  transferLoyaltyPointsBetweenUsers(
    # Input fields for transferring Loyalty Points.
    input: TransferLoyaltyPointsBetweenUsersInput!
  ): TransferLoyaltyPointsBetweenUsers

  # Set the Loyalty Point user for the account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-9210: Unhandled Loyalty Points exception.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  setLoyaltyPointsUser(
    # Input fields for setting the Loyalty Points user.
    input: SetLoyaltyPointsUserInput!
  ): SetLoyaltyPointsUser

  # Create a referral using an email address, personal link or code.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-6723: Unauthorized.
  # - KT-CT-6710: Unable to create referral.
  # - KT-CT-6711: Accounts may not self-refer.
  # - KT-CT-6713: Referring and referred account brands do not match.
  # - KT-CT-6712: Invalid reference.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createReferral(
    # Input fields for creating a referral.
    input: CreateReferralInput!
  ): CreateReferral

  # Redeem the referral claim code from certain referral scheme.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-6723: Unauthorized.
  # - KT-CT-6724: Referral claim code not found.
  # - KT-CT-6725: Referral claim code redeeming error.
  # - KT-CT-6726: Referral claim code has already been redeemed.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  redeemReferralClaimCode(
    # Input fields for redeeming referral code.
    input: RedeemReferralClaimCodeInput!
  ): RedeemReferralClaimCode

  # Mutation to create a new portfolio user role. This will effectively link the user to the portfolio giving them all the permissions enabled for the specific role.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-9403: Received an invalid portfolioId.
  # - KT-CT-9404: Received an invalid accountUserId.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createPortfolioUserRole(
    # Input fields for connecting a user to a portfolio.
    input: CreatePortfolioUserRoleInput
  ): CreatePortfolioUserRole

  # Mutation to create a new Portfolio instance.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-9402: Received an invalid brandCode.
  # - KT-CT-9401: Received an invalid operationsTeamId.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createPortfolio(
    # Input fields for creating a portfolio.
    input: CreatePortfolioInput
  ): CreatePortfolio

  # Close the Open Print Batch if any.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-9010: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  closeOpenPrintBatch: CloseOpenPrintBatch!

  # Mark the print batch as processed.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-9011: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  markPrintBatchAsProcessed(printBatchId: ID!): MarkPrintBatchAsProcessed!

  # Create or update a loyalty card for the given account user.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5412: No account user exists with the given id.
  # - KT-CT-8610: Invalid data.
  # - KT-CT-8611: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createOrUpdateLoyaltyCard(
    # Input fields for creating or updating a loyalty card.
    input: CreateOrUpdateLoyaltyCardInput!
  ): CreateOrUpdateLoyaltyCardMutation

  # Link an account user and line user together.
  linkUserToLine(
    # Input fields to link an account user with LINE.
    input: LinkUserToLineInput!
  ): LinkUserToLineResponse!

  # Unlink an account user and line together.
  unlinkUserFromLine: UnlinkUserFromLineResponse!

  # Instigate a leave supplier process or update an existing process.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-10304: Mutation not enabled in this environment.
  # - KT-CT-4501: Unauthorized.
  # - KT-CT-1602: Serializer validation error.
  # - KT-JP-8801: Supply point not found.
  # - KT-CT-10301: Unable to instigate leave supplier process.
  # - KT-CT-10309: Failed to update leave supplier process - the service is not enabled.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  instigateLeaveSupplier(input: LeaveSupplierInput!): LeaveSupplierInstigated!

  # Cancel a leave supplier process.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-10304: Mutation not enabled in this environment.
  # - KT-CT-10302: Invalid data.
  # - KT-CT-10305: Failed to cancel leave supplier process - market actions are no longer cancellable.
  # - KT-CT-10306: Failed to cancel leave supplier process - the cancellation workflow has not been configured.
  # - KT-CT-10307: Failed to cancel leave supplier process - failed to cancel market actions.
  # - KT-CT-10308: Failed to cancel leave supplier process.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  cancelLeaveSupplier(input: CancelLeaveSupplierInput!): LeaveSupplierCancelled!

  # Prepare account for sign up. Returns the existing account and/or user if matching datafound for the provided input, otherwise creates a new account and account user.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-10303: Mutation not enabled in this environment.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  prepareAccount(input: PrepareAccountInput!): PrepareAccountResult!

  # Create an affiliate link for a new sales agent.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7711: Invalid data.
  # - KT-CT-7713: Invalid data.
  # - KT-CT-7714: Invalid data.
  # - KT-CT-7715: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createAffiliateLink(
    # Input fields for creating an affiliate link for an organisation
    input: CreateAffiliateLinkInputType!
  ): CreateAffiliateLink!

  # Update an existing affiliate link.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7711: Invalid data.
  # - KT-CT-7713: Invalid data.
  # - KT-CT-7714: Invalid data.
  # - KT-CT-7715: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateAffiliateLink(
    # Input fields for Updating an existing affiliate link
    input: UpdateAffiliateLinkInputType!
  ): UpdateAffiliateLink!

  # Create an affiliate organisation.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7716: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createAffiliateOrganisation(
    # Input fields for creating an affiliate organisation
    input: CreateAffiliateOrganisationInputType!
  ): CreateAffiliateOrganisation!

  # Update an existing affiliate organisation.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7717: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateAffiliateOrganisation(
    # Input fields for Updating an existing affiliate organisation
    input: UpdateAffiliateOrganisationInputType!
  ): UpdateAffiliateOrganisation!

  # Create a session for an affiliate link.
  createAffiliateSession(
    # Input fields for creating a session for an affiliate link
    input: CreateAffiliateSessionInputType!
  ): CreateAffiliateSession!

  # Validate user's email address.
  validateEmail(input: ValidateEmailInput!): ValidateEmail

  # Validate user's phone number.
  validatePhone(input: ValidatePhoneNumberInput!): ValidatePhone

  # Look up an event to perform from its event_id, and return the next action to perform.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-8002: No event found.
  # - KT-CT-8003: Event has no execute function.
  # - KT-CT-8004: Error executing event in the backend.
  # - KT-CT-8007: Incorrect or missing parameters for backend screen event.
  # - KT-GB-9310: Account ineligible for joining Octoplus.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  backendScreenEvent(
    # Input fields for performing a backend action.
    input: BackendScreenEventInput!
  ): BackendScreenEvent

  # Create metadata on an object.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-8412: Invalid data.
  # - KT-CT-8414: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createMetadata(
    # Input fields for creating metadata.
    input: MetadataInput!
  ): CreateMetadata

  # Update metadata on an object.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-8413: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateMetadata(
    # Input fields for updating metadata.
    input: MetadataInput!
  ): UpdateMetadata

  # Submit customer feedback.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5514: Unable to submit feedback.
  # - KT-CT-5511: The feedback_id should be provided for feedback source.
  # - KT-CT-5512: The feedback doesn't match the account.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  submitCustomerFeedback(
    input: CustomerFeedbackInputType!
  ): SubmitCustomerFeedback

  # Submit a repayment request.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1132: Unauthorized.
  # - KT-CT-3927: Invalid Amount.
  # - KT-CT-3928: Idempotency key used for another repayment request.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  submitRepaymentRequest(
    # Input fields for requesting a repayment.
    input: RequestRepaymentInputType!
  ): SubmitRepaymentRequest

  # Cancel a repayment or refund request.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4231: Unauthorized.
  # - KT-CT-3930: The repayment or refund request does not exist.
  # - KT-CT-3931: This repayment or refund request cannot be cancelled.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  cancelRepaymentRequest(
    # Input fields for cancelling a repayment request.
    input: CancelRepaymentRequestInputType!
  ): CancelRepaymentRequest

  # Allow a repayment to be submitted.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3944: Account repayment does not exist.
  # - KT-CT-3945: Unable to allow a repayment to be submitted.
  # - KT-CT-3950: The provided reason text is too long.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  allowRepaymentSubmission(
    # Input variable needed for allowing repayment submission.
    input: RepaymentInput!
  ): AllowRepaymentSubmission

  # Block a repayment from being submitted.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3944: Account repayment does not exist.
  # - KT-CT-3946: Unable to block a repayment from being submitted.
  # - KT-CT-3950: The provided reason text is too long.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  blockRepaymentSubmission(
    # Input variable needed for blocking repayment submission.
    input: RepaymentInput!
  ): BlockRepaymentSubmission

  # Approve a repayment.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3934: Repayment request already approved.
  # - KT-CT-3935: Repayment request cannot be paid.
  # - KT-CT-3959: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  approveRepayment(
    # Input fields for approving a repayment.
    input: ApproveRepaymentInput!
  ): ApproveRepayment

  # Collect deposit for the given account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-CT-5711: No collection is required.
  # - KT-CT-5712: Deposit agreement does not exist or has not been accepted.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  collectDeposit(input: CollectDepositInput!): CollectDeposit

  # Record the customer's acceptance of a deposit agreement.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  recordDepositAgreementAccepted(
    input: DepositAgreementInput!
  ): RecordDepositAgreementAccepted

  # Create a new deposit agreement for the account if it needs one.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createDepositAgreement(
    input: CreateDepositAgreementInput!
  ): CreateDepositAgreement

  # Initiate a standalone payment and return the client secret required to complete it.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-CT-3943: Invalid ledger.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  initiateStandalonePayment(
    # Input fields for initiating a standalone payment.
    input: InitiateStandalonePaymentInput!
  ): InitiateStandalonePayment

  # Initiate a standalone payment and return the url where the customer can complete it.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1128: Unauthorized.
  # - KT-CT-3822: Unauthorized.
  # - KT-CT-3943: Invalid ledger.
  # - KT-CT-3957: No collection method provided.
  # - KT-CT-3958: Provide either ledger ID or ledger number.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  initiateHostedStandalonePayment(
    # Input fields for initiating a standalone payment.
    input: InitiateHostedStandalonePaymentInput!
  ): InitiateHostedStandalonePayment

  # Get the client secret needed to create a new payment instruction using an embedded form.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  getEmbeddedSecretForNewPaymentInstruction(
    # Input fields for getting the client secret for an embedded new card payment method form.
    input: GetEmbeddedSecretForNewPaymentInstructionInput!
  ): GetEmbeddedSecretForNewPaymentInstruction

  # Store a new payment instruction created through the embedded process.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4177: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  storePaymentInstruction(
    # Input fields for storing a new payment instruction created through the embedded process.
    input: StorePaymentInstructionInput!
  ): StorePaymentInstruction

  # Get the external URL where the user can set up a payment instruction.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1128: Unauthorized.
  # - KT-CT-3822: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  getHostedUrlForNewPaymentInstruction(
    # Input fields for getting the external URL for setting up a payment instruction.
    input: GetHostedUrlForNewPaymentInstructionInput!
  ): GetHostedUrlForNewPaymentInstruction

  # Invalidate an existing instruction.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3926: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  invalidatePaymentInstruction(
    # Input fields for invalidating a payment instruction from an embedded form.
    input: InvalidatePaymentInstructionInput!
  ): InvalidatePaymentInstruction

  # Set up a new direct debit instruction.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3940: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  setUpDirectDebitInstruction(
    # Input fields for creating a new direct debit instruction
    input: SetUpDirectDebitInstructionInput!
  ): SetUpDirectDebitInstruction

  # Attempt to collect a one-off payment. If an instruction type is provided and there is an existing payment instruction, the payment can be collected immediately. A request to collect a payment at a future date can also be made, in which case the instruction input type is not necessary, but an instruction must exist at the specified collection date for the payment to be collected successfully.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3932: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  collectPayment(
    # Input fields for collecting a payment.
    input: CollectPaymentInput!
  ): CollectPayment

  # Amend an existing payment.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3924: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  amendPayment(
    # Input fields for amending an existing payment.
    input: AmendPaymentInput!
  ): AmendPayment

  # Change the auto top up amount for the payment schedule.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3815: No active payment schedule found for this account.
  # - KT-CT-3941: Invalid data.
  # - KT-CT-3942: An unexpected error occurred.
  # - KT-CT-3947: An unexpected error occurred.
  # - KT-CT-3953: The payment schedule is not a balance triggered schedule.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateAutoTopUpAmount(
    # Input fields for updating the auto-top-up amount for a schedule.
    input: UpdateAutoTopUpAmountInput!
  ): UpdateAutoTopUpAmount

  # Replace an existing payment schedule with a new one that updates either the payment amount or payment day.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-3815: No active payment schedule found for this account.
  # - KT-CT-3822: Unauthorized.
  # - KT-CT-3923: Unauthorized.
  # - KT-CT-3941: Invalid data.
  # - KT-CT-3942: An unexpected error occurred.
  # - KT-CT-3947: An unexpected error occurred.
  # - KT-CT-3960: Invalid value for payment day.
  # - KT-CT-3961: Cannot update plan-associated payment schedule.
  # - KT-CT-3962: No new value provided to update payment schedule.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createAccountPaymentSchedule(
    # Input fields for updating a payment schedule.
    input: CreateAccountPaymentScheduleInput!
  ): CreateAccountPaymentSchedule

  # Cancel an in-flight payment.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3924: Unauthorized.
  # - KT-CT-3954: Payment cancellation failed.
  # - KT-CT-3955: Payment cannot be cancelled.
  # - KT-CT-3956: Temporary error occurred.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  cancelPayment(
    # Input fields for cancelling a pending payment.
    input: CancelPaymentInput!
  ): CancelPayment

  # Refund a cleared payment.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3924: Unauthorized.
  # - KT-CT-3928: Idempotency key used for another repayment request.
  # - KT-CT-3929: The payment is not in a refundable state.
  # - KT-CT-3933: Refund amount greater than payment amount.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  refundPayment(
    # Input fields for refunding a payment.
    input: RefundPaymentInput!
  ): RefundPayment
  assignInkBucket(input: AssignInkBucketInput!): AssignInkBucketPayload
  updateMessageTags(input: UpdateMessageTagsInput!): UpdateMessageTagsPayload

  # Register an Ink inbound message.
  createInkInboundMessage(
    input: CreateInkInboundMessageInput!
  ): CreateInkInboundMessagePayload

  # The possible errors that can be raised are:
  #
  # - KT-CT-7620: Channel not supported.
  # - KT-CT-7618: Unable to process message.
  # - KT-CT-7624: Error when generating the presigned URL.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  generateInkPresignedUrl(
    input: GenerateInkPresignedUrlInput
  ): GenerateInkPresignedUrl

  # Create a goods quote.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-8202: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createGoodsQuote(
    # Input fields for creating a goods quote.
    input: CreateGoodsQuoteInput!
  ): CreateGoodsQuote

  # Create a goods quote without an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-8202: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createGoodsQuoteWithoutAccount(
    # Input fields for creating a goods quote without an existing account.
    input: CreateGoodsQuoteWithoutAccountInput!
  ): CreateGoodsQuoteWithoutAccount

  # Accept a goods quote.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-8223: Unauthorized.
  # - KT-CT-8201: Received an invalid quoteId.
  # - KT-CT-8224: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  acceptGoodsQuote(
    # Input fields for accepting a quote.
    input: AcceptGoodsQuoteInput!
  ): AcceptGoodsQuote

  # Share a goods quote.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4122: Invalid email.
  # - KT-CT-8203: Received an invalid quote code.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  shareGoodsQuote(
    # Input fields for sharing a quote.
    input: ShareGoodsQuoteInput!
  ): ShareGoodsQuote

  # Create a goods purchase.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-8206: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createGoodsPurchase(
    # Input fields for creating a purchase without a quote.
    input: CreatePurchaseInput!
  ): CreateGoodsPurchase

  # Verify user's email address.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  verifyEmail(input: VerifyEmailInput!): VerifyEmail

  # Create an account reminder.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1401: Invalid data.
  # - KT-CT-1402: Unable to create account reminder.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createAccountReminder(
    # Input variables needed for creating an account reminder.
    input: CreateAccountReminderInput!
  ): CreateAccountReminder

  # Create an account reference.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4123: Unauthorized.
  # - KT-CT-8310: Invalid data.
  # - KT-CT-8311: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createAccountReference(
    # Input fields for creating an account reference.
    input: AccountReferenceInput!
  ): CreateAccountReference

  # Update an account reference.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4123: Unauthorized.
  # - KT-CT-8310: Invalid data.
  # - KT-CT-8311: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateAccountReference(
    # Input fields for updating an account reference.
    input: AccountReferenceInput!
  ): UpdateAccountReference

  # Delete an account reference.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4123: Unauthorized.
  # - KT-CT-8310: Invalid data.
  # - KT-CT-8312: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  deleteAccountReference(
    # Input fields for removing an account reference.
    input: DeleteAccountReferenceInput!
  ): DeleteAccountReference

  # Create an external account event.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7123: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createExternalAccountEvent(
    # Input fields for creating an external account event.
    input: CreateExternalAccountEventInput!
  ): CreateExternalAccountEvent

  # Add credit to an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5315: Invalid data.
  # - KT-CT-5314: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createAccountCredit(
    # Input fields for creating an account credit.
    input: CreateAccountCreditInput!
  ): CreateAccountCredit
    @deprecated(
      reason: "The 'createAccountCredit' field is deprecated.\n\nUse postCredit mutation as it is ledger aware.\n\n- Marked as deprecated on 2022-07-04.\n- Will be removed on 2024-01-01."
    )

  # Post credit to a ledger.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5316: Invalid data.
  # - KT-CT-5311: The credit reason with the requested code is deprecated.
  # - KT-CT-5312: The credit reason with the requested code does not exist.
  # - KT-CT-5313: An error occurred whilst posting the credit.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  postCredit(
    # Input fields for posting a credit.
    input: PostCreditInput!
  ): PostCredit

  # Add charge to an account.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5211: The charge reason with the requested code is deprecated.
  # - KT-CT-5212: The charge reason with the requested code does not exist.
  # - KT-CT-5213: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createAccountCharge(
    # Input fields for creating an account charge.
    input: CreateAccountChargeInput!
  ): CreateAccountCharge

  # Transfer value from a source ledger to a destination ledger. This decreases the balance of the source ledger by the given amount and increases the balance of the destination ledger by the same amount. If the amount is negative, the effect is reversed (the source ledger's balance increases and the destination ledger's balance decreases).
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-3822: Unauthorized.
  # - KT-CT-3823: Unauthorized.
  # - KT-CT-9701: Balance transfer to same account is not allowed.
  # - KT-CT-9702: Balance transfer is not support for debit account with Zero balance.
  # - KT-CT-9703: Balance transfer is not supported for debit account.
  # - KT-CT-9704: Balance transfer amount should be non-zero.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  transferLedgerBalance(
    # Input fields for processing an account balance transfer.
    input: TransferLedgerBalanceInputType!
  ): TransferLedgerBalance

  # Create a "form submission" entity. This is only meant to be used as a quick way of putting together a form and submit data for it, in the form of JSON - it is not expected that all form submissions will come through this path.
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  createFormSubmission(input: FormSubmissionInput!): FormSubmissionOuput

  # Provide a temporary token to get an auth token. This is intended to allow support users to view customer data through the brand interface.
  masqueradeAuthentication(
    # The masquerade token issued by the support site.
    masqueradeToken: String!

    # The ID of the AccountUser to masquerade as.
    userId: String!
  ): MasqueradeAuthentication

  # Generate a pre-signed token with a set expiry time.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1128: Unauthorized.
  # - KT-CT-1120: The Kraken Token has expired.
  # - KT-CT-1131: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  generatePreSignedToken(
    email: String!

    # The number of days that the token will be available for authentication (From now on).
    numberOfDaysAllowed: Int!

    # Define (and limit) the scope of the token.
    scope: PreSignedTokenScope!
  ): GeneratePreSignedToken

  # Invalidate a previously-issued pre-signed token.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1129: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  invalidatePreSignedToken(
    input: InvalidatePreSignedTokenInput!
  ): InvalidatePreSignedToken

  # Invalidate pre-signed tokens issued to a particular user.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1129: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  invalidatePreSignedTokensForUser(
    input: InvalidatePreSignedTokensForUserInput!
  ): InvalidatePreSignedTokensForUser

  # Provide the email address of an account user to send them an email with instructions on how to reset their password.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1133: Unable to request password reset email.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  requestPasswordReset(
    # Input fields for requesting a password reset email.
    input: RequestPasswordResetInput!
  ): RequestPasswordResetOutputType

  # Reset the password of an account user indicated by the userId to the value supplied.
  resetPassword(
    input: ResetPasswordMutationInput!
  ): ResetPasswordMutationPayload

  # Reset the password of an account user.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-4125: Unauthorized.
  # - KT-CT-1132: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  resetUserPassword(
    # Input fields for resetting an account user's password.
    input: ResetUserPasswordInput!
  ): ResetUserPasswordOutput

  # Create a Kraken Token (JWT) for authentication.
  #
  # Provide the required input fields to obtain the token.
  #
  # The token should be used as the `Authorization` header for any authenticated requests.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1135: Invalid data.
  # - KT-CT-1134: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  obtainKrakenToken(
    # Input fields that can be used to obtain a Json Web Token (JWT) for authentication to the API.
    input: ObtainJSONWebTokenInput!
  ): ObtainKrakenJSONWebToken

  # Force users of Kraken Tokens and refresh tokens issued to the Query to reauthenticate.
  #
  # Calling this mutation will cause all Kraken Tokens and refresh tokens issued to the authenticated viewer before the mutation was called to become invalid.
  forceReauthentication(
    # Input object argument to the force-reauthentication mutation.
    input: ForceReauthenticationInput!
  ): ForceReauthentication

  # For authorized third-party organizations only.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1120: The Kraken Token has expired.
  # - KT-CT-1121: Please use Kraken Token to issue long-lived refresh tokens.
  # - KT-CT-1132: Unauthorized.
  # - KT-CT-1122: Long-lived refresh tokens can only be issued for account users.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  obtainLongLivedRefreshToken(
    # Input fields for obtaining a long-lived refresh token to extend the expiry claim of a Kraken token.
    input: ObtainLongLivedRefreshTokenInput!
  ): ObtainLongLivedRefreshToken

  # Invalidate a previously-issued refresh token.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1130: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  invalidateRefreshToken(
    input: InvalidateRefreshTokenInput!
  ): InvalidateRefreshToken

  # Invalidate refresh tokens issued to a particular user.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1128: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  invalidateRefreshTokensForUser(
    input: InvalidateRefreshTokensForUserInput!
  ): InvalidateRefreshTokensForUser

  # Provide identifying information about an account and user to get a scoped token that will permit access to associate an email address with the account’s user.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-1145: Account/user details do not match.
  # - KT-CT-1113: Disabled GraphQL field requested.
  #
  verifyIdentity(
    # Details about the user to be verified.
    input: VerifyIdentityInput!
  ): VerifyIdentity

  # Mutation to create a new APIException instance.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7801: Received an invalid operationsTeamId.
  # - KT-CT-7802: The external identifier already exists.
  # - KT-CT-7805: Too many tags associated with this API Exception.
  # - KT-CT-7806: Cannot create duplicate tags for the same API exception.
  # - KT-CT-7811: Received an invalid assignedUserId.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createApiException(
    # Input fields for creating an API exception.
    input: CreateAPIExceptionInput!
  ): CreateAPIException

  # Mutation to update an existing APIException instance.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7804: No fields present in the input for updating the APIException.
  # - KT-CT-7803: Received an invalid apiExceptionId.
  # - KT-CT-7809: Update results in no changes to API Exception.
  # - KT-CT-7805: Too many tags associated with this API Exception.
  # - KT-CT-7806: Cannot create duplicate tags for the same API exception.
  # - KT-CT-7801: Received an invalid operationsTeamId.
  # - KT-CT-7811: Received an invalid assignedUserId.
  # - KT-CT-7812: Support user is inactive.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateApiException(
    # Input fields for updating an API exception.
    input: UpdateAPIExceptionInput!
  ): UpdateAPIException

  # Mutation to create a new APICall instance.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7803: Received an invalid apiExceptionId.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createApiCall(
    # Input fields for creating an API call.
    input: CreateAPICallInput!
  ): CreateAPICall

  # Mutation to create a new APIExceptionEvent instance.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7803: Received an invalid apiExceptionId.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createApiExceptionEvent(
    # Input fields for creating an API exception event.
    input: CreateAPIExceptionEventInput!
  ): CreateAPIExceptionEvent

  # Mutation to create a new APIExceptionNote instance.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7803: Received an invalid apiExceptionId.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  createApiExceptionNote(
    # Input fields for creating an API exception note.
    input: CreateAPIExceptionNoteInput!
  ): CreateAPIExceptionNote

  # Mutation to update an existing APIExceptionNote instance.
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-7807: Received an invalid apiExceptionNoteId.
  # - KT-CT-7808: Unauthorized.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateApiExceptionNote(
    # Input fields for creating an API exception note.
    input: UpdateAPIExceptionNoteInput!
  ): UpdateAPIExceptionNote

  # **DEPRECATED: Please use updateUser instead**
  #
  # Update the account user details of the authenticated user. Only one field can be updated per day. This prevents users from switching accounts to someone else (usually when moving homes) All account changes should be handled by operations or the move out journey. New customers are exempt from this rule for the first 31 days.
  updateUserDetails(
    input: UpdateAccountUserMutationInput!
  ): UpdateAccountUserMutationPayload
    @deprecated(
      reason: "The 'updateUserDetails' field is deprecated.\n\n\nPlease use the 'updateUser' mutation instead.\n\n\n- Marked as deprecated on 2020-10-02.\n- Will be removed on 2023-04-06."
    )

  # Update the comms preferences of the account user (the authenticated user).
  updateCommsPreferences(
    input: UpdateAccountUserCommsPreferencesMutationInput!
  ): UpdateAccountUserCommsPreferencesMutationPayload

  # Update password of the authenticated user.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  updatePassword(input: UpdatePasswordInput): UpdatePassword

  # Regenerate the live secret key for the authenticated user.
  regenerateSecretKey: RegenerateSecretKey

  # Update the account user details of the authenticated user. Only one field can be updated per day. This prevents users from switching accounts to someone else (usually when moving homes) All account changes should be handled by operations or the move out journey. New customers are exempt from this rule for the first 31 days.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5413: Invalid data.
  # - KT-CT-5414: Invalid data.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  updateUser(
    # Input fields for updating user.
    input: UpdateUserInput!
  ): UpdateUserMutation

  # Register a device token to be used for push notifications for an app.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  registerPushNotificationBinding(
    # Input fields for creating an push notification binding.
    input: RegisterPushNotificationBindingInput!
  ): RegisterPushNotificationBinding

  # Delete a device token used for push notifications.
  #
  #
  #
  # This field requires the `Authorization` header to be set.
  #
  #
  #
  # The possible errors that can be raised are:
  #
  # - KT-CT-5411: Invalid token or no push notification binding found for the given account user.
  # - KT-CT-1113: Disabled GraphQL field requested.
  # - KT-CT-1111: Unauthorized.
  # - KT-CT-1112: 'Authorization' header not provided.
  #
  deletePushNotificationBinding(
    # Input fields for deleting a push notification binding.
    input: DeletePushNotificationBindingInput!
  ): DeletePushNotificationBinding
}

# Register an Ink message from OEGB chatbot.
# This mutation has been created specifically designed for the MVP
# It can be removed once a better implementation is found
type CreateInkChatbotMessagePayload {
  # The Ink message that was created.
  message: InkMessage!
  clientMutationId: String
}

input CreateInkChatbotMessageInput {
  #
  # An arbitrary, unique ID for this message.
  #
  # This must be unique for each message that is supplied
  # using the same organisation; collisions between messages
  # provided by different organisations are tolerated.
  #
  # Stored as vendor_id.
  #
  messageId: String!
  newMessage: InkMessageInput!

  #
  # An optional parameter where we can pass the generic message headers if it has one
  #
  # Email channel tries to get the value `conversation-relay-id` from this
  # parameter
  #
  messageHeaders: JSONString

  # When the message occurred in the system of origin.
  occurredAt: DateTime

  #
  # The account related to the message, if there is one.
  #
  # If provided, we will directly route the message to the account's conversation.
  #
  accountNumber: String!
  clientMutationId: String
}

# Calculates and records the deposit amount. returns the deposit amount and key
#
# The possible errors that can be raised are:
#
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CalculateDepositAmount {
  possibleErrors: [PossibleErrorType]

  # Calculated deposit amount
  depositAmount: Int

  # unique key of the record inserted in DepositAmount model
  key: String
}

input CalculateDepositAmountInput {
  # provide the credit score of the business
  creditScore: Int!

  # provide the monthly consumption amount
  monthlyAmount: Int!
}

# The possible errors that can be raised are:
#
# - KT-CT-10701: Unable to fetch company's credit data.
# - KT-CT-10702: Company not found.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CheckBusinessCreditRisk {
  possibleErrors: [PossibleErrorType]

  # PaymentMultiplier to determine deposit amount.
  paymentMultiplier: Int
}

input CheckBusinessCreditRiskInput {
  # Type of the business: LTD, Charity, SoleTrader or Partnership.
  businessType: BusinessTypeEnum!

  # Company registration number. Only needed for LTDs.
  companyNumber: String
}

enum BusinessTypeEnum {
  LTD
  CHARITY
  SOLE_TRADER
  PARTNERSHIP
}

# Create one or more product rates for a product.
#
# The possible errors that can be raised are:
#
# - KT-GB-9514: No available product found.
# - KT-GB-9518: Invalid input data for product rate(s).
# - KT-GB-9519: Unable to create product rate(s).
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateProductRates {
  possibleErrors: [PossibleErrorType]

  # Successfully created rate(s) for the specified product.
  productRates: [ProductRateType]
}

# A single product rate.
type ProductRateType {
  validFrom: DateTime
  validTo: DateTime

  # The band category of the product rate.
  bandCategory: String
  bandSubcategory: String!
  pricePerUnit: Decimal!

  # The gsp of the product rate.
  gsp: String

  # The payment_method of the product rate.
  paymentMethod: String
}

input CreateProductRatesInputType {
  # The product rate(s) to be created.
  productRates: [ProductRateInputType]!
}

# Input type for creating a single product rate.
input ProductRateInputType {
  # Date and time the product rate is effective from.
  validFrom: DateTime!

  # Date and time the product rate is effective to.
  validTo: DateTime

  # The band category of the product rate.
  bandCategory: LimitedBandCategories!

  # The band subcategory of the product rate. For gas products, pass 'null'. For electricity products, select a subcategory.
  bandSubcategory: AllBandSubCategories = null

  # The value of the product rate.
  pricePerUnit: Decimal!

  # The GSP group id of the product rate.
  gsp: GSPGroupIdsOptions!

  # The payment method of the product rate, if applicable.
  paymentMethod: PaymentMethodChoices = null
}

#
#     Set of band categories that are currently
#     supported for creating product rates.
#
enum LimitedBandCategories {
  STANDING_CHARGE
  CONSUMPTION_CHARGE
}

#
#     Combined list of subcategories for both consumption and standing charges
#
enum AllBandSubCategories {
  STANDARD
  ECO7_DAY
  ECO7_NIGHT
  THREE_RATE_PEAK
  THREE_RATE_OFF_PEAK
  THREE_RATE_SHOULDER
  ECONOMY7
  THREE_RATE
}

# An enumeration.
enum GSPGroupIdsOptions {
  _A
  _B
  _C
  _D
  _E
  _F
  _G
  _H
  _J
  _K
  _L
  _M
  _N
  _P
}

type QuoteNewMeterPoints {
  # The generated quote.
  quoteRequest: QuoteRequest
}

input QuoteNewMeterPointsInput {
  # A list of electricity meterpoints to create this quote for.
  electricityMeterPointsInput: [ElectricityMeterPointInput!]

  # A list of gas meterpoints to create this quote for.
  gasMeterPointsInput: [GasMeterPointInput!]

  # Additional context about the future account which is required to create the quote.
  newAccountInput: NewAccountInput!

  # Only quote on products with these tags. If not provided, quote against all available products.
  productTags: [String!]
}

input ElectricityMeterPointInput {
  # Must be provided if no custom consumption input is provided.
  mpan: String

  # Annual consumption values for this meter point. Must be provided if no MPAN is provided.
  consumption: ElectricityConsumptionInput

  # The meter type on this meter point. Must be provided if no MPAN is provided.
  meterType: MeterType

  # The grid supply point ID of this meter point.
  gspId: String

  # Should the meter point be quoted on a flat rate.
  flatRate: Boolean
}

input ElectricityConsumptionInput {
  # Amount of electricity consumed.
  standard: Int

  # Daily electricity consumption.
  day: Int

  # Nightly electricity consumption.
  night: Int

  # Off peak hours electricity consumption.
  offPeak: Int

  # If the consumption values are estimated, set this to 'True'.
  isEstimate: Boolean
}

enum MeterType {
  STANDARD
  ECONOMY7
  SMART
  SMART_ECONOMY7
  SMART_FLAT_ECONOMY7
  FLAT_ECONOMY7
  THREE_RATE
  FLAT_THREE_RATE
}

input GasMeterPointInput {
  # Must be provided if no custom consumption input is provided.
  mprn: String

  # Annual consumption values for this meter point.
  consumption: GasConsumptionInput

  # The grid supply point ID of this meter point.
  gspId: String
}

input GasConsumptionInput {
  # Amount of gas consumed.
  value: Int!

  # If the consumption values are estimated, set this to 'True'.
  isEstimate: Boolean
}

input NewAccountInput {
  # Account type to quote for (e.g. Business or Domestic).
  accountType: AccountTypeChoices!

  # Company brand to quote for.
  brandCode: String!

  # Optional parameter for the payment method to quote for. Defaults to Direct Debit.
  paymentMethod: PaymentMethodChoices

  # Optional ID of the affiliate session active when creating this quote.
  affiliateSessionId: String
}

# The possible errors that can be raised are:
#
# - KT-CT-4616: Unable to create a quote.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type QuoteNewMeterPointsOnBespokeProducts {
  possibleErrors: [PossibleErrorType]

  # The generated quote.
  quoteRequest: QuoteRequest
}

input QuoteNewMeterPointsOnBespokeProductsInput {
  # A list of electricity meterpoints to create this quote for.
  electricityMeterPointsInput: [ElectricityMeterPointProductsInput!]

  # A list of gas meterpoints to create this quote for.
  gasMeterPointsInput: [GasMeterPointProductsInput!]

  # Data for creating a new account.
  newAccountInput: NewAccountInput!
}

input ElectricityMeterPointProductsInput {
  # Must be provided if no custom consumption input is provided.
  mpan: String

  # Annual consumption values for this meter point. Must be provided if no MPAN is provided.
  consumption: ElectricityConsumptionInput

  # The meter type on this meter point. Must be provided if no MPAN is provided.
  meterType: MeterType

  # The grid supply point ID of this meter point.
  gspId: String

  # Should the meter point be quoted on a flat rate.
  flatRate: Boolean

  # A list of products and optional product parameters to quote for.
  productsInput: [ElectricityProductInput!]!
}

input ElectricityProductInput {
  # Code specifying the product to quote for.
  code: String

  # Optional payment method to quote for.
  paymentMethod: PaymentMethodChoices

  # Bespoke rates to override default electricity unit rates.
  bespokeRates: ElectricityBespokeRates
}

input ElectricityBespokeRates {
  # Standard bespoke rate for electricity.
  standard: Decimal

  # Daily bespoke rate for electricity.
  day: Decimal

  # Nightly bespoke rate for electricity.
  night: Decimal

  # Off peak rate for electricity.
  offPeak: Decimal

  # Standing charge for electricity.
  standingCharge: Decimal!
}

input GasMeterPointProductsInput {
  # Must be provided if no custom consumption input is provided.
  mprn: String

  # Annual consumption values for this meter point.
  consumption: GasConsumptionInput

  # The grid supply point ID of this meter point.
  gspId: String

  # A list of products and optional product parameters to quote for.
  productsInput: [GasProductInput!]!
}

input GasProductInput {
  # Code specifying the product to quote for.
  code: String

  # Optional payment method to quote for.
  paymentMethod: PaymentMethodChoices

  # Bespoke rates to override default gas unit rates.
  bespokeRates: GasBespokeRates
}

input GasBespokeRates {
  # Standard bespoke rate for gas.
  value: Decimal!

  # Standing charge for gas.
  standingCharge: Decimal!
}

# The possible errors that can be raised are:
#
# - KT-CT-4616: Unable to create a quote.
# - KT-GB-4614: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type QuoteAccountOnProducts {
  possibleErrors: [PossibleErrorType]

  # The generated quote.
  quoteRequest: QuoteRequest
}

input QuoteAccountOnProductsInput {
  # A list of electricity meterpoints to create this quote for.
  electricityMeterPointsInput: [ElectricityMeterPointProductsInput!]

  # A list of gas meterpoints to create this quote for.
  gasMeterPointsInput: [GasMeterPointProductsInput!]

  # Account number to create this quote for.
  accountNumber: String!

  # Date at which the product switch takes effect. Defaults to today if not provided.
  at: DateTime
}

type CreateRenewalQuoteRequest {
  quoteRequest: QuoteRequest
}

input CreateRenewalQuoteRequestInput {
  # The account number.
  accountNumber: String!

  # The property id to create a quote request for.
  propertyId: Int!

  # The date at which the agreements would be renewed.
  renewalAt: DateTime!
}

# The possible errors that can be raised are:
#
# - KT-GB-4624: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateQuoteRequestForProducts {
  possibleErrors: [PossibleErrorType]

  # Returns a quote request for the requested product codes. Does not persist the quote.
  quoteRequest: QuoteRequestBase
}

type QuoteRequestBase {
  # List of electricity supply points and their quoted products.
  electricitySupplyPoints: [ElectricitySupplyPoint]

  # List of gas supply points and their quoted products.
  gasSupplyPoints: [GasSupplyPoint]
  createdAt: DateTime
}

input CreateQuoteRequestForProductsInput {
  # The account number.
  accountNumber: String!

  # The property id to create a quote request for.
  propertyId: Int!

  # The product codes of products to quote for.
  productCodes: [String]!

  # The date at which the agreements would be renewed.
  renewalAt: DateTime!

  # If the customer is currently on a flat rate tariff, create a flat rate quote.
  persistFlatRate: Boolean

  # Optional parameter to override the payment method on the current agreement.
  paymentMethod: PaymentMethodChoices
}

# The possible errors that can be raised are:
#
# - KT-GB-4625: Unable to create quote request.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type CreateAcquisitionQuoteRequestForProducts {
  possibleErrors: [PossibleErrorType]

  # Returns a quote request for the requested product codes. Does not persist the quote.
  quoteRequest: QuoteRequestBase
}

input CreateAcquisitionQuoteRequestForProductsInput {
  # The electricity meter points to create a quote request for.
  electricityMeterPoints: [ElectricityMeterPointConsumptionInput]

  # The gas meter points to create a quote request for.
  gasMeterPoints: [GasMeterPointConsumptionInput]

  # The postcode of the meter points being quoted.
  postcode: String!

  # The product codes of products to quote for.
  productCodes: [String]!

  # Optional parameter for the payment method to quote for. Defaults to Direct Debit.
  paymentMethod: PaymentMethodChoices = DIRECT_DEBIT
}

input ElectricityMeterPointConsumptionInput {
  profileClass: Int
  mpan: String
  isEstimate: Boolean!
  annualConsumptionStandard: Int
  annualConsumptionDay: Int
  annualConsumptionNight: Int
}

input GasMeterPointConsumptionInput {
  mprn: String
  isEstimate: Boolean!
  annualConsumption: Int
}

# Mutation for creating an refund request for an account.
#
# The possible errors that can be raised are:
#
# - KT-GB-4127: Unable to send refund request confirmation email.
# - KT-GB-4121: Unable to process refund request.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateRefundRequest {
  possibleErrors: [PossibleErrorType]
  refundRequest: RefundRequestType
}

type RefundRequestType {
  # The requested refund amount which was submitted in the repayment.
  requestedAmountToReturn: Int
}

# The input type for the refund request.
input RefundRequestInput {
  # The account number.
  accountNumber: String!

  # The requested refund amount.
  requestedAmount: Int!
}

# Update smart meter data preferences of an account.
#
# The possible errors that can be raised are:
#
# - KT-CT-4023: Unauthorized.
# - KT-GB-4015: Cannot update smart meter reading frequency preferences.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateSmartMeterDataPreferences {
  possibleErrors: [PossibleErrorType]
  preferencesUpdated: Boolean
  smartMeterDataPreferences: SmartMeterDataPreferencesType
}

input UpdateSmartMeterDataPreferencesInput {
  accountNumber: String!

  # The desired reading frequency for the smart meter.
  readingFrequency: SmartMeterReadingFrequencyChoices!

  # The consent that smart meter readings can be used for further analysis
  allowReadingsAnalysis: Boolean
}

# Send a request to the DCC to join a smart device to a HAN (Home Area Network).
#
# The possible errors that can be raised are:
#
# - KT-GB-4019: This device type is not currently supported.
# - KT-GB-4020: Error sending the request to join the device to the Home Area Network.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type JoinDeviceToNetwork {
  possibleErrors: [PossibleErrorType]
  requestReference: String
}

#
#     Types of devices that can be joined to a HAN (Home Area Network).
#
enum JoinableDeviceType {
  # Electricity meter.
  ELECTRICITY_METER

  # Gas meter.
  GAS_METER

  # HAN Connected Auxiliary Load Control Switch (HCALCS).
  AUX_SWITCH

  # Pre-Payment Meter Interface Device.
  PPMID

  # In-Home Display.
  IHD
}

# The possible errors that can be raised are:
#
# - KT-GB-4021: Invalid MPxN.
# - KT-GB-4022: MPxN not recognised.
# - KT-GB-4023: Error sending the request to commission the device.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CommissionMeter {
  possibleErrors: [PossibleErrorType]

  # The id of the SMETS Commission Request in Kraken.
  requestReference: String
}

input CommissionMeterInput {
  mpxn: String

  # Device ID of the CHF (Communications Hub Function).
  chfDeviceId: String!

  # Device ID (ESME or GSME) of the device being commissioned.
  meterDeviceId: String!

  # Code provided by manufacturer as part of ASN data, and included as part of device pre-notification, which is required to authorise device commissioning.
  installationCode: String!

  # Type of meter being commissioned
  meterType: MeterTypeChoices!

  # Serial number for ESME or GSME devices.
  serialNumber: String
}

# An enumeration.
enum MeterTypeChoices {
  # Electricity meter.
  ELECTRICITY_METER

  # Gas meter.
  GAS_METER
}

# The possible errors that can be raised are:
#
# - KT-GB-4024: The provided device ID does not match any devices known by Kraken.
# - KT-GB-4025: Error sending the request to decommission the device.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type DecommissionSmartDevice {
  possibleErrors: [PossibleErrorType]

  # The reference of the Decommission Request in Kraken.
  requestReference: String
}

input DecommissionSmartDeviceInput {
  # Device ID for the device being decommissioned.
  deviceId: String!
}

# A request sent to notify Kraken of a new device, which will be prenotified to the adapter.
type RegisterSmartDevice {
  # The reference for the associated request in Kraken.
  requestReference: String
}

# This type is used by agent services to notify Kraken of a new device.
input RegisterSmartDeviceInput {
  # The ID of the device to register.
  deviceId: String!

  # MPID of the Meter Asset Provider for the device. Used with ESME or GSME devices.
  mapMpid: String

  # Supplier associated with the device.
  supplierMpid: String!

  # The 4-letter manufacturer code for the device.
  deviceManufacturer: String!

  # Model of the device.
  deviceModel: String!

  # Type of the device, e.g. ESME or GSME.
  deviceType: String!

  # SMETS CHTS version number.
  smetsChtsVersion: String

  # Installation code of the device.
  installCode: String!

  # ESME variant for an ESME device.
  esmeVariant: String

  # Serial number for ESME or GSME devices.
  serialNumber: String

  # Firmware version number.
  firmwareVersion: String
}

# Update the status of the communications hub.
#
# The possible errors that can be raised are:
#
# - KT-GB-4026: Either the mpxn or mpan input must be provided.
# - KT-GB-4027: If both mpxn and mpan are provided, they must match.
# - KT-GB-4028: Please input a valid MPxN.
# - KT-GB-4029: Meter point not found for MPAN.
# - KT-GB-4030: Meter point not found for MPRN.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateCommsHubStatus {
  possibleErrors: [PossibleErrorType]

  # The id of the Request object in Kraken.
  requestReference: String
}

input UpdateCommsHubStatusInput {
  # Device ID of the CHF (Communications Hub Function).
  chfDeviceId: String!

  # The type of status update to be sent.
  updateType: CommsHubStatusUpdateType!

  # MPxN of a meter point linked to the CHF.
  mpxn: String

  # Is it a new or replacement CHF?
  chfInstallType: CHFInstallType

  # Was an external aerial installed?
  hasAerialInstalled: Boolean

  # Location of the CHF.
  chfLocation: CHFLocation

  # Type of the premise in which the CHF is located.
  premiseType: PremiseType

  # In the case of NO_SM_WAN, was the issue a local metal obstruction (as defined in CHSM)?
  hasMetalObstruction: Boolean

  # In the case of NO_SM_WAN, was the issue a thick stone wall obstruction (as defined in CHSM)?
  hasConnectivityObstruction: Boolean

  # In the case of NO_SM_WAN, was the CHF in a shared/communal area (as defined in CHSM)?
  hasSharedObstruction: Boolean

  # The engineer's description of the fault.
  faultReason: CHFFaultReason

  # Whether a fault was identified before or after the installation.
  faultReturnType: CHFFaultReturnType

  # How the CHF was installed and connected to the rest of the Smart Metering System.
  chfConnectionMethod: CHFConnectionMethod

  # In the case of NO_FAULT_RETURN, the reason for the meter not being installed.
  noFaultReturnType: CHFNoFaultReturnType
}

#
#     The type of comms hub status update request to be sent.
#
enum CommsHubStatusUpdateType {
  # Success.
  SUCCESS

  # No SM Wide Area Network.
  NO_SM_WAN

  # Returning CHF due to technical fault.
  FAULT_RETURN

  # Returning CHF for non-technical reason.
  NO_FAULT_RETURN
}

#
#     Whether it is a new or replacement CHF.
#
enum CHFInstallType {
  # New.
  NEW

  # Replacement.
  REPLACEMENT
}

#
#     Location of the CHF.
#
enum CHFLocation {
  # Outside of the premises.
  OUTSIDE

  # Indoors On External Wall.
  INDOORS_ON_EXTERNAL_WALL

  # Indoors, NOT on an external wall.
  DEEP_INDOORS

  # In the basement/cellar.
  BASEMENT_OR_CELLAR
}

#
#     The type of premise in which the CHF is located.
#
enum PremiseType {
  # Detached / Semi-detached.
  DETACHED_OR_SEMI

  # Terraced.
  TERRACED

  # An apartment block with 5 floors or less.
  LOW_RISE_APARTMENT

  # An apartment block with more than 5 floors.
  HIGH_RISE_APARTMENT
}

#
#     The user's description of the fault, if the meter was not installed due to a technical problem.
#
enum CHFFaultReason {
  # Damaged Case.
  DAMAGED_CASE

  # Damaged connector.
  DAMAGED_CONNECTOR

  # Illegal Interference Or Missing Seals.
  ILLEGAL_INTERFERENCE_OR_MISSING_SEALS

  # Environmental Conditions Exceeded.
  ENVIRONMENTAL_CONDITIONS_EXCEEDED

  # Fault with SM WAN.
  SM_WAN_FAULT

  # Fault with SM HAN interface.
  SM_HAN_FAULT

  # Fault with LED.
  LED_FAULT

  # Fault with aerial.
  AERIAL_FAULT

  # Manufacturing Defect.
  MANUFACTURING_DEFECT
}

#
#     Whether the fault was identified before or after the installation.
#
enum CHFFaultReturnType {
  # Prior To Installation.
  PRIOR_TO_INSTALLATION

  # Post Installation.
  POST_INSTALLATION
}

#
#     How the CHF was installed and connected to the rest of the Smart Metering System.
#
enum CHFConnectionMethod {
  # Hot Shoe.
  HOT_SHOE

  # Cradle.
  CRADLE

  # Esme.
  ESME
}

#
#     The reason for the meter not being installed if there was no technical issue.
#
enum CHFNoFaultReturnType {
  # General.
  GENERAL

  # Non-domestic opt-out.
  NON_DOMESTIC_OPT_OUT

  # Dual supplier HAN variant replacement.
  DUAL_SUPPLIER_HAN_VARIANT_REPLACEMENT

  # SM WAN variant replacement requested by DCC.
  SM_WAN_VARIANT_REPLACEMENT

  # Lost or stolen hub.
  LOST_OR_STOLEN_HUB
}

# The possible errors that can be raised are:
#
# - KT-GB-4053: Fuel type should not be specified for Alt HAN device.
# - KT-GB-4031: Error sending the request to join the device to the CHF.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type JoinConsumerDevice {
  possibleErrors: [PossibleErrorType]

  # The reference of the join PPMID, IHD, CAD or Alt HAN request in Kraken.
  requestReference: String
}

input JoinConsumerDeviceInput {
  # The fuel type of the device, electricity, gas or dual fuel
  fuelType: FuelTypeChoices

  # Device ID of the CHF (Communications Hub Function).
  chfDeviceId: String!

  # Device ID (IHD, PPMID, CAD or Alt HAN) of the device being added to the CHF.
  consumerDeviceId: String!

  # Code provided by manufacturer as part of ASN data, and included as part of device pre-notification, which can be required to authorise the joined device.
  installationCode: String

  # The device type being joined to the CHF.
  consumerDeviceType: JoinConsumerDeviceChoices!
}

# An enumeration.
enum FuelTypeChoices {
  # Electricity.
  ELECTRICITY

  # Gas.
  GAS

  # Dual Fuel.
  DUAL_FUEL
}

# An enumeration.
enum JoinConsumerDeviceChoices {
  # Pre-Payment Meter Interface Device.
  PPMID

  # In-Home Display.
  IHD

  # Consumer Access Device.
  CAD

  # Alternative Home Area Network.
  ALT_HAN
}

# Remove a consumer device from the CHF/HAN. Currently limited to only CAD devices.
#
# The possible errors that can be raised are:
#
# - KT-GB-4012: Unable to find the CAD device.
# - KT-GB-4032: Error sending the request to remove the device.
# - KT-GB-4013: Received invalid device type to remove other than CAD.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type RemoveConsumerDevice {
  possibleErrors: [PossibleErrorType]

  # The reference of the remove consumer device request in Kraken.
  requestReference: String
}

input RemoveConsumerDeviceInput {
  # Device ID of the CAD being removed from the CHF/HAN.
  consumerDeviceId: String!

  # The device type being joined, currently limited to CAD only.
  consumerDeviceType: RemoveConsumerDeviceChoices!
}

# An enumeration.
enum RemoveConsumerDeviceChoices {
  # Consumer Access Device.
  CAD
}

# Add credit to a smart prepayment meter.
type AddCreditToSmartMeter {
  # Top-up amount in pence to add to smart meter
  amount: Int!
}

# This type is used by clients to top-up a smart prepay meter
input SmartPrepayMeterAmountInput {
  # Account number of customer.
  accountNumber: String!

  # Electricity or gas meter device ID.
  deviceId: String!

  # Amount of credit to add to the meter, in pence.
  amount: Int!

  # The top-up will wait for this payment to clear before proceeding.
  paymentIntentId: ID

  # Apply as temporary credit.
  isTemporaryCredit: Boolean

  # Reason for top-up.
  reason: String
}

# The possible errors that can be raised are:
#
# - KT-GB-4033: No electricity device found matching device ID.
# - KT-GB-4034: Error requesting consumption data.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type RequestConsumptionData {
  possibleErrors: [PossibleErrorType]

  # The reference for the associated request in Kraken.
  requestReference: String
}

input RequestConsumptionDataInput {
  # Device ID for the meter.
  deviceId: String!

  # The first half hourly period start (inclusive) to retrieve.
  startAt: DateTime

  # The last half hourly end time (inclusive) to retrieve.
  endAt: DateTime
}

type ReplaceCommsHub {
  # The reference for the associated request in Kraken.
  requestReference: String
}

# Specify a new SMETS2 Communications Hub to replace an existing Communications Hub.
input ReplaceCommsHubInput {
  # The device id of the old Communications Hub.
  oldCommsHubDeviceId: String!

  # The device id of the new Communications Hub.
  newCommsHubDeviceId: String!
}

# Triggers an asynchronous request to check the connection of a device.
#
# As this is an asynchronous operation, the mutation does not return the result of the request.
# Instead, the request reference is returned, which can be used to track the status of the
# request. If it's an organisation, the organisation will receive an update on the request via
# the agent services.
type CheckDeviceConnection {
  # The reference of the request in Kraken.
  requestReference: String
}

# Specify the device id of a smart device to check the connection.
input CheckDeviceConnectionInput {
  # The device id of the device (e.g. B0-11-2E-33-FF-45-C6-78).
  deviceId: String!
}

type OccupyOutputType {
  account: AccountInterface
}

input OccupyInput {
  accountNumber: String!
  propertyId: String!
  quoteCode: String!
  productCode: String!

  # The day of the month that payments should be taken from the account. Should be between 1 and 28.
  paymentDay: Int
  directDebitInstruction: DirectDebitInstructionLocalBankDetailsInput = null
  users: [AccountUserInput]
  moveInDate: Date
}

input DirectDebitInstructionLocalBankDetailsInput {
  accountNumber: String!
  accountHolder: String!
  sortCode: String!
}

input AccountUserInput {
  givenName: String!
  familyName: String!
  email: String!
  mobile: String!
  optedInForMarketing: Boolean!
  creditScoreData: CreditScoreData = null
  creditScoreFetchedAt: DateTime
  dateOfBirth: Date
  psrData: UpdateSpecialCircumstancesInput = null

  # Role codes of the roles to be assigned to the user.
  roles: [String]
}

input CreditScoreData {
  riskBracket: String!
  score: Int!
}

input UpdateSpecialCircumstancesInput {
  # Additional presence preferred
  additionalPresencePreferred: Boolean

  # Blind
  blind: Boolean

  # Careline/telecare system
  carelineTelecareSystem: Boolean

  # Chronic/serious illness
  chronicSeriousIllness: Boolean

  # Dementia
  dementia: Boolean

  # Developmental condition
  developmentalCondition: Boolean

  # Pensionable age
  elderly: Boolean
  hearingImpairment: Boolean

  # Heart, lung & ventilator
  heartLungMachine: Boolean

  # Dialysis, feeding pump and automated medication
  kidneyDialysis: Boolean

  # MDE electric showering
  mdeElectricShowering: Boolean

  # Medicine refrigeration
  medicineRefrigeration: Boolean

  # Mental health
  mentalHealth: Boolean

  # Nebuliser and apnoea monitor
  nebuliser: Boolean

  # Oxygen concentrator
  oxygenConcentrator: Boolean

  # Oxygen Use
  oxygenUse: Boolean
  partialSighted: Boolean
  physicalImpairment: Boolean
  poorSenseOfSmell: Boolean
  restrictedHandMovement: Boolean
  restrictedMovement: Boolean
  speechImpairment: Boolean
  stairLift: Boolean
  waterDependent: Boolean
  familiesWithYoungChildren5OrUnder: Boolean
  familiesWithYoungChildren5OrUnderEndDate: String
  temporaryLifeChanges: Boolean
  temporaryLifeChangesEndDate: String
  temporaryPostHospitalRecovery: Boolean
  temporaryPostHospitalRecoveryEndDate: String
  temporaryYoungAdultHouseholder: Boolean
  temporaryYoungAdultHouseholderEndDate: String
  foreignLanguageSpeaker: Boolean

  # Preferred language
  language: String

  # Use a unique password to identify our staff and partners
  usePasswordToIdentify: Boolean
  partnerPassword: String

  # Consent required to allow priority service request information to be shared. You will only need to provide this once
  userConsent: Boolean
}

# The possible errors that can be raised are:
#
# - KT-GB-6624: An error occurred when trying to process this house move.
# - KT-GB-6625: An error occurred when trying to process this house move.
# - KT-GB-6626: There was an error processing the PSR data.
# - KT-GB-6627: There are missing agent appointments.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type PerformMoveOut {
  possibleErrors: [PossibleErrorType]
  account: AccountInterface
}

input MoveOutInput {
  accountNumber: String!
  propertyId: String!
  moveOutDate: Date!

  # The property to perform a move in for.
  newProperty: MoveInNewProperty = null

  # The details of the next occupant of the property.
  newTenant: MoveOutNewTenant = null
}

input MoveInNewProperty {
  # Street address of the new property. Should not contain the postcode.
  address: String!

  # Postcode of new property.
  postcode: String!

  # Date of moving into the new property.
  moveInDate: String

  # MPANs of the electricity meter points at the new property.
  mpans: [String]

  # MPRNs of the gas meter points at the new property.
  mprns: [String]

  # The product to use when creating agreements for the new property. If not provided, the current product for each meter point is used if available, or else the default SVT product. If provided, quote_code must also be provided.
  productCode: String

  # A quote that contains the product provided in product_code. Should be provided only if product_code is also provided.
  quoteCode: String

  # If True, this will trigger the move in flow at the new property for the account.
  moveInNewProperty: Boolean
}

input MoveOutNewTenant {
  givenName: String
  familyName: String
  email: String
  mobile: String
  role: String
}

# Create a shell account (a billable account with no property/energy supply).
type CreateShellAccountPayload {
  portfolioNumber: String
  givenName: String!
  familyName: String!
  billingName: String
  email: String!
  mobile: String
  landline: String
  brand: String
  dateOfBirth: Date
  billingAddressLine1: String
  billingAddressLine2: String
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingPostcode: String
  billingRichAddress: String

  # For fixed billing accounts only, the length of their billing period. Can be MONTHLY or QUARTERLY.
  billingPeriodLength: String

  # For fixed billing accounts only, the number the period length is to be multiplied by to get the total period length, i.e. for billing every second month, select 2 combined with a billing period length MONTHLY. Can't be > 1 for quarterly billing.
  billingPeriodMultiplier: Int

  # Day to fixed bill on if billing_period_length set.
  billingPeriodDay: Int

  # Month to start billing from if billing_period_length set to QUARTERLY or the multiplier is > 1.
  billingPeriodMonth: Int
  isBusinessAccount: Boolean
  companyName: String
  companyNumber: String
  businessType: String
  password: String
  passwordUpdateToken: String
  urn: String
  errors: [ErrorType]
  account: AccountInterface
  clientMutationId: String
}

input CreateShellAccountInput {
  portfolioNumber: String
  givenName: String!
  familyName: String!
  billingName: String
  email: String!
  mobile: String
  landline: String
  brand: String
  dateOfBirth: Date
  billingAddressLine1: String
  billingAddressLine2: String
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingPostcode: String
  billingRichAddress: String

  # For fixed billing accounts only, the length of their billing period. Can be MONTHLY or QUARTERLY.
  billingPeriodLength: String

  # For fixed billing accounts only, the number the period length is to be multiplied by to get the total period length, i.e. for billing every second month, select 2 combined with a billing period length MONTHLY. Can't be > 1 for quarterly billing.
  billingPeriodMultiplier: Int

  # Day to fixed bill on if billing_period_length set.
  billingPeriodDay: Int

  # Month to start billing from if billing_period_length set to QUARTERLY or the multiplier is > 1.
  billingPeriodMonth: Int
  isBusinessAccount: Boolean
  companyName: String
  companyNumber: String
  businessType: String
  password: String
  passwordUpdateToken: String
  urn: String
  clientMutationId: String
}

# Update the comms delivery preference for the input account number to the
# received commsDeliveryPreference value.
#
# The possible errors that can be raised are:
#
# - KT-CT-4123: Unauthorized.
# - KT-CT-4136: Cannot set comms preference to email when account has no email.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateCommsDeliveryPreference {
  possibleErrors: [PossibleErrorType]
  account: AccountInterface
}

# Input fields for updating comms delivery preferences for an account
input UpdateCommsDeliveryPreferenceInput {
  accountNumber: String!
  commsDeliveryPreference: CommsDeliveryPreference!
}

# Update the billing email for the input account number to the
# received email value.
#
# The possible errors that can be raised are:
#
# - KT-CT-4123: Unauthorized.
# - KT-CT-4122: Invalid email.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateAccountBillingEmail {
  possibleErrors: [PossibleErrorType]

  # Account that was changed.
  account: AccountInterface
}

# Input fields for updating billing email for an account.
input UpdateAccountBillingEmailInput {
  # Account number for account.
  accountNumber: String!

  # The billing_email which can be up to 512 characters. Use null to unset billing_email.
  billingEmail: String
}

# The possible errors that can be raised are:
#
# - KT-CT-4123: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type AddCampaignToAccount {
  possibleErrors: [PossibleErrorType]

  # Whether the campaign was successfully added.
  campaignAdded: Boolean
}

input AddCampaignToAccountInput {
  # The account number.
  accountNumber: String!

  # The slug of the campaign we want to assign.
  campaign: String!
}

# The possible errors that can be raised are:
#
# - KT-CT-4145: Invalid address.
# - KT-CT-7123: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateAccountBillingAddress {
  possibleErrors: [PossibleErrorType]

  # The updated account.
  account: AccountType
}

input AccountBillingAddressInput {
  # The account number of the account to update.
  accountNumber: String

  # Billing address details.
  billingAddress: BillingAddressDetailsInput = null
}

input BillingAddressDetailsInput {
  # Billing street address.
  streetAddress: String

  # Billing structured street address.
  structuredStreetAddress: GenericScalar

  # Billing dependent locality.
  dependentLocality: String

  # Billing locality.
  locality: String

  # Billing postal code.
  postalCode: String

  # Billing sorting code.
  sortingCode: String

  # Billing delivery point identifier.
  deliveryPointIdentifier: String

  # Administrative area.
  administrativeArea: String

  # Billing country.
  country: String
}

# The possible errors that can be raised are:
#
# - KT-CT-4123: Unauthorized.
# - KT-CT-4180: Account note must be a valid string.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateAccountNote {
  possibleErrors: [PossibleErrorType]

  # Account, which has the added note.
  account: AccountType
}

input CreateAccountNoteInput {
  # The account number.
  accountNumber: String!

  # The note to add.
  note: String!

  # Pin the note to account.
  isPinned: Boolean!
}

# Renew agreements for an account.
#
# This mutation calls tariff renewal use-case both
# for electricity and gas agreements.
#
# This mutation renews agreements from midnight the day it is invoked in the case of flexible
# tariffs and fixed tariffs ending in more than 90 days. For fixed tariffs that end in less
# than 90 days, it creates follow on agreements that start when the fixed agreements end (or
# minimum of when they end in the case of misaligned agreements).
#
# The possible errors that can be raised are:
#
# - KT-GB-4125: Invalid data.
# - KT-GB-4111: Unable to renew agreements for tariff renewal.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type RenewAgreements {
  possibleErrors: [PossibleErrorType]
  account: AccountType
}

input RenewAgreementsInput {
  # Account number.
  accountNumber: String!

  # The ID if the quoted product we wish to use to create new agreements. Part of the tariff renewal journey involves re-quoting to ensure this is available.
  quotedProductId: ID!

  # The ID of the property that agreements should be renewed for.
  propertyId: ID!

  # Where the account's current payment schedule has a debt repayment element, we let the user choose whether to continue making catch-up payments, or to repay the full debt in addition to their next payment.
  makeFullDebtRepayment: Boolean!

  # If the customer is currently on a flat rate tariff, persist this into the new agreement.
  persistFlatRate: Boolean

  # The date the new agreement takes effect. This can be no more than 90 days in the future.
  changeOn: Date
}

# Renew agreement for a given meter point.
#
# The possible errors that can be raised are:
#
# - KT-GB-4112: Unable to renew agreements for meter point at this time. Please try again later.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type RenewAgreementForMeterPoint {
  possibleErrors: [PossibleErrorType]
  electricityAgreement: RestrictedElectricityAgreement
  gasAgreement: RestrictedGasAgreement
}

type RestrictedElectricityAgreement implements Node {
  validFrom: DateTime!
  validTo: DateTime

  # The ID of the object
  id: ID!
  tariffCode: String
}

type RestrictedGasAgreement implements Node {
  validFrom: DateTime!
  validTo: DateTime

  # The ID of the object
  id: ID!
  tariffCode: String
}

input RenewAgreementForMeterPointInput {
  # MPxN to renew the agreement for.
  mpxn: String!

  # Tariff code for the new agreement.
  tariffCode: String!

  # The start date of the new agreement (inclusive).
  validFromDate: Date!

  # The end date of the new agreement (exclusive).
  validToDate: Date

  # The date the agreement was agreed from (inclusive, if different to valid_from).
  agreedFromDate: Date

  # Bespoke rates overriding those of the associated tariff.
  bespokeTariffRates: BespokeTariffRatesInput = null

  # Bespoke rates overriding those of the associated tariff, with payment method.
  bespokePpsTariffRates: [BespokePPSTariffRatesInput] = null

  # Information on the commission that's associated with this agreement.
  commission: CommissionInput = null
}

input BespokeTariffRatesInput {
  # Bespoke standing charge.
  standingCharge: Decimal

  # Gas bespoke unit rate.
  unitRate: Decimal

  # Electricity bespoke unit rates with their associated rate type.
  unitRates: [BespokeElectricityUnitRatesInput] = null
}

input BespokeElectricityUnitRatesInput {
  # Electricity bespoke unit rate to override the unit rate associated with the tariff.
  unitRate: Decimal!

  # Rate type associated with the given unit rate.
  rateType: NonBespokeElectricityRateTypeChoices!
}

# An enumeration.
enum NonBespokeElectricityRateTypeChoices {
  STANDARD
  ECO7_DAY
  ECO7_NIGHT
  OFF_PEAK
}

input BespokePPSTariffRatesInput {
  # Bespoke standing charge.
  standingCharge: Decimal

  # Gas bespoke unit rate.
  unitRate: Decimal

  # Electricity bespoke unit rates with their associated rate type.
  unitRates: [BespokeElectricityUnitRatesInput] = null

  # Payment method associated with the given unit rate.
  paymentMethod: PaymentMethod!
}

# An enumeration.
enum PaymentMethod {
  DIRECT_DEBIT
  NON_DIRECT_DEBIT
  PREPAYMENT
}

input CommissionInput {
  # The third-party intermediary who sold this renewal to the customer.
  organizationName: String!

  # The amount to add to the unit rate when billing, in pence/kWh, which is paid to the third-party intermediary.
  unitRateUplift: Decimal!

  # The fixed comission fee, in pence, which is paid to the third-party intermediary.
  fixedTpiFee: Int

  # The subdomain of the affiliate link used to track the commission.
  affiliateLinkSubdomain: String
}

# Renew agreements provided for an account.
#
# The possible errors that can be raised are:
#
# - KT-GB-4113: At least one list of agreements to renew is required.
# - KT-GB-4126: Electricity and gas agreement input is invalid.
# - KT-GB-4114: Unable to renew agreements.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type RenewAgreementsForAccount {
  possibleErrors: [PossibleErrorType]
  account: AccountType
}

input RenewAgreementsForAccountInput {
  # Account number
  accountNumber: String!

  # A list of electricity agreements and the code of the product they will be renewed to.
  electricityAgreements: [AgreementRenewalProductInput]

  # A list of gas agreements and the code of the product they will be renewed to.
  gasAgreements: [AgreementRenewalProductInput]

  # The date the new agreement takes effect. This can be no more than 90 days in the future.
  changeOn: Date
}

input AgreementRenewalProductInput {
  # The Kraken ID of the agreement to be renewed. The agreement must be currently active.
  agreementId: ID!

  # The code of the product the agreement will be renewed to.
  productCode: String!
}

# Set stated interest in acquiring a smart meter of an account.
#
# The possible errors that can be raised are:
#
# - KT-GB-4115: Could not create smart meter interest for account.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateAccountSmartMeterInterest {
  possibleErrors: [PossibleErrorType]
  interestUpdated: Boolean

  # The interest of an account in procuring smart meters.
  smets2Interest: SmartMeterInterestChoices

  # The source category of the smart meter interest update.
  smets2InterestSource: SmartMeterInterestSourceChoices

  # The reason why the account holder is not interested in having a smart meter installed.
  smets2RefusalReason: SMETS2InterestReason
}

# An enumeration.
enum SmartMeterInterestSourceChoices {
  WEBSITE
  AFFILIATE
}

input UpdateAccountSmartMeterInterestInput {
  accountNumber: String!

  # Input field for setting smart meter interest.
  smets2Interest: SmartMeterInterestChoices!

  # The source category of the smart meter interest update.
  smets2InterestSource: SmartMeterInterestSourceChoices = WEBSITE

  # Input field for setting the reason for why a customer is not interested in a smart meter.
  smets2RefusalReason: SMETS2InterestReason
}

# Onboarding for smart tariffs.
#
# This mutation kicks off the smart onboarding for electricity.
#
# The possible errors that can be raised are:
#
# - KT-GB-4102: Unable to start smart onboarding process.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type StartSmartOnboardingProcess {
  possibleErrors: [PossibleErrorType]
  onboardingProcess: SmartOnboardingProcessType

  # The product enrolment process created.
  productEnrolment: ProductEnrolmentType
}

type SmartOnboardingProcessType {
  id: ID!
  account: AccountType!
  meterPoint: ElectricityMeterPointType
  product: EnergyProductType!
}

input StartSmartOnboardingProcessInput {
  # Account number.
  accountNumber: String!

  # The MPAN to switch.
  mpan: String

  # The MPRN to switch.
  mprn: String

  # The product code to switch to.
  productCode: String!
  isNewAccount: Boolean = false
  termsAndConditions: TermsAndConditions = null

  # A target start date for the new agreement. Must be today or later. Will be ignored if date is in the past at time of creating the new agreement.
  targetAgreementChangeDate: Date
}

input TermsAndConditions {
  # The version of the terms and conditions the user was presented with.
  version: String!
  accepted: Boolean!
}

# Onboarding for export tariffs.
#
# This mutation kicks off the export onboarding for electricity.
#
# The possible errors that can be raised are:
#
# - KT-GB-4103: Unable to start export onboarding process.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type StartExportOnboardingProcess {
  possibleErrors: [PossibleErrorType]
  onboardingProcess: SmartOnboardingProcessType

  # The product enrolment process created.
  productEnrolment: ProductEnrolmentType
}

input StartExportOnboardingProcessInput {
  # Account number.
  accountNumber: String!

  # The import MPAN.
  importMpan: String

  # The export MPAN.
  exportMpan: String

  # The export product code.
  productCode: String!

  # The export technology type.
  technologyType: ExportTechnologyType!

  # The FiT ownership status.
  fitStatus: FITStatus!

  # Whether to take over the FiT generation payments.
  includeFitGeneration: Boolean = false

  # The FiT ID.
  fitId: String

  # The export certificate object.
  certificate: Certificate = null

  # The DNO status.
  dnoStatus: DNOStatus!

  # Have the terms and conditions for this product been accepted? To be deprecated.
  termsAndConditionsAccepted: Boolean!

  # Version of the terms and conditions that have been accepted.
  acceptedTermsAndConditionsVersion: String
}

# The type of generator technology used for export.
enum ExportTechnologyType {
  # Hydro
  HYDRO

  # Photovoltaic
  SOLAR

  # Storage
  STORAGE

  # Wind
  WIND

  # Photovoltaic and Storage
  SOLAR_AND_STORAGE

  # Wind and Storage
  WIND_AND_STORAGE
}

# The ownership status of FiT for this property.
enum FITStatus {
  # Notified
  OWNER

  # Previous owner
  PREVIOUS_OWNER

  # Third party owned
  THIRD_PARTY_OWNED

  # Unknown
  UNKNOWN

  # None
  NONE
}

input Certificate {
  # The export certificate number.
  number: String!

  # The export certificate type.
  type: CertificateType!
}

# The export certificate type.
enum CertificateType {
  MCS
  FLEXI_ORB
}

# The status of DNO being notified of this export request.
enum DNOStatus {
  # Notified
  NOTIFIED

  # Not Notified
  NOT_NOTIFIED

  # Unknown
  UNKNOWN
}

# Mutation to update the Supply Start Date (SSD) of an account.
#
# The possible errors that can be raised are:
#
# - KT-GB-4101: Unable to update SSD for account.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateSsd {
  possibleErrors: [PossibleErrorType]
  ssdUpdated: Boolean
  estimatedSsd: Date
}

input UpdateSsdInput {
  # The account number.
  accountNumber: String!

  # The desired Supply Start Date (SSD).
  desiredSsd: Date!
}

# Create a Siteworks event.
#
# Currently, only events for reporting are enabled.
type CreateSiteworksEvent {
  eventCreated: Boolean
}

input CreateSiteworksEventInput {
  # The Siteworks request id.
  siteworksRequestId: String!

  # The type of Siteworks event that will be created.
  eventType: SiteworksEventType!

  # The content that might be submitted as field servies data.
  fieldServicesData: JSONString

  # The references that are related to jobs, appointments etc.
  references: JSONString

  # The notes that are associated with the Siteworks event.
  eventNotes: String
}

#
#     Please note: these labels are exposed in the API documentation.
#
enum SiteworksEventType {
  # SMICOP compliance report submitted
  SMICOP_COMPLIANCE_REPORT_SUBMITTED
}

# Makes it possible to create Sitework events by external third parties.
#
# This mutation uses the external JWT authorization method.
#
# The possible errors that can be raised are:
#
# - KT-GB-4222: The provided 'siteworksRequestId' is not a valid UUID.
# - KT-GB-4223: Siteworks request not found. Check the provided 'siteworksRequestId' is correct.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateSiteworksEventExternal {
  possibleErrors: [PossibleErrorType]
  eventCreated: Boolean
}

# Create a new job or update the status of an existing one.
#
# The possible errors that can be raised are:
#
# - KT-CT-1112: 'Authorization' header not provided.
# - KT-CT-4231: Unauthorized.
# - KT-GB-4230: Invalid data.
# - KT-GB-4224: Error processing siteworks appointment.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateOrUpdateSiteworksAppointment {
  possibleErrors: [PossibleErrorType]
  result: CreateOrUpdateSiteworksAppointmentOutput
}

type CreateOrUpdateSiteworksAppointmentOutput {
  appointmentCreated: Boolean
  appointmentUpdated: Boolean
}

input CreateOrUpdateSiteworksAppointmentInput {
  # The market ID of the agent that carried out the work. This should be an electricity market participant ID or gas market code.
  agentId: String!

  # The unique appointment reference of the agent.
  appointmentReference: String!

  # The scheduled date of the appointment. Required if the appointment is not already booked.
  appointmentDate: Date!

  # The status of the appointment.
  status: AppointmentStatus!

  # The type of work the appointment has been booked for.
  workType: String

  # The categories of meter the work applies to.
  fuelType: FuelType!

  # Required if `fuel_type` is `ELECTRICITY` or `DUAL_FUEL`.
  mpan: String

  # Required if `fuel_type` is `GAS` or `DUAL_FUEL`.
  mprn: String
  electricitySupplyType: ElectricitySupplyType = null
  gasSupplyType: GasSupplyType = null

  # The start time of the slot during which the engineer is scheduled at the property.
  timeSlotStart: Time!

  # The end time of the slot during which the engineer is scheduled at the property.
  timeSlotEnd: Time

  # Address of the property where the appointment is taking place.
  address: AddressInput = null

  # Boolean flag to indicate an emergency appointment.
  isEmergency: Boolean

  # Name of engineer currently assigned to the appointment.
  engineerName: String

  # Extra context to a change in status such as abort or cancellation reason.
  statusReason: String

  # Free text comments about the appointment.
  jobNotes: String

  # If applicable, the category of new meters installed.
  newMeterCategory: NewMeterCategory = null

  # A list of electricity meters that the work applies to.
  electricityMeters: [MeterInput] = null

  # A list of electricity meters that the work applies to.
  gasMeters: [MeterInput] = null

  # The payment mode for the new meters. If not provided it will default to the payment mode for the current meters.
  futurePaymentMode: PaymentMode = null

  # Determines which communications will be sent to customers for the appointment. The default is to send all available messages (e.g. appointment confirmed, job completed).
  commsStrategy: CommsStrategy = SEND_ALL
}

# An enumeration.
enum AppointmentStatus {
  # The appointment has been booked.
  BOOKED

  # The appointment was cancelled either by the customer or the agent.
  CANCELLED

  # The appointment was aborted. Choose this option for partially completed work (e.g. on a dual fuel meter exchange where one meter was exchanged successfully but the other exchange could not be completed.
  ABORTED

  # The appointment has been completed successfully.
  COMPLETED
}

# An enumeration.
enum ElectricitySupplyType {
  # Single phase meter point.
  SINGLE_PHASE

  # Three phase meter point.
  THREE_PHASE
}

# An enumeration.
enum GasSupplyType {
  # Standard pressure gas supply.
  STANDARD

  # Medium pressure gas supply.
  MEDIUM
}

input AddressInput {
  addressLine1: String
  addressLine2: String
  addressLine3: String
  addressLine4: String
  addressLine5: String

  # Postcode of the property where the appointment took place.
  postcode: String!
}

# An enumeration.
enum NewMeterCategory {
  # SMETS1 (first generation smart meter).
  SMETS1

  # SMETS2 (second generation smart meter).
  SMETS2

  # Traditional meter.
  TRADITIONAL

  # Check Meter.
  CHECK_METER
}

input MeterInput {
  # Serial number of the meter involved in the appointments
  serialNumber: String!

  # Whether the meter details refer to a meter that is currently installed at the site or one that has been removed or replaced.
  status: MeterStatus = null

  # The type of meter. This field is not required but should be supplied whenever possible.
  meterType: String
}

# An enumeration.
enum MeterStatus {
  # The meter was removed.
  REMOVED

  # The meter was installed or work was done on an existing meter.
  ON_SITE
}

# Determines which communications will be sent for the appointment.
enum CommsStrategy {
  SEND_ALL
  SEND_ONLY_JOB_COMPLETED
  SUPPRESS_ALL
}

# Allows account users and organisations to cancel siteworks appointment.
type CancelSiteworksAppointment {
  siteworksAppointment: ActiveAppointmentType
}

input CancelSiteworksAppointmentInput {
  # The siteworks appointment Kraken unique ID.
  appointmentId: ID

  # The siteworks appointment agent reference code.
  agentReference: String
}

# The possible errors that can be raised are:
#
# - KT-GB-4219: Property does not exist.
# - KT-GB-4220: No account currently active at property.
# - KT-GB-4221: Could not confirm duplicate property.
# - KT-GB-4228: Cannot currently book appointments for legacy prepay meters.
# - KT-GB-4229: A smart meter exchange appointment for this date already exists.
# - KT-GB-4210: Bookings not supported for agent appointed at property.
# - KT-GB-4211: Timeslot no longer available.
# - KT-GB-4212: Missing or invalid data for account or property.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type ConfirmSiteworksAppointmentSlot {
  possibleErrors: [PossibleErrorType]
  siteworksAppointment: ActiveAppointmentType
}

input ConfirmSiteworksAppointmentSlotInput {
  propertyId: ID!
  appointmentDate: Date!
  startTime: Time!
  endTime: Time!
  additionalInformation: String
  agentReference: String
  siteId: String
  slotId: String
  calculationId: String
  promiseId: String

  # Determines which communications will be sent to customers for the appointment. The default is to send all available messages (e.g. appointment confirmed, job completed).
  commsStrategy: CommsStrategy = SEND_ALL
}

# The possible errors that can be raised are:
#
# - KT-GB-4213: Application not found.
# - KT-GB-4231: Invalid data.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type ReportRemovedMeterDetails {
  possibleErrors: [PossibleErrorType]
  result: ReportRemovedMeterDetailsOutput
}

type ReportRemovedMeterDetailsOutput {
  appointment: SiteworksAppointmentType
  electricityMeterPoint: SiteworksBookingElectricityMeterPointType
  gasMeterPoint: SiteworksBookingGasMeterPointType
}

input ReportRemovedMeterDetailsInput {
  # The installer/agents own booking reference for the appointment to remove these meters.
  appointmentId: String
  electricityMeterPoint: RemovedElectricityMeterPointInput = null
  gasMeterPoint: RemovedGasMeterPointInput = null
}

input RemovedElectricityMeterPointInput {
  mpan: String
  meters: [RemovedElectricityMeterInput] = null
}

input RemovedElectricityMeterInput {
  serialNumber: String!
  meterType: ElectricityMeterTypes = null
  registers: [RemovedElectricityMeterRegisterInput]!
  readAt: DateTime
  prepayData: RemovedMeterPrepayDataInput = null
}

# An enumeration.
enum ElectricityMeterTypes {
  # Key.
  K

  # Smartcard.
  S

  # Token.
  T
}

input RemovedElectricityMeterRegisterInput {
  # Identifier string/label for the register.
  id: String!
  finalReading: Float!
}

input RemovedMeterPrepayDataInput {
  # The credit balance of the meter in millipence.
  balance: Int

  # The total of all debt left on the removed meter in millipence.
  cumulativeDebtBalance: Int

  # Amount of emergency credit remaining on the meter in millipence.
  emergencyCreditBalance: Int
}

input RemovedGasMeterPointInput {
  mprn: String
  meters: [RemovedGasMeterInput] = null
}

input RemovedGasMeterInput {
  serialNumber: String!
  meterType: GasMeterTypes = null
  finalReading: Float!
  readAt: DateTime
  prepayData: RemovedMeterPrepayDataInput = null
}

# An enumeration.
enum GasMeterTypes {
  # Prepayment.
  PP

  # Electronic token.
  ET
}

# The possible errors that can be raised are:
#
# - KT-GB-5411: Failed to update special circumstance record.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdateSpecialCircumstances {
  possibleErrors: [PossibleErrorType]
  specialCircumstances: SpecialCircumstancesType
}

type DirectDebitPaymentDayUpdate {
  paymentSchedule: PaymentScheduleType
  errors: [ErrorType]
}

input DirectDebitPaymentDayUpdateInput {
  accountNumber: String!
  paymentDay: Int!
}

# The possible errors that can be raised are:
#
# - KT-GB-3918: Account not found.
# - KT-GB-3910: This feature is not available to business accounts.
# - KT-GB-3911: Your payment day cannot be changed at this time.
# - KT-GB-3912: Unable to update payment day.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type UpdatePaymentSchedulePaymentDay {
  possibleErrors: [PossibleErrorType]
  paymentSchedule: PaymentScheduleType
}

input UpdatePaymentSchedulePaymentDayInput {
  accountNumber: String!
  paymentDay: Int!
}

# The possible errors that can be raised are:
#
# - KT-GB-3919: Invalid payment schedule amount.
# - KT-GB-3920: Cannot update payment schedule amount.
# - KT-CT-3923: Unauthorized.
# - KT-CT-3941: Invalid data.
# - KT-CT-3942: An unexpected error occurred.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type UpdatePaymentSchedulePaymentAmount {
  possibleErrors: [PossibleErrorType]
  paymentSchedule: PaymentScheduleType
}

input UpdatePaymentSchedulePaymentAmountInput {
  accountNumber: String!

  # Amount in pence
  amount: Int!
}

# The possible errors that can be raised are:
#
# - KT-CT-3940: Invalid data.
# - KT-CT-3923: Unauthorized.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type CreateDirectDebitInstruction {
  possibleErrors: [PossibleErrorType]
  directDebitInstruction: DirectDebitInstructionType
}

input CreateDirectDebitInstructionInput {
  accountNumber: String!
  directDebitInstruction: DirectDebitInstructionLocalBankDetailsInput!
}

# Mutation for creating an Payment Schedule instance using the authenticated user.
#
# The possible errors that can be raised are:
#
# - KT-GB-3917: No statement in last 60 days.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type CreatePaymentSchedule {
  possibleErrors: [PossibleErrorType]
  paymentSchedule: PaymentScheduleType
}

input PaymentScheduleInput {
  # Input a customer account number.
  accountNumber: String!

  # Payment amount must be inputted as pence.
  paymentAmount: Int!

  # Input a direct debit payment day.
  paymentDay: Int!
}

type WarmHomeDiscountApplicationOutputType {
  errors: [SerializerFieldErrorsType]
  id: String
}

input WarmHomeDiscountApplicationInputType {
  # A set of criteria under which someone is eligible for the Warm Home Discount. The applicant must meet at least one of these criteria, as well as at least one qualifying component criteria.
  qualifyingCriteria: QualifyingCriteriaOptions = null

  # A set of criteria under which someone is eligible for the Warm Home Discount. The applicant must meet at least one of these criteria, as well as at least one qualifying component criteria.
  qualifyingComponent: CurrentQualifyingComponentOptions = null
}

# An enumeration.
enum CurrentQualifyingComponentOptions {
  PERSONAL_INDEPENDENCE_PAYMENTS
  DISABILITY_BENEFITS
  INCOME_RELATED_BENEFITS
  MATERNITY_EXEMPTION_CERTIFICATE
  AGE_THRESHOLD
  HAS_DISABILITY
  ADULT_DISABILITY_PAYMENT
  DEPENDENT_CHILD_UNDER_FIVE
  DEPENDENT_CHILD_OVER_FIVE
  LIMITED_CAPABILITY_FOR_WORK
}

type CreateMeterReadingOutputType {
  readingErrors: [SerializerFieldErrorsType]
  id: String
    @deprecated(
      reason: "The 'id' field is deprecated.\n\nThe `ID` field is depreciated.\n\n- Marked as deprecated on 2022-10-03.\n- Will be removed on 2024-01-01."
    )
}

input ReadingInputType {
  registerId: ID
  reading: Int
}

# Amend unbilled electricity reading.
type AmendUnbilledElectricityReading {
  readingAmended: Boolean
}

input AmendUnbilledReadingInput {
  # The ID of the reading that will be amended.
  readingId: Int!

  # The new value of reading.
  readingValue: Int!

  # The new datetime of reading.
  readingDatetime: DateTime!
}

# Create a new auto topup config for SPAYG meter.
type CreateAutoTopupConfig {
  # The created auto top-up config.
  autoTopupConfig: AutoTopupConfigType!
}

# The input type for creating an auto top-up config.
input CreateAutoTopupConfigInput {
  # The account number, e.g.: 'A-A1B2C3D4'.
  accountNumber: String!

  # Alphanumber code identifying the device, e.g.: 'A1-BC-D2-00-01-23-EF-4G'.
  deviceId: String!

  # The amount to top-up. The amount should always be provided in the minor unit of currency, i.e. USA cents / GBP pence / etc. Minimum allowed amount is 1.
  topupAmount: Int!
}

# Disable auto topup for SPAYG meter.
type DisableAutoTopup {
  # Boolean indicating if the auto top-up was successfully disabled.
  success: Boolean!
}

# The input type for disabling auto top-up.
input DisableAutoTopupInput {
  # The account number, e.g.: 'A-A1B2C3D4'.
  accountNumber: String!

  # Alphanumber code identifying the device, e.g.: 'A1-BC-D2-00-01-23-EF-4G'.
  deviceId: String!
}

type CreateQuoteOutputType {
  errors: [SerializerFieldErrorsType]
  quote: QuoteType
}

input CreateQuoteInput {
  postcode: String!
  electricityMeterPoints: [ElectricityMeterPointConsumptionInput]
  gasMeterPoints: [GasMeterPointConsumptionInput]

  # Used to verify the position that field sales agents generate quotes from
  position: PositionInput
  gspGroupId: String = ""
  affiliateSessionId: String = ""

  # The affiliate organisation ID. Used with restrict_to_affiliate_products.
  affiliateOrganisationId: String = ""

  # Whether to restrict the products (tariffs) to quote from to only show affiliate products. Requires affiliate_organisation_id.
  restrictToAffiliateProducts: Boolean = false
  brandCode: String!

  # Optional address information about the customer
  address: QuoteAddressInput
  isBusiness: Boolean = false

  # Whether the user has consented to their energy consumption estimates being retrieved from the industry vendors. This currently applies to business accounts only.
  hasConsentedToIndustryDataSearch: Boolean = false

  # Optional parameter to select the payment method for the quote, default is direct debit.
  paymentMethod: QuotePaymentMethodChoices = DIRECTDEBIT
}

input PositionInput {
  latitude: Float
  longitude: Float
}

input QuoteAddressInput {
  addressLine1: String = ""
  addressLine2: String = ""
  addressLine3: String = ""
}

# An enumeration.
enum QuotePaymentMethodChoices {
  DIRECTDEBIT
  CREDITCARD
  ONRECEIPT
  PREPAYMENT
}

# The possible errors that can be raised are:
#
# - KT-GB-4612: Unable to refresh quote - quote not found.
# - KT-GB-4613: Error generating quote.
# - KT-CT-1113: Disabled GraphQL field requested.
#
type RefreshQuote {
  possibleErrors: [PossibleErrorType]
  quote: QuoteType
}

input RefreshQuoteInput {
  code: String!
}

type Requote {
  quote: QuoteType
}

input RequoteInput {
  accountNumber: String!
  propertyId: ID!
  productAvailableAt: DateTime
  includeHiddenProducts: Boolean
  persistFlatRate: Boolean

  # Optional parameter to select the payment method for the quote, default is direct debit.
  paymentMethod: QuotePaymentMethodChoices = DIRECTDEBIT
}

# Bill an account with a smart meter to the most recent midnight snapshot reading.
type BillToLatestSmartMeterSnapshot {
  # The date that has been billed up to.
  billedToDate: Date

  # The balance after attempting to bill.
  currentBalance: Decimal
}

input BillToLatestSmartMeterSnapshotInput {
  # The account number.
  accountNumber: String!

  # The mpan number.
  mpan: String!
}

# Switch the provided meter points to the specified product.
#
# The possible errors that can be raised are:
#
# - KT-GB-4116: Invalid data.
# - KT-GB-4617: Quoted product not found.
# - KT-CT-4623: Unauthorized.
# - KT-GB-4117: Unable to process product switch.
# - KT-GB-4119: Meter point already on another account.
# - KT-GB-4120: MPxN has no active agreement.
# - KT-CT-1113: Disabled GraphQL field requested.
# - KT-CT-1111: Unauthorized.
# - KT-CT-1112: 'Authorization' header not provided.
#
type SwitchMeterPointProducts {
  possibleErrors: [PossibleErrorType]

  # The account associated with the meter points whose products were switched.
  account: AccountType
}

input SwitchMeterPointProductsInput {
  # Account number.
  accountNumber: String!

  # The information required to switch each meter point onto the specified product.
  meterPointSwitchContexts: [MeterPointSwitchContext!]!

  # Runs payment adequacy and checks if the amount - the customer is paying each month - should be updated.
  updatePaymentAmount: Boolean
}

input MeterPointSwitchContext {
  # The MPxN of the meter point.
  mpxn: String!

  # The ID of the selected quoted product.
  quotedProductId: ID!

  # The date the product switch should take effect. Defaults to the current agreement end date, or tomorrow if the agreement is open-ended.
  changeOn: Date

  # Information on the commission that's associated with this agreement.
  commission: CommissionInput = null

  # Should the meter point be on a flat rate.
  flatRate: Boolean
}

# Create an Electric Juice charge and associated line items.
type CreateElectricJuiceCharge {
  accountCharge: AccountChargeType
}

type AccountChargeType {
  # The ID of the account charge.
  id: ID

  # The net amount of the charge.
  netAmount: BigInt

  # The gross amount of the charge.
  grossAmount: BigInt

  # The sales tax amount of the charge.
  salesTaxAmount: BigInt

  # The climate change levy amount of the charge.
  cclAmount: BigInt

  # The reason for the charge.
  reason: String

  # The note for the charge.
  note: String

  # The display note for the charge.
  displayNote: String
  metadata: AccountChargeMetadataType
}

# The `BigInt` scalar type represents non-fractional whole numeric values.
# `BigInt` is not constrained to 32-bit like the `Int` type and thus is a less
# compatible type.
scalar BigInt

type AccountChargeMetadataType {
  # A JSON object containing unstructured data about the account charge.
  data: JSONString

  # The date and time the metadata was last updated.
  updatedAt: DateTime
}

# Allows use of a JSON String for input / output from the GraphQL schema.
#
# Use of this type is *not recommended* as you lose the benefits of having a defined, static
# schema (one of the key benefits of GraphQL).
scalar JSONString

# The `DateTime` scalar type represents a DateTime
# value as specified by
# [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
scalar DateTime

# The input type for adding a charge for Electric Juice.
input CreateElectricJuiceChargeInput {
  # The account number.
  accountNumber: String!

  # The UID of the Electric Juice charge card to associate with this charge.
  chargeCardUid: String

  # The start time of the charge period.
  periodStartAt: DateTime!

  # The end time of the charge period.
  periodEndAt: DateTime!

  # The amount to be charged (excl. tax).
  netAmount: Int!

  # The provider that originated this charge.
  chargeProvider: String!

  # The location of the charging point this charge is associated with.
  postcode: String!

  # The amount of energy consumed in kWh.
  kwhUsed: Decimal!

  # The price per kWh.
  pricePerKwh: Decimal!

  # The price of additional (non-consumption) fees on this charge.
  additionalFees: Int!
}

enum CurrencyOptions {
  UK_PENCE
}

# The `Decimal` scalar type represents a python Decimal.
scalar Decimal

# Add a credit to an Electric Juice Network ledger.
type CreateElectricJuiceCredit {
  accountCredit: AccountCreditType
}

type AccountCreditType {
  id: ID!

  #
  grossAmount: BigInt!

  #
  netAmount: BigInt!

  #
  salesTaxAmount: BigInt!
  note: String!
  reason: String!
  metadata: AccountCreditMetadataType
}

type AccountCreditMetadataType {
  data: JSONString!
  updatedAt: DateTime!
}

# The input type for an Electric Juice ledger credit.
input CreateElectricJuiceCreditInput {
  # The account number.
  accountNumber: String!

  # The net amount of the credit to be created.
  netAmount: Int!

  # The gross amount of the credit to be created.
  grossAmount: Int!

  # The tax amount of the credit to be created.
  taxAmount: Int!

  # Optional short note about account credit.
  note: String

  # The reason why the credit is added to the account.
  reason: AccountCreditReasonType!
}

#
#     Please note: these labels are exposed in the API documentation.
#
enum AccountCreditReasonType {
  # External referral credit
  EXTERNAL_REFERRAL_CREDIT
}
