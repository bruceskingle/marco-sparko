//graphql/octopus/octopus-schema.graphql built OK
//graphql/octopus/Login.graphql built OK
//graphql/octopus/account.graphql built OK
//graphql/octopus/meter.graphql built OK
//graphql/octopus/bill.graphql built OK

// Generated by sparko_graphql

#[allow(unused)]
pub mod graphql {
use display_json::DisplayAsJsonPretty;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
#[serde(rename = "ObtainJSONWebTokenInput")]
/* BRUCE */ pub struct ObtainJsonWebTokenInput {
    #[serde(rename = "email")]
    pub email_: Option<String>,
    #[serde(rename = "password")]
    pub password_: Option<String>,
    #[serde(rename = "APIKey")]
    pub apikey_: Option<String>,
    #[serde(rename = "organizationSecretKey")]
    pub organization_secret_key_: Option<String>,
    #[serde(rename = "preSignedKey")]
    pub pre_signed_key_: Option<String>,
    #[serde(rename = "refreshToken")]
    pub refresh_token_: Option<String>,
}

impl ObtainJsonWebTokenInput {
    pub fn builder() -> ObtainJsonWebTokenInputBuilder {
        ObtainJsonWebTokenInputBuilder {
            email_: None,
            password_: None,
            apikey_: None,
            organization_secret_key_: None,
            pre_signed_key_: None,
            refresh_token_: None,
        }
    }
}


pub struct ObtainJsonWebTokenInputBuilder {
    email_: Option<String>,
    password_: Option<String>,
    apikey_: Option<String>,
    organization_secret_key_: Option<String>,
    pre_signed_key_: Option<String>,
    refresh_token_: Option<String>,
}

impl ObtainJsonWebTokenInputBuilder {
    pub fn with_email(mut self, value: String) -> Self {
        self.email_ = Some(value);
        self
    }
    
    pub fn with_password(mut self, value: String) -> Self {
        self.password_ = Some(value);
        self
    }
    
    pub fn with_apikey(mut self, value: String) -> Self {
        self.apikey_ = Some(value);
        self
    }
    
    pub fn with_organization_secret_key(mut self, value: String) -> Self {
        self.organization_secret_key_ = Some(value);
        self
    }
    
    pub fn with_pre_signed_key(mut self, value: String) -> Self {
        self.pre_signed_key_ = Some(value);
        self
    }
    
    pub fn with_refresh_token(mut self, value: String) -> Self {
        self.refresh_token_ = Some(value);
        self
    }
    
    pub fn build(self) -> Result<ObtainJsonWebTokenInput, sparko_graphql::error::Error> {
        Ok(ObtainJsonWebTokenInput {
            email_: self.email_,
            password_: self.password_,
            apikey_: self.apikey_,
            organization_secret_key_: self.organization_secret_key_,
            pre_signed_key_: self.pre_signed_key_,
            refresh_token_: self.refresh_token_,
            })
    }
}

type GenericScalar = serde_json::Value;

type Date = sparko_graphql::types::Date;

type DateTime = sparko_graphql::types::DateTime;

#[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
pub enum DeviceType {
    #[serde(rename = "ESME")]
    Esme,
    #[serde(rename = "GSME")]
    Gsme,
    #[serde(rename = "GPF")]
    Gpf,
    #[serde(rename = "CHF")]
    Chf,
    #[serde(rename = "HCALCS")]
    Hcalcs,
    #[serde(rename = "PPMID")]
    Ppmid,
    #[serde(rename = "IHD")]
    Ihd,
    #[serde(rename = "CAD")]
    Cad,
    #[serde(rename = "IHD_OR_CAD")]
    IhdOrCad,
}

#[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
pub enum LineItemTypeOptions {
    #[serde(rename = "STANDING_CHARGE")]
    StandingCharge,
    #[serde(rename = "CONSUMPTION_CHARGE")]
    ConsumptionCharge,
}

#[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
pub enum LineItemGroupingOptions {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "HALF_HOUR")]
    HalfHour,
    #[serde(rename = "HOUR")]
    Hour,
    #[serde(rename = "DAY")]
    Day,
    #[serde(rename = "WEEK")]
    Week,
    #[serde(rename = "MONTH")]
    Month,
    #[serde(rename = "QUARTER")]
    Quarter,
}

type Decimal = crate::octopus::decimal::Decimal;

#[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
pub enum TelemetryGrouping {
    #[serde(rename = "TEN_SECONDS")]
    TenSeconds,
    #[serde(rename = "ONE_MINUTE")]
    OneMinute,
    #[serde(rename = "FIVE_MINUTES")]
    FiveMinutes,
    #[serde(rename = "HALF_HOURLY")]
    HalfHourly,
    #[serde(rename = "HOURLY")]
    Hourly,
}

#[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
pub enum ConsumptionGroupings {
    #[serde(rename = "QUARTER_HOUR")]
    QuarterHour,
    #[serde(rename = "HALF_HOUR")]
    HalfHour,
    #[serde(rename = "HOUR")]
    Hour,
    #[serde(rename = "DAY")]
    Day,
    #[serde(rename = "WEEK")]
    Week,
    #[serde(rename = "MONTH")]
    Month,
    #[serde(rename = "QUARTER")]
    Quarter,
}

#[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
pub enum BillTypeEnum {
    #[serde(rename = "STATEMENT")]
    Statement,
    #[serde(rename = "INVOICE")]
    Invoice,
    #[serde(rename = "CREDIT_NOTE")]
    CreditNote,
    #[serde(rename = "PRE_KRAKEN")]
    PreKraken,
}

#[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
pub enum StatementReversalsAfterClose {
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "SOME")]
    Some,
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "NOT_CLOSED")]
    NotClosed,
}

#[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
pub enum AccountStatementStatus {
    #[serde(rename = "OPEN")]
    Open,
    #[serde(rename = "CLOSED")]
    Closed,
}

#[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
pub enum ConsumptionUnit {
    #[serde(rename = "kWh")]
    KWh,
    #[serde(rename = "MJ")]
    Mj,
}

pub mod login {
    // Start dependencies
    // End dependencies
    pub mod obtain_kraken_token {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::ObtainJsonWebTokenInput;
        use super::super::GenericScalar;
        // Start dependencies
        // generate name=ObtainKrakenJsonWebToken id=0, selection.name=ObtainKrakenJsonWebToken
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "ObtainKrakenJSONWebToken")]
        pub struct ObtainKrakenJsonWebToken {
            #[serde(rename = "refreshToken")]
            pub refresh_token_: String, // T1
            #[serde(rename = "refreshExpiresIn")]
            pub refresh_expires_in_: i32, // T1
            #[serde(rename = "payload")]
            pub payload_: GenericScalar, // T1
            #[serde(rename = "token")]
            pub token_: String, // T1
        }
        
        // generate name=Response id=1, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "obtainKrakenToken")]
            pub obtain_kraken_token_: ObtainKrakenJsonWebToken, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Variables {
            #[serde(rename = "input")]
            input_: ObtainJsonWebTokenInput,
        }
        
        impl Variables {
            pub fn get_formal_params(&self, buf: &mut String) {
                buf.push_str("$input: ObtainJSONWebTokenInput!,");
            }
        }
        
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Mutation {
            variables: Variables,
        }
        
        impl Mutation {
            const REQUEST_NAME: &str = "obtainKrakenToken";
            
            pub fn from(variables: Variables) -> Mutation {
                Mutation {variables}
            }
            
            pub fn new(
                input_: ObtainJsonWebTokenInput,
            ) -> Mutation {
                Mutation {
                variables: Variables {
                    input_,
                }
                }
            }
            pub fn builder() -> MutationBuilder {
                MutationBuilder {
                    input_: None,
                }
            }
        } // End of Mutation
        
        
        pub struct MutationBuilder {
            input_: Option<ObtainJsonWebTokenInput>,
        }
        
        impl MutationBuilder {
            pub fn with_input(mut self, value: ObtainJsonWebTokenInput) -> Self {
                self.input_ = Some(value);
                self
            }
            
            pub fn build(self) -> Result<Mutation, sparko_graphql::error::Error> {
                if let None = self.input_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("input"))
                }
                Ok(Mutation::from(Variables {
                    input_: self.input_.unwrap(),
                    }))
            }
        }
        
        impl GraphQLQuery<Response> for Mutation {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("mutation obtainKrakenToken");
                buf.push('(');
                self.variables.get_formal_params(&mut buf);
                buf.push(')');
                buf.push('{');
                    buf.push_str("obtainKrakenToken\n");
                    buf.push('(');
                        buf.push_str("input: $input,\n");
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("refreshToken\n");
                        buf.push_str("refreshExpiresIn\n");
                        buf.push_str("payload\n");
                        buf.push_str("token\n");
                    buf.push('}');
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                serde_json::to_string_pretty(&self.variables)
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
} // End of executable_document login
pub mod account {
    // Start dependencies
    // End dependencies
    pub mod viewer {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::Date;
        // Start dependencies
        // generate name=AccountInterface id=2, selection.name=AccountInterface
        // implemented_by ["AccountType"]
        /* <2 variant */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AccountInterface {
            #[serde(rename = "number")]
            pub number_: String, // T1
            #[serde(rename = "brand")]
            pub brand_: String, // T1
            #[serde(rename = "overdueBalance")]
            pub overdue_balance_: i32, // T1
            #[serde(rename = "billingName")]
            pub billing_name_: String, // T1
            #[serde(rename = "billingSubName")]
            pub billing_sub_name_: Option<String>, // T1
            #[serde(rename = "billingEmail")]
            pub billing_email_: Option<String>, // T1
        }
        
        // generate name=AccountUserType id=3, selection.name=AccountUserType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AccountUserType {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "accounts")]
            pub accounts_: Vec<AccountInterface>, // T1
            #[serde(rename = "givenName")]
            pub given_name_: String, // T1
            #[serde(rename = "familyName")]
            pub family_name_: String, // T1
            #[serde(rename = "email")]
            pub email_: String, // T1
            #[serde(rename = "mobile")]
            pub mobile_: String, // T1
            #[serde(rename = "landline")]
            pub landline_: String, // T1
            #[serde(rename = "title")]
            pub title_: String, // T1
            #[serde(rename = "pronouns")]
            pub pronouns_: Option<String>, // T1
            #[serde(rename = "isDeceased")]
            pub is_deceased_: bool, // T1
            #[serde(rename = "liveSecretKey")]
            pub live_secret_key_: Option<String>, // T1
            #[serde(rename = "dateOfBirth")]
            pub date_of_birth_: Option<Date>, // T1
            #[serde(rename = "fullName")]
            pub full_name_: String, // T1
            #[serde(rename = "preferredName")]
            pub preferred_name_: String, // T1
            #[serde(rename = "alternativePhoneNumbers")]
            pub alternative_phone_numbers_: Vec<String>, // T1
            #[serde(rename = "hasFamilyIssues")]
            pub has_family_issues_: bool, // T1
            #[serde(rename = "isInHardship")]
            pub is_in_hardship_: bool, // T1
            #[serde(rename = "isOptedInToWof")]
            pub is_opted_in_to_wof_: bool, // T1
        }
        
        // generate name=Response id=4, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "viewer")]
            pub viewer_: AccountUserType, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Query {
        }
        
        impl Query {
            const REQUEST_NAME: &str = "viewer";
            
            pub fn new() -> Query {
                Query {}
            }
        } // End of Query
        
        impl GraphQLQuery<Response> for Query {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("query viewer");
                buf.push('{');
                    buf.push_str("viewer\n");
                    buf.push('{');
                        buf.push_str("id\n");
                        buf.push_str("accounts\n");
                        buf.push('{');
                            buf.push_str("number\n");
                            buf.push_str("brand\n");
                            buf.push_str("overdueBalance\n");
                            buf.push_str("billingName\n");
                            buf.push_str("billingSubName\n");
                            buf.push_str("billingEmail\n");
                        buf.push('}');
                        buf.push_str("givenName\n");
                        buf.push_str("familyName\n");
                        buf.push_str("email\n");
                        buf.push_str("mobile\n");
                        buf.push_str("landline\n");
                        buf.push_str("title\n");
                        buf.push_str("pronouns\n");
                        buf.push_str("isDeceased\n");
                        buf.push_str("liveSecretKey\n");
                        buf.push_str("dateOfBirth\n");
                        buf.push_str("fullName\n");
                        buf.push_str("preferredName\n");
                        buf.push_str("alternativePhoneNumbers\n");
                        buf.push_str("hasFamilyIssues\n");
                        buf.push_str("isInHardship\n");
                        buf.push_str("isOptedInToWof\n");
                    buf.push('}');
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                Ok(String::from("{}"))
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
} // End of executable_document account
pub mod meter {
    // Start dependencies
    // End dependencies
    pub mod account_properties_meters {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::DateTime;
        use super::super::Date;
        use super::super::DeviceType;
        // Start dependencies
        // generate name=OccupancyPeriodType id=5, selection.name=OccupancyPeriodType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct OccupancyPeriodType {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "effectiveFrom")]
            pub effective_from_: DateTime, // T1
            #[serde(rename = "effectiveTo")]
            pub effective_to_: Option<DateTime>, // T1
            #[serde(rename = "isOccupier")]
            pub is_occupier_: bool, // T1
        }
        
        // generate name=CoordinatesType id=6, selection.name=CoordinatesType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct CoordinatesType {
            #[serde(rename = "latitude")]
            pub latitude_: f64, // T1
            #[serde(rename = "longitude")]
            pub longitude_: f64, // T1
        }
        
        // generate name=ElectricityMeterType id=7, selection.name=ElectricityMeterType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct ElectricityMeterType {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "nodeId")]
            pub node_id_: String, // T1
            #[serde(rename = "serialNumber")]
            pub serial_number_: String, // T1
        }
        
        // generate name=ElectricityMeterType2 id=8, selection.name=ElectricityMeterType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "ElectricityMeterType")]
        pub struct ElectricityMeterType2 {
            #[serde(rename = "nodeId")]
            pub node_id_: String, // T1
            #[serde(rename = "serialNumber")]
            pub serial_number_: String, // T1
            #[serde(rename = "consumptionUnits")]
            pub consumption_units_: String, // T1
            #[serde(rename = "hasAndAllowsHhReadings")]
            pub has_and_allows_hh_readings_: bool, // T1
            #[serde(rename = "importMeter")]
            pub import_meter_: Option<ElectricityMeterType>, // T1
        }
        
        // generate name=ElectricityMeterPointType id=9, selection.name=ElectricityMeterPointType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct ElectricityMeterPointType {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "supplyEndDate")]
            pub supply_end_date_: Option<Date>, // T1
            #[serde(rename = "mpan")]
            pub mpan_: String, // T1
            #[serde(rename = "status")]
            pub status_: String, // T1
            #[serde(rename = "meters")]
            pub meters_: Vec<ElectricityMeterType2>, // T1
        }
        
        // generate name=GasMeterType id=10, selection.name=GasMeterType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct GasMeterType {
            #[serde(rename = "nodeId")]
            pub node_id_: String, // T1
            #[serde(rename = "serialNumber")]
            pub serial_number_: String, // T1
            #[serde(rename = "consumptionUnits")]
            pub consumption_units_: String, // T1
            #[serde(rename = "hasAndAllowsHhReadings")]
            pub has_and_allows_hh_readings_: bool, // T1
        }
        
        // generate name=GasMeterPointType id=11, selection.name=GasMeterPointType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct GasMeterPointType {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "supplyEndDate")]
            pub supply_end_date_: Option<Date>, // T1
            #[serde(rename = "mprn")]
            pub mprn_: String, // T1
            #[serde(rename = "status")]
            pub status_: String, // T1
            #[serde(rename = "meters")]
            pub meters_: Vec<GasMeterType>, // T1
        }
        
        // generate name=SmartMeterDeviceType id=12, selection.name=SmartMeterDeviceType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct SmartMeterDeviceType {
            #[serde(rename = "deviceId")]
            pub device_id_: String, // T1
            #[serde(rename = "type")]
            pub type_: DeviceType, // T1
        }
        
        // generate name=SmartMeterDeviceNetworkType id=13, selection.name=SmartMeterDeviceNetworkType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct SmartMeterDeviceNetworkType {
            #[serde(rename = "smartDevices")]
            pub smart_devices_: Vec<SmartMeterDeviceType>, // T1
        }
        
        // generate name=PropertyType id=14, selection.name=PropertyType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct PropertyType {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "address")]
            pub address_: String, // T1
            #[serde(rename = "postcode")]
            pub postcode_: String, // T1
            #[serde(rename = "occupancyPeriods")]
            pub occupancy_periods_: Vec<OccupancyPeriodType>, // T1
            #[serde(rename = "coordinates")]
            pub coordinates_: CoordinatesType, // T1
            #[serde(rename = "electricityMeterPoints")]
            pub electricity_meter_points_: Vec<ElectricityMeterPointType>, // T1
            #[serde(rename = "gasMeterPoints")]
            pub gas_meter_points_: Vec<GasMeterPointType>, // T1
            #[serde(rename = "smartDeviceNetworks")]
            pub smart_device_networks_: Vec<SmartMeterDeviceNetworkType>, // T1
        }
        
        // generate name=AccountType id=15, selection.name=AccountType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AccountType {
            #[serde(rename = "properties")]
            pub properties_: Vec<PropertyType>, // T1
        }
        
        // generate name=Response id=16, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "account")]
            pub account_: AccountType, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Variables {
            #[serde(rename = "accountNumber")]
            account_number_: String,
        }
        
        impl Variables {
            pub fn get_formal_params(&self, buf: &mut String) {
                buf.push_str("$accountNumber: String!,");
            }
        }
        
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Query {
            variables: Variables,
        }
        
        impl Query {
            const REQUEST_NAME: &str = "accountPropertiesMeters";
            
            pub fn from(variables: Variables) -> Query {
                Query {variables}
            }
            
            pub fn new(
                account_number_: String,
            ) -> Query {
                Query {
                variables: Variables {
                    account_number_,
                }
                }
            }
            pub fn builder() -> QueryBuilder {
                QueryBuilder {
                    account_number_: None,
                }
            }
        } // End of Query
        
        
        pub struct QueryBuilder {
            account_number_: Option<String>,
        }
        
        impl QueryBuilder {
            pub fn with_account_number(mut self, value: String) -> Self {
                self.account_number_ = Some(value);
                self
            }
            
            pub fn build(self) -> Result<Query, sparko_graphql::error::Error> {
                if let None = self.account_number_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("accountNumber"))
                }
                Ok(Query::from(Variables {
                    account_number_: self.account_number_.unwrap(),
                    }))
            }
        }
        
        impl GraphQLQuery<Response> for Query {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("query accountPropertiesMeters");
                buf.push('(');
                self.variables.get_formal_params(&mut buf);
                buf.push(')');
                buf.push('{');
                    buf.push_str("account\n");
                    buf.push('(');
                        buf.push_str("accountNumber: $accountNumber,\n");
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("properties\n");
                        buf.push('{');
                            buf.push_str("id\n");
                            buf.push_str("address\n");
                            buf.push_str("postcode\n");
                            buf.push_str("occupancyPeriods\n");
                            buf.push('{');
                                buf.push_str("id\n");
                                buf.push_str("effectiveFrom\n");
                                buf.push_str("effectiveTo\n");
                                buf.push_str("isOccupier\n");
                            buf.push('}');
                            buf.push_str("coordinates\n");
                            buf.push('{');
                                buf.push_str("latitude\n");
                                buf.push_str("longitude\n");
                            buf.push('}');
                            buf.push_str("electricityMeterPoints\n");
                            buf.push('{');
                                buf.push_str("id\n");
                                buf.push_str("supplyEndDate\n");
                                buf.push_str("mpan\n");
                                buf.push_str("status\n");
                                buf.push_str("meters\n");
                                buf.push('{');
                                    buf.push_str("nodeId\n");
                                    buf.push_str("serialNumber\n");
                                    buf.push_str("consumptionUnits\n");
                                    buf.push_str("hasAndAllowsHhReadings\n");
                                    buf.push_str("importMeter\n");
                                    buf.push('{');
                                        buf.push_str("id\n");
                                        buf.push_str("nodeId\n");
                                        buf.push_str("serialNumber\n");
                                    buf.push('}');
                                buf.push('}');
                            buf.push('}');
                            buf.push_str("gasMeterPoints\n");
                            buf.push('{');
                                buf.push_str("id\n");
                                buf.push_str("supplyEndDate\n");
                                buf.push_str("mprn\n");
                                buf.push_str("status\n");
                                buf.push_str("meters\n");
                                buf.push('{');
                                    buf.push_str("nodeId\n");
                                    buf.push_str("serialNumber\n");
                                    buf.push_str("consumptionUnits\n");
                                    buf.push_str("hasAndAllowsHhReadings\n");
                                buf.push('}');
                            buf.push('}');
                            buf.push_str("smartDeviceNetworks\n");
                            buf.push('{');
                                buf.push_str("smartDevices\n");
                                buf.push('{');
                                    buf.push_str("deviceId\n");
                                    buf.push_str("type\n");
                                buf.push('}');
                            buf.push('}');
                        buf.push('}');
                    buf.push('}');
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                serde_json::to_string_pretty(&self.variables)
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
    pub mod meter_agreements {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::DateTime;
        // Start dependencies
        // generate name=ElectricityMeterPointType id=17, selection.name=ElectricityMeterPointType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct ElectricityMeterPointType {
            #[serde(rename = "mpan")]
            pub mpan_: String, // T1
        }
        
        // generate name=ElectricityMeterType id=18, selection.name=ElectricityMeterType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct ElectricityMeterType {
            #[serde(rename = "meterPoint")]
            pub meter_point_: ElectricityMeterPointType, // T1
        }
        
        // generate name=UnitRate id=19, selection.name=UnitRate
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct UnitRate {
            #[serde(rename = "validFrom")]
            pub valid_from_: DateTime, // T1
            #[serde(rename = "validTo")]
            pub valid_to_: DateTime, // T1
            #[serde(rename = "preVatValue")]
            pub pre_vat_value_: f64, // T1
            #[serde(rename = "value")]
            pub value_: f64, // T1
        }
        
        // generate name=HalfHourlyTariff id=20, selection.name=HalfHourlyTariff
        // generate name=StandardTariff id=21, selection.name=StandardTariff
        // generate name=DayNightTariff id=22, selection.name=DayNightTariff
        // generate name=ThreeRateTariff id=23, selection.name=ThreeRateTariff
        // generate name=PrepayTariff id=24, selection.name=PrepayTariff
        // generate name=ElectricityTariffType id=25, selection.name=ElectricityTariffType
        // implemented_by ["StandardTariff", "DayNightTariff", "ThreeRateTariff", "HalfHourlyTariff", "PrepayTariff"]
        /* 5 variants 5 implementors */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(tag = "__typename")]
        pub enum ElectricityTariffType {
        /* variants
        HalfHourlyTariff Variant { index: 20, name: "HalfHourlyTariff", fields: {"displayName": SelectionField { name: "displayName", selection_type: BuiltinType(String), force_nonnull: true }, "fullName": SelectionField { name: "fullName", selection_type: BuiltinType(String), force_nonnull: true }, "standingCharge": SelectionField { name: "standingCharge", selection_type: BuiltinType(Float), force_nonnull: false }, "unitRates": SelectionField { name: "unitRates", selection_type: Array(Selection(19)), force_nonnull: true }, "description": SelectionField { name: "description", selection_type: BuiltinType(String), force_nonnull: true }, "preVatStandingCharge": SelectionField { name: "preVatStandingCharge", selection_type: BuiltinType(Float), force_nonnull: false }, "productCode": SelectionField { name: "productCode", selection_type: BuiltinType(String), force_nonnull: true }, "tariffCode": SelectionField { name: "tariffCode", selection_type: BuiltinType(String), force_nonnull: true }}, type_condition: "HalfHourlyTariff" }
        StandardTariff Variant { index: 21, name: "StandardTariff", fields: {"id": SelectionField { name: "id", selection_type: BuiltinType(ID), force_nonnull: true }, "description": SelectionField { name: "description", selection_type: BuiltinType(String), force_nonnull: true }, "displayName": SelectionField { name: "displayName", selection_type: BuiltinType(String), force_nonnull: true }, "fullName": SelectionField { name: "fullName", selection_type: BuiltinType(String), force_nonnull: true }, "preVatStandingCharge": SelectionField { name: "preVatStandingCharge", selection_type: BuiltinType(Float), force_nonnull: false }, "preVatUnitRate": SelectionField { name: "preVatUnitRate", selection_type: BuiltinType(Float), force_nonnull: true }, "standingCharge": SelectionField { name: "standingCharge", selection_type: BuiltinType(Float), force_nonnull: false }, "tariffCode": SelectionField { name: "tariffCode", selection_type: BuiltinType(String), force_nonnull: true }, "unitRate": SelectionField { name: "unitRate", selection_type: BuiltinType(Float), force_nonnull: true }}, type_condition: "StandardTariff" }
        DayNightTariff Variant { index: 22, name: "DayNightTariff", fields: {"id": SelectionField { name: "id", selection_type: BuiltinType(ID), force_nonnull: true }, "dayRate": SelectionField { name: "dayRate", selection_type: BuiltinType(Float), force_nonnull: true }, "description": SelectionField { name: "description", selection_type: BuiltinType(String), force_nonnull: true }, "displayName": SelectionField { name: "displayName", selection_type: BuiltinType(String), force_nonnull: true }, "fullName": SelectionField { name: "fullName", selection_type: BuiltinType(String), force_nonnull: true }, "nightRate": SelectionField { name: "nightRate", selection_type: BuiltinType(Float), force_nonnull: true }, "preVatDayRate": SelectionField { name: "preVatDayRate", selection_type: BuiltinType(Float), force_nonnull: true }, "preVatNightRate": SelectionField { name: "preVatNightRate", selection_type: BuiltinType(Float), force_nonnull: true }, "preVatStandingCharge": SelectionField { name: "preVatStandingCharge", selection_type: BuiltinType(Float), force_nonnull: false }, "standingCharge": SelectionField { name: "standingCharge", selection_type: BuiltinType(Float), force_nonnull: false }, "tariffCode": SelectionField { name: "tariffCode", selection_type: BuiltinType(String), force_nonnull: true }}, type_condition: "DayNightTariff" }
        ThreeRateTariff Variant { index: 23, name: "ThreeRateTariff", fields: {"id": SelectionField { name: "id", selection_type: BuiltinType(ID), force_nonnull: true }, "dayRate": SelectionField { name: "dayRate", selection_type: BuiltinType(Float), force_nonnull: true }, "description": SelectionField { name: "description", selection_type: BuiltinType(String), force_nonnull: true }, "displayName": SelectionField { name: "displayName", selection_type: BuiltinType(String), force_nonnull: true }, "fullName": SelectionField { name: "fullName", selection_type: BuiltinType(String), force_nonnull: true }, "nightRate": SelectionField { name: "nightRate", selection_type: BuiltinType(Float), force_nonnull: true }, "offPeakRate": SelectionField { name: "offPeakRate", selection_type: BuiltinType(Float), force_nonnull: true }, "preVatDayRate": SelectionField { name: "preVatDayRate", selection_type: BuiltinType(Float), force_nonnull: true }, "preVatNightRate": SelectionField { name: "preVatNightRate", selection_type: BuiltinType(Float), force_nonnull: true }, "preVatOffPeakRate": SelectionField { name: "preVatOffPeakRate", selection_type: BuiltinType(Float), force_nonnull: true }, "preVatStandingCharge": SelectionField { name: "preVatStandingCharge", selection_type: BuiltinType(Float), force_nonnull: false }, "standingCharge": SelectionField { name: "standingCharge", selection_type: BuiltinType(Float), force_nonnull: false }, "tariffCode": SelectionField { name: "tariffCode", selection_type: BuiltinType(String), force_nonnull: true }}, type_condition: "ThreeRateTariff" }
        PrepayTariff Variant { index: 24, name: "PrepayTariff", fields: {"id": SelectionField { name: "id", selection_type: BuiltinType(ID), force_nonnull: true }, "displayName": SelectionField { name: "displayName", selection_type: BuiltinType(String), force_nonnull: true }, "fullName": SelectionField { name: "fullName", selection_type: BuiltinType(String), force_nonnull: true }, "preVatStandingCharge": SelectionField { name: "preVatStandingCharge", selection_type: BuiltinType(Float), force_nonnull: false }, "preVatUnitRate": SelectionField { name: "preVatUnitRate", selection_type: BuiltinType(Float), force_nonnull: true }, "productCode": SelectionField { name: "productCode", selection_type: BuiltinType(String), force_nonnull: true }, "standingCharge": SelectionField { name: "standingCharge", selection_type: BuiltinType(Float), force_nonnull: false }, "tariffCode": SelectionField { name: "tariffCode", selection_type: BuiltinType(String), force_nonnull: true }, "unitRate": SelectionField { name: "unitRate", selection_type: BuiltinType(Float), force_nonnull: true }}, type_condition: "PrepayTariff" }
        */
            StandardTariff(StandardTariff),
            DayNightTariff(DayNightTariff),
            ThreeRateTariff(ThreeRateTariff),
            HalfHourlyTariff(HalfHourlyTariff),
            PrepayTariff(PrepayTariff),
        }
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AbstractElectricityTariffType {
        }
        
        impl AbstractElectricityTariffType {
            pub fn as_electricity_tariff_type(&self) -> &AbstractElectricityTariffType {
                self
            }
        }
        
        // Variant names "HalfHourlyTariff"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "HalfHourlyTariff")]
        pub struct HalfHourlyTariff {
            #[serde(rename = "displayName")]
            pub display_name_: String, // T1
            #[serde(rename = "fullName")]
            pub full_name_: String, // T1
            #[serde(rename = "standingCharge")]
            pub standing_charge_: Option<f64>, // T1
            #[serde(rename = "unitRates")]
            pub unit_rates_: Vec<UnitRate>, // T1
            #[serde(rename = "description")]
            pub description_: String, // T1
            #[serde(rename = "preVatStandingCharge")]
            pub pre_vat_standing_charge_: Option<f64>, // T1
            #[serde(rename = "productCode")]
            pub product_code_: String, // T1
            #[serde(rename = "tariffCode")]
            pub tariff_code_: String, // T1
        }
        
        // Variant names "StandardTariff"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "StandardTariff")]
        pub struct StandardTariff {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "description")]
            pub description_: String, // T1
            #[serde(rename = "displayName")]
            pub display_name_: String, // T1
            #[serde(rename = "fullName")]
            pub full_name_: String, // T1
            #[serde(rename = "preVatStandingCharge")]
            pub pre_vat_standing_charge_: Option<f64>, // T1
            #[serde(rename = "preVatUnitRate")]
            pub pre_vat_unit_rate_: f64, // T1
            #[serde(rename = "standingCharge")]
            pub standing_charge_: Option<f64>, // T1
            #[serde(rename = "tariffCode")]
            pub tariff_code_: String, // T1
            #[serde(rename = "unitRate")]
            pub unit_rate_: f64, // T1
        }
        
        // Variant names "DayNightTariff"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "DayNightTariff")]
        pub struct DayNightTariff {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "dayRate")]
            pub day_rate_: f64, // T1
            #[serde(rename = "description")]
            pub description_: String, // T1
            #[serde(rename = "displayName")]
            pub display_name_: String, // T1
            #[serde(rename = "fullName")]
            pub full_name_: String, // T1
            #[serde(rename = "nightRate")]
            pub night_rate_: f64, // T1
            #[serde(rename = "preVatDayRate")]
            pub pre_vat_day_rate_: f64, // T1
            #[serde(rename = "preVatNightRate")]
            pub pre_vat_night_rate_: f64, // T1
            #[serde(rename = "preVatStandingCharge")]
            pub pre_vat_standing_charge_: Option<f64>, // T1
            #[serde(rename = "standingCharge")]
            pub standing_charge_: Option<f64>, // T1
            #[serde(rename = "tariffCode")]
            pub tariff_code_: String, // T1
        }
        
        // Variant names "ThreeRateTariff"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "ThreeRateTariff")]
        pub struct ThreeRateTariff {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "dayRate")]
            pub day_rate_: f64, // T1
            #[serde(rename = "description")]
            pub description_: String, // T1
            #[serde(rename = "displayName")]
            pub display_name_: String, // T1
            #[serde(rename = "fullName")]
            pub full_name_: String, // T1
            #[serde(rename = "nightRate")]
            pub night_rate_: f64, // T1
            #[serde(rename = "offPeakRate")]
            pub off_peak_rate_: f64, // T1
            #[serde(rename = "preVatDayRate")]
            pub pre_vat_day_rate_: f64, // T1
            #[serde(rename = "preVatNightRate")]
            pub pre_vat_night_rate_: f64, // T1
            #[serde(rename = "preVatOffPeakRate")]
            pub pre_vat_off_peak_rate_: f64, // T1
            #[serde(rename = "preVatStandingCharge")]
            pub pre_vat_standing_charge_: Option<f64>, // T1
            #[serde(rename = "standingCharge")]
            pub standing_charge_: Option<f64>, // T1
            #[serde(rename = "tariffCode")]
            pub tariff_code_: String, // T1
        }
        
        // Variant names "PrepayTariff"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "PrepayTariff")]
        pub struct PrepayTariff {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "displayName")]
            pub display_name_: String, // T1
            #[serde(rename = "fullName")]
            pub full_name_: String, // T1
            #[serde(rename = "preVatStandingCharge")]
            pub pre_vat_standing_charge_: Option<f64>, // T1
            #[serde(rename = "preVatUnitRate")]
            pub pre_vat_unit_rate_: f64, // T1
            #[serde(rename = "productCode")]
            pub product_code_: String, // T1
            #[serde(rename = "standingCharge")]
            pub standing_charge_: Option<f64>, // T1
            #[serde(rename = "tariffCode")]
            pub tariff_code_: String, // T1
            #[serde(rename = "unitRate")]
            pub unit_rate_: f64, // T1
        }
        
        // generate name=ElectricityAgreementType id=26, selection.name=ElectricityAgreementType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct ElectricityAgreementType {
            #[serde(rename = "id")]
            pub id_: i32, // T1
            #[serde(rename = "validFrom")]
            pub valid_from_: DateTime, // T1
            #[serde(rename = "validTo")]
            pub valid_to_: Option<DateTime>, // T1
            #[serde(rename = "tariff")]
            pub tariff_: ElectricityTariffType, // T1
        }
        
        // generate name=ElectricityMeterPointType2 id=27, selection.name=ElectricityMeterPointType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "ElectricityMeterPointType")]
        pub struct ElectricityMeterPointType2 {
            #[serde(rename = "mpan")]
            pub mpan_: String, // T1
            #[serde(rename = "agreements")]
            pub agreements_: Vec<ElectricityAgreementType>, // T1
        }
        
        // generate name=GasTariffType id=28, selection.name=GasTariffType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct GasTariffType {
            #[serde(rename = "fullName")]
            pub full_name_: String, // T1
            #[serde(rename = "tariffCode")]
            pub tariff_code_: String, // T1
            #[serde(rename = "standingCharge")]
            pub standing_charge_: Option<f64>, // T1
            #[serde(rename = "preVatUnitRate")]
            pub pre_vat_unit_rate_: f64, // T1
            #[serde(rename = "unitRate")]
            pub unit_rate_: f64, // T1
        }
        
        // generate name=GasAgreementType id=29, selection.name=GasAgreementType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct GasAgreementType {
            #[serde(rename = "id")]
            pub id_: i32, // T1
            #[serde(rename = "validFrom")]
            pub valid_from_: DateTime, // T1
            #[serde(rename = "validTo")]
            pub valid_to_: Option<DateTime>, // T1
            #[serde(rename = "tariff")]
            pub tariff_: GasTariffType, // T1
        }
        
        // generate name=GasMeterPointType id=30, selection.name=GasMeterPointType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct GasMeterPointType {
            #[serde(rename = "agreements")]
            pub agreements_: Vec<GasAgreementType>, // T1
        }
        
        // generate name=ElectricityMeterType2 id=31, selection.name=ElectricityMeterType
        // generate name=GasMeterType id=32, selection.name=GasMeterType
        // generate name=Node id=33, selection.name=Node
        // implemented_by ["InkTag", "InkGenericMessage", "InkBucket", "ElectricityMeterType", "GasMeterType", "EmailEventType", "PrintEventType", "PrintMessageType", "AccountFileAttachment", "RestrictedElectricityAgreement", "RestrictedGasAgreement"]
        /* 2 variants 11 implementors */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(tag = "__typename")]
        pub enum Node {
        /* variants
        ElectricityMeterType Variant { index: 31, name: "ElectricityMeterType", fields: {"importMeter": SelectionField { name: "importMeter", selection_type: Selection(18), force_nonnull: false }, "meterPoint": SelectionField { name: "meterPoint", selection_type: Required(Selection(27)), force_nonnull: true }}, type_condition: "ElectricityMeterType" }
        GasMeterType Variant { index: 32, name: "GasMeterType", fields: {"meterPoint": SelectionField { name: "meterPoint", selection_type: Required(Selection(30)), force_nonnull: true }}, type_condition: "GasMeterType" }
        */
            InkTag(AbstractNode),
            InkGenericMessage(AbstractNode),
            InkBucket(AbstractNode),
            ElectricityMeterType(ElectricityMeterType2),
            GasMeterType(GasMeterType),
            EmailEventType(AbstractNode),
            PrintEventType(AbstractNode),
            PrintMessageType(AbstractNode),
            AccountFileAttachment(AbstractNode),
            RestrictedElectricityAgreement(AbstractNode),
            RestrictedGasAgreement(AbstractNode),
        }
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AbstractNode {
        }
        
        impl AbstractNode {
            pub fn as_node(&self) -> &AbstractNode {
                self
            }
        }
        
        // Variant names "ElectricityMeterType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "ElectricityMeterType2")]
        pub struct ElectricityMeterType2 {
            #[serde(rename = "importMeter")]
            pub import_meter_: Option<ElectricityMeterType>, // T1
            #[serde(rename = "meterPoint")]
            pub meter_point_: ElectricityMeterPointType2, // T1
        }
        
        // Variant names "GasMeterType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "GasMeterType")]
        pub struct GasMeterType {
            #[serde(rename = "meterPoint")]
            pub meter_point_: GasMeterPointType, // T1
        }
        
        // generate name=Response id=34, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "node")]
            pub node_: Node, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Variables {
            #[serde(rename = "meterNodeId")]
            meter_node_id_: String,
            #[serde(rename = "validAfter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            valid_after_: Option<DateTime>,
        }
        
        impl Variables {
            pub fn get_formal_params(&self, buf: &mut String) {
                buf.push_str("$meterNodeId: ID!,");
                if self.valid_after_.is_some() {
                    buf.push_str("$validAfter: DateTime,");
                }
            }
        }
        
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Query {
            variables: Variables,
        }
        
        impl Query {
            const REQUEST_NAME: &str = "meterAgreements";
            
            pub fn from(variables: Variables) -> Query {
                Query {variables}
            }
            
            pub fn new(
                meter_node_id_: String,
                valid_after_: Option<DateTime>,
            ) -> Query {
                Query {
                variables: Variables {
                    meter_node_id_,
                    valid_after_,
                }
                }
            }
            pub fn builder() -> QueryBuilder {
                QueryBuilder {
                    meter_node_id_: None,
                    valid_after_: None,
                }
            }
        } // End of Query
        
        
        pub struct QueryBuilder {
            meter_node_id_: Option<String>,
            valid_after_: Option<DateTime>,
        }
        
        impl QueryBuilder {
            pub fn with_meter_node_id(mut self, value: String) -> Self {
                self.meter_node_id_ = Some(value);
                self
            }
            
            pub fn with_valid_after(mut self, value: DateTime) -> Self {
                self.valid_after_ = Some(value);
                self
            }
            
            pub fn build(self) -> Result<Query, sparko_graphql::error::Error> {
                if let None = self.meter_node_id_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("meterNodeId"))
                }
                Ok(Query::from(Variables {
                    meter_node_id_: self.meter_node_id_.unwrap(),
                    valid_after_: self.valid_after_,
                    }))
            }
        }
        
        impl GraphQLQuery<Response> for Query {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("query meterAgreements");
                buf.push('(');
                self.variables.get_formal_params(&mut buf);
                buf.push(')');
                buf.push('{');
                    buf.push_str("node\n");
                    buf.push('(');
                        buf.push_str("id: $meterNodeId,\n");
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("... on ElectricityMeterType {\n");
                            buf.push_str("importMeter\n");
                            buf.push('{');
                                buf.push_str("meterPoint\n");
                                buf.push('{');
                                    buf.push_str("mpan\n");
                                buf.push('}');
                            buf.push('}');
                            buf.push_str("meterPoint\n");
                            buf.push('{');
                                buf.push_str("mpan\n");
                                buf.push_str("agreements\n");
                                buf.push('(');
                                    buf.push_str("excludeFuture: false,\n");
                                    if self.variables.valid_after_.is_some() {
                                        buf.push_str("validAfter: $validAfter,\n");
                                    }
                                    buf.push_str("includeInactive: true,\n");
                                buf.push(')');
                                buf.push('{');
                                    buf.push_str("id\n");
                                    buf.push_str("validFrom\n");
                                    buf.push_str("validTo\n");
                                    buf.push_str("tariff\n");
                                    buf.push('{');
                                        buf.push_str("... on HalfHourlyTariff {\n");
                                            buf.push_str("displayName\n");
                                            buf.push_str("fullName\n");
                                            buf.push_str("standingCharge\n");
                                            buf.push_str("unitRates\n");
                                            buf.push('{');
                                                buf.push_str("validFrom\n");
                                                buf.push_str("validTo\n");
                                                buf.push_str("preVatValue\n");
                                                buf.push_str("value\n");
                                            buf.push('}');
                                            buf.push_str("description\n");
                                            buf.push_str("preVatStandingCharge\n");
                                            buf.push_str("productCode\n");
                                            buf.push_str("tariffCode\n");
                                        buf.push('}');
                                        buf.push_str("... on StandardTariff {\n");
                                            buf.push_str("id\n");
                                            buf.push_str("description\n");
                                            buf.push_str("displayName\n");
                                            buf.push_str("fullName\n");
                                            buf.push_str("preVatStandingCharge\n");
                                            buf.push_str("preVatUnitRate\n");
                                            buf.push_str("standingCharge\n");
                                            buf.push_str("tariffCode\n");
                                            buf.push_str("unitRate\n");
                                        buf.push('}');
                                        buf.push_str("... on DayNightTariff {\n");
                                            buf.push_str("id\n");
                                            buf.push_str("dayRate\n");
                                            buf.push_str("description\n");
                                            buf.push_str("displayName\n");
                                            buf.push_str("fullName\n");
                                            buf.push_str("nightRate\n");
                                            buf.push_str("preVatDayRate\n");
                                            buf.push_str("preVatNightRate\n");
                                            buf.push_str("preVatStandingCharge\n");
                                            buf.push_str("standingCharge\n");
                                            buf.push_str("tariffCode\n");
                                        buf.push('}');
                                        buf.push_str("... on ThreeRateTariff {\n");
                                            buf.push_str("id\n");
                                            buf.push_str("dayRate\n");
                                            buf.push_str("description\n");
                                            buf.push_str("displayName\n");
                                            buf.push_str("fullName\n");
                                            buf.push_str("nightRate\n");
                                            buf.push_str("offPeakRate\n");
                                            buf.push_str("preVatDayRate\n");
                                            buf.push_str("preVatNightRate\n");
                                            buf.push_str("preVatOffPeakRate\n");
                                            buf.push_str("preVatStandingCharge\n");
                                            buf.push_str("standingCharge\n");
                                            buf.push_str("tariffCode\n");
                                        buf.push('}');
                                        buf.push_str("... on PrepayTariff {\n");
                                            buf.push_str("id\n");
                                            buf.push_str("displayName\n");
                                            buf.push_str("fullName\n");
                                            buf.push_str("preVatStandingCharge\n");
                                            buf.push_str("preVatUnitRate\n");
                                            buf.push_str("productCode\n");
                                            buf.push_str("standingCharge\n");
                                            buf.push_str("tariffCode\n");
                                            buf.push_str("unitRate\n");
                                        buf.push('}');
                                        buf.push_str("__typename\n");
                                    buf.push('}');
                                buf.push('}');
                            buf.push('}');
                        buf.push('}');
                        buf.push_str("... on GasMeterType {\n");
                            buf.push_str("meterPoint\n");
                            buf.push('{');
                                buf.push_str("agreements\n");
                                buf.push('(');
                                    buf.push_str("excludeFuture: false,\n");
                                    if self.variables.valid_after_.is_some() {
                                        buf.push_str("validAfter: $validAfter,\n");
                                    }
                                buf.push(')');
                                buf.push('{');
                                    buf.push_str("id\n");
                                    buf.push_str("validFrom\n");
                                    buf.push_str("validTo\n");
                                    buf.push_str("tariff\n");
                                    buf.push('{');
                                        buf.push_str("fullName\n");
                                        buf.push_str("tariffCode\n");
                                        buf.push_str("standingCharge\n");
                                        buf.push_str("preVatUnitRate\n");
                                        buf.push_str("unitRate\n");
                                    buf.push('}');
                                buf.push('}');
                            buf.push('}');
                        buf.push('}');
                        buf.push_str("__typename\n");
                    buf.push('}');
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                serde_json::to_string_pretty(&self.variables)
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
    pub mod electricity_agreement_line_items {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::DateTime;
        use super::super::LineItemTypeOptions;
        use super::super::LineItemGroupingOptions;
        use super::super::Decimal;
        // Start dependencies
        // generate name=ElectricityMeterPointType id=17, selection.name=ElectricityMeterPointType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct ElectricityMeterPointType {
            #[serde(rename = "mpan")]
            pub mpan_: String, // T1
        }
        
        // generate name=LineItemType id=35, selection.name=LineItemType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct LineItemType {
            #[serde(rename = "startAt")]
            pub start_at_: DateTime, // T1
            #[serde(rename = "endAt")]
            pub end_at_: DateTime, // T1
            #[serde(rename = "netAmount")]
            pub net_amount_: Decimal, // T1
            #[serde(rename = "numberOfUnits")]
            pub number_of_units_: Decimal, // T1
            #[serde(rename = "settlementUnit")]
            pub settlement_unit_: String, // T1
        }
        
        // generate name=ElectricityAgreementType id=36, selection.name=ElectricityAgreementType
        // generate name=AgreementInterface id=37, selection.name=AgreementInterface
        // implemented_by ["ElectricityAgreementType", "GasAgreementType"]
        /* 1 variants 2 implementors */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(tag = "__typename")]
        pub enum AgreementInterface {
        /* variants
        ElectricityAgreementType Variant { index: 36, name: "ElectricityAgreementType", fields: {"meterPoint": SelectionField { name: "meterPoint", selection_type: Required(Selection(17)), force_nonnull: true }, "lineItems": SelectionField { name: "lineItems", selection_type: PageOf(Selection(35)), force_nonnull: true }}, type_condition: "ElectricityAgreementType" }
        */
            ElectricityAgreementType(ElectricityAgreementType),
            GasAgreementType(AbstractAgreementInterface),
        }
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AbstractAgreementInterface {
        }
        
        impl AbstractAgreementInterface {
            pub fn as_agreement_interface(&self) -> &AbstractAgreementInterface {
                self
            }
        }
        
        // Variant names "ElectricityAgreementType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "ElectricityAgreementType")]
        pub struct ElectricityAgreementType {
            #[serde(rename = "meterPoint")]
            pub meter_point_: ElectricityMeterPointType, // T1
            #[serde(rename = "lineItems")]
            pub line_items_: sparko_graphql::types::PageOf<LineItemType>, // T1
        }
        
        // generate name=Response id=38, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "electricityAgreement")]
            pub electricity_agreement_: AgreementInterface, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Variables {
            #[serde(rename = "agreementId")]
            agreement_id_: String,
            #[serde(rename = "startAt")]
            start_at_: DateTime,
            #[serde(rename = "first")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_: Option<i32>,
            #[serde(rename = "timezone")]
            timezone_: String,
            #[serde(rename = "itemType")]
            item_type_: LineItemTypeOptions,
            #[serde(rename = "lineItemGrouping")]
            line_item_grouping_: LineItemGroupingOptions,
            #[serde(rename = "after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            after_: Option<String>,
        }
        
        impl Variables {
            pub fn get_formal_params(&self, buf: &mut String) {
                buf.push_str("$agreementId: ID!,");
                buf.push_str("$startAt: DateTime!,");
                if self.first_.is_some() {
                    buf.push_str("$first: Int,");
                }
                buf.push_str("$timezone: String!,");
                buf.push_str("$itemType: LineItemTypeOptions!,");
                buf.push_str("$lineItemGrouping: LineItemGroupingOptions!,");
                if self.after_.is_some() {
                    buf.push_str("$after: String,");
                }
            }
        }
        
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Query {
            variables: Variables,
        }
        
        impl Query {
            const REQUEST_NAME: &str = "electricityAgreementLineItems";
            
            pub fn from(variables: Variables) -> Query {
                Query {variables}
            }
            
            pub fn new(
                agreement_id_: String,
                start_at_: DateTime,
                first_: Option<i32>,
                timezone_: String,
                item_type_: LineItemTypeOptions,
                line_item_grouping_: LineItemGroupingOptions,
                after_: Option<String>,
            ) -> Query {
                Query {
                variables: Variables {
                    agreement_id_,
                    start_at_,
                    first_,
                    timezone_,
                    item_type_,
                    line_item_grouping_,
                    after_,
                }
                }
            }
            pub fn builder() -> QueryBuilder {
                QueryBuilder {
                    agreement_id_: None,
                    start_at_: None,
                    first_: None,
                    timezone_: None,
                    item_type_: None,
                    line_item_grouping_: None,
                    after_: None,
                }
            }
        } // End of Query
        
        
        pub struct QueryBuilder {
            agreement_id_: Option<String>,
            start_at_: Option<DateTime>,
            first_: Option<i32>,
            timezone_: Option<String>,
            item_type_: Option<LineItemTypeOptions>,
            line_item_grouping_: Option<LineItemGroupingOptions>,
            after_: Option<String>,
        }
        
        impl QueryBuilder {
            pub fn with_agreement_id(mut self, value: String) -> Self {
                self.agreement_id_ = Some(value);
                self
            }
            
            pub fn with_start_at(mut self, value: DateTime) -> Self {
                self.start_at_ = Some(value);
                self
            }
            
            pub fn with_first(mut self, value: i32) -> Self {
                self.first_ = Some(value);
                self
            }
            
            pub fn with_timezone(mut self, value: String) -> Self {
                self.timezone_ = Some(value);
                self
            }
            
            pub fn with_item_type(mut self, value: LineItemTypeOptions) -> Self {
                self.item_type_ = Some(value);
                self
            }
            
            pub fn with_line_item_grouping(mut self, value: LineItemGroupingOptions) -> Self {
                self.line_item_grouping_ = Some(value);
                self
            }
            
            pub fn with_after(mut self, value: String) -> Self {
                self.after_ = Some(value);
                self
            }
            
            pub fn build(self) -> Result<Query, sparko_graphql::error::Error> {
                if let None = self.agreement_id_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("agreementId"))
                }
                if let None = self.start_at_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("startAt"))
                }
                if let None = self.timezone_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("timezone"))
                }
                if let None = self.item_type_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("itemType"))
                }
                if let None = self.line_item_grouping_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("lineItemGrouping"))
                }
                Ok(Query::from(Variables {
                    agreement_id_: self.agreement_id_.unwrap(),
                    start_at_: self.start_at_.unwrap(),
                    first_: self.first_,
                    timezone_: self.timezone_.unwrap(),
                    item_type_: self.item_type_.unwrap(),
                    line_item_grouping_: self.line_item_grouping_.unwrap(),
                    after_: self.after_,
                    }))
            }
        }
        
        impl GraphQLQuery<Response> for Query {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("query electricityAgreementLineItems");
                buf.push('(');
                self.variables.get_formal_params(&mut buf);
                buf.push(')');
                buf.push('{');
                    buf.push_str("electricityAgreement\n");
                    buf.push('(');
                        buf.push_str("id: $agreementId,\n");
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("... on ElectricityAgreementType {\n");
                            buf.push_str("meterPoint\n");
                            buf.push('{');
                                buf.push_str("mpan\n");
                            buf.push('}');
                            buf.push_str("lineItems\n");
                            buf.push('(');
                                if self.variables.first_.is_some() {
                                    buf.push_str("first: $first,\n");
                                }
                                buf.push_str("grouping: $lineItemGrouping,\n");
                                buf.push_str("startAt: $startAt,\n");
                                buf.push_str("itemType: $itemType,\n");
                                buf.push_str("timezone: $timezone,\n");
                                if self.variables.after_.is_some() {
                                    buf.push_str("after: $after,\n");
                                }
                            buf.push(')');
                            buf.push('{');
                                buf.push_str("...lineItems\n");
                                buf.push_str("__typename\n");
                            buf.push('}');
                        buf.push('}');
                        buf.push_str("__typename\n");
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment lineItems on LineItemConnection\n");
                buf.push('{');
                    buf.push_str("edges\n");
                    buf.push('{');
                        buf.push_str("node\n");
                        buf.push('{');
                            buf.push_str("startAt\n");
                            buf.push_str("endAt\n");
                            buf.push_str("netAmount\n");
                            buf.push_str("numberOfUnits\n");
                            buf.push_str("settlementUnit\n");
                        buf.push('}');
                        buf.push_str("cursor\n");
                    buf.push('}');
                    buf.push_str("pageInfo\n");
                    buf.push('{');
                        buf.push_str("hasNextPage\n");
                        buf.push_str("hasPreviousPage\n");
                        buf.push_str("endCursor\n");
                        buf.push_str("startCursor\n");
                    buf.push('}');
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                serde_json::to_string_pretty(&self.variables)
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
    pub mod gas_agreement_line_items {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::DateTime;
        use super::super::LineItemTypeOptions;
        use super::super::LineItemGroupingOptions;
        use super::super::Decimal;
        // Start dependencies
        // generate name=GasMeterPointType id=39, selection.name=GasMeterPointType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct GasMeterPointType {
            #[serde(rename = "mprn")]
            pub mprn_: String, // T1
        }
        
        // generate name=LineItemType id=35, selection.name=LineItemType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct LineItemType {
            #[serde(rename = "startAt")]
            pub start_at_: DateTime, // T1
            #[serde(rename = "endAt")]
            pub end_at_: DateTime, // T1
            #[serde(rename = "netAmount")]
            pub net_amount_: Decimal, // T1
            #[serde(rename = "numberOfUnits")]
            pub number_of_units_: Decimal, // T1
            #[serde(rename = "settlementUnit")]
            pub settlement_unit_: String, // T1
        }
        
        // generate name=GasAgreementType id=40, selection.name=GasAgreementType
        // generate name=AgreementInterface id=41, selection.name=AgreementInterface
        // implemented_by ["ElectricityAgreementType", "GasAgreementType"]
        /* 1 variants 2 implementors */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(tag = "__typename")]
        pub enum AgreementInterface {
        /* variants
        GasAgreementType Variant { index: 40, name: "GasAgreementType", fields: {"meterPoint": SelectionField { name: "meterPoint", selection_type: Required(Selection(39)), force_nonnull: true }, "lineItems": SelectionField { name: "lineItems", selection_type: PageOf(Selection(35)), force_nonnull: true }}, type_condition: "GasAgreementType" }
        */
            ElectricityAgreementType(AbstractAgreementInterface),
            GasAgreementType(GasAgreementType),
        }
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AbstractAgreementInterface {
        }
        
        impl AbstractAgreementInterface {
            pub fn as_agreement_interface(&self) -> &AbstractAgreementInterface {
                self
            }
        }
        
        // Variant names "GasAgreementType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "GasAgreementType")]
        pub struct GasAgreementType {
            #[serde(rename = "meterPoint")]
            pub meter_point_: GasMeterPointType, // T1
            #[serde(rename = "lineItems")]
            pub line_items_: sparko_graphql::types::PageOf<LineItemType>, // T1
        }
        
        // generate name=Response id=42, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "gasAgreement")]
            pub gas_agreement_: AgreementInterface, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Variables {
            #[serde(rename = "agreementId")]
            agreement_id_: String,
            #[serde(rename = "startAt")]
            start_at_: DateTime,
            #[serde(rename = "first")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_: Option<i32>,
            #[serde(rename = "timezone")]
            timezone_: String,
            #[serde(rename = "itemType")]
            item_type_: LineItemTypeOptions,
            #[serde(rename = "lineItemGrouping")]
            line_item_grouping_: LineItemGroupingOptions,
            #[serde(rename = "after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            after_: Option<String>,
        }
        
        impl Variables {
            pub fn get_formal_params(&self, buf: &mut String) {
                buf.push_str("$agreementId: ID!,");
                buf.push_str("$startAt: DateTime!,");
                if self.first_.is_some() {
                    buf.push_str("$first: Int,");
                }
                buf.push_str("$timezone: String!,");
                buf.push_str("$itemType: LineItemTypeOptions!,");
                buf.push_str("$lineItemGrouping: LineItemGroupingOptions!,");
                if self.after_.is_some() {
                    buf.push_str("$after: String,");
                }
            }
        }
        
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Query {
            variables: Variables,
        }
        
        impl Query {
            const REQUEST_NAME: &str = "gasAgreementLineItems";
            
            pub fn from(variables: Variables) -> Query {
                Query {variables}
            }
            
            pub fn new(
                agreement_id_: String,
                start_at_: DateTime,
                first_: Option<i32>,
                timezone_: String,
                item_type_: LineItemTypeOptions,
                line_item_grouping_: LineItemGroupingOptions,
                after_: Option<String>,
            ) -> Query {
                Query {
                variables: Variables {
                    agreement_id_,
                    start_at_,
                    first_,
                    timezone_,
                    item_type_,
                    line_item_grouping_,
                    after_,
                }
                }
            }
            pub fn builder() -> QueryBuilder {
                QueryBuilder {
                    agreement_id_: None,
                    start_at_: None,
                    first_: None,
                    timezone_: None,
                    item_type_: None,
                    line_item_grouping_: None,
                    after_: None,
                }
            }
        } // End of Query
        
        
        pub struct QueryBuilder {
            agreement_id_: Option<String>,
            start_at_: Option<DateTime>,
            first_: Option<i32>,
            timezone_: Option<String>,
            item_type_: Option<LineItemTypeOptions>,
            line_item_grouping_: Option<LineItemGroupingOptions>,
            after_: Option<String>,
        }
        
        impl QueryBuilder {
            pub fn with_agreement_id(mut self, value: String) -> Self {
                self.agreement_id_ = Some(value);
                self
            }
            
            pub fn with_start_at(mut self, value: DateTime) -> Self {
                self.start_at_ = Some(value);
                self
            }
            
            pub fn with_first(mut self, value: i32) -> Self {
                self.first_ = Some(value);
                self
            }
            
            pub fn with_timezone(mut self, value: String) -> Self {
                self.timezone_ = Some(value);
                self
            }
            
            pub fn with_item_type(mut self, value: LineItemTypeOptions) -> Self {
                self.item_type_ = Some(value);
                self
            }
            
            pub fn with_line_item_grouping(mut self, value: LineItemGroupingOptions) -> Self {
                self.line_item_grouping_ = Some(value);
                self
            }
            
            pub fn with_after(mut self, value: String) -> Self {
                self.after_ = Some(value);
                self
            }
            
            pub fn build(self) -> Result<Query, sparko_graphql::error::Error> {
                if let None = self.agreement_id_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("agreementId"))
                }
                if let None = self.start_at_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("startAt"))
                }
                if let None = self.timezone_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("timezone"))
                }
                if let None = self.item_type_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("itemType"))
                }
                if let None = self.line_item_grouping_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("lineItemGrouping"))
                }
                Ok(Query::from(Variables {
                    agreement_id_: self.agreement_id_.unwrap(),
                    start_at_: self.start_at_.unwrap(),
                    first_: self.first_,
                    timezone_: self.timezone_.unwrap(),
                    item_type_: self.item_type_.unwrap(),
                    line_item_grouping_: self.line_item_grouping_.unwrap(),
                    after_: self.after_,
                    }))
            }
        }
        
        impl GraphQLQuery<Response> for Query {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("query gasAgreementLineItems");
                buf.push('(');
                self.variables.get_formal_params(&mut buf);
                buf.push(')');
                buf.push('{');
                    buf.push_str("gasAgreement\n");
                    buf.push('(');
                        buf.push_str("id: $agreementId,\n");
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("... on GasAgreementType {\n");
                            buf.push_str("meterPoint\n");
                            buf.push('{');
                                buf.push_str("mprn\n");
                            buf.push('}');
                            buf.push_str("lineItems\n");
                            buf.push('(');
                                if self.variables.first_.is_some() {
                                    buf.push_str("first: $first,\n");
                                }
                                buf.push_str("grouping: $lineItemGrouping,\n");
                                buf.push_str("startAt: $startAt,\n");
                                buf.push_str("itemType: $itemType,\n");
                                buf.push_str("timezone: $timezone,\n");
                                if self.variables.after_.is_some() {
                                    buf.push_str("after: $after,\n");
                                }
                            buf.push(')');
                            buf.push('{');
                                buf.push_str("...lineItems\n");
                                buf.push_str("__typename\n");
                            buf.push('}');
                        buf.push('}');
                        buf.push_str("__typename\n");
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment lineItems on LineItemConnection\n");
                buf.push('{');
                    buf.push_str("edges\n");
                    buf.push('{');
                        buf.push_str("node\n");
                        buf.push('{');
                            buf.push_str("startAt\n");
                            buf.push_str("endAt\n");
                            buf.push_str("netAmount\n");
                            buf.push_str("numberOfUnits\n");
                            buf.push_str("settlementUnit\n");
                        buf.push('}');
                        buf.push_str("cursor\n");
                    buf.push('}');
                    buf.push_str("pageInfo\n");
                    buf.push('{');
                        buf.push_str("hasNextPage\n");
                        buf.push_str("hasPreviousPage\n");
                        buf.push_str("endCursor\n");
                        buf.push_str("startCursor\n");
                    buf.push('}');
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                serde_json::to_string_pretty(&self.variables)
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
    pub mod get_current_demand {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::DateTime;
        use super::super::TelemetryGrouping;
        use super::super::Decimal;
        // Start dependencies
        // generate name=SmartMeterTelemetryType id=43, selection.name=SmartMeterTelemetryType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct SmartMeterTelemetryType {
            #[serde(rename = "readAt")]
            pub read_at_: DateTime, // T1
            #[serde(rename = "demand")]
            pub demand_: Decimal, // T1
        }
        
        // generate name=Response id=44, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "smartMeterTelemetry")]
            pub smart_meter_telemetry_: Vec<SmartMeterTelemetryType>, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Variables {
            #[serde(rename = "meterDeviceId")]
            meter_device_id_: String,
            #[serde(rename = "start")]
            #[serde(skip_serializing_if = "Option::is_none")]
            start_: Option<DateTime>,
            #[serde(rename = "end")]
            #[serde(skip_serializing_if = "Option::is_none")]
            end_: Option<DateTime>,
            #[serde(rename = "grouping")]
            #[serde(skip_serializing_if = "Option::is_none")]
            grouping_: Option<TelemetryGrouping>,
        }
        
        impl Variables {
            pub fn get_formal_params(&self, buf: &mut String) {
                buf.push_str("$meterDeviceId: String!,");
                if self.start_.is_some() {
                    buf.push_str("$start: DateTime,");
                }
                if self.end_.is_some() {
                    buf.push_str("$end: DateTime,");
                }
                if self.grouping_.is_some() {
                    buf.push_str("$grouping: TelemetryGrouping,");
                }
            }
        }
        
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Query {
            variables: Variables,
        }
        
        impl Query {
            const REQUEST_NAME: &str = "getCurrentDemand";
            
            pub fn from(variables: Variables) -> Query {
                Query {variables}
            }
            
            pub fn new(
                meter_device_id_: String,
                start_: Option<DateTime>,
                end_: Option<DateTime>,
                grouping_: Option<TelemetryGrouping>,
            ) -> Query {
                Query {
                variables: Variables {
                    meter_device_id_,
                    start_,
                    end_,
                    grouping_,
                }
                }
            }
            pub fn builder() -> QueryBuilder {
                QueryBuilder {
                    meter_device_id_: None,
                    start_: None,
                    end_: None,
                    grouping_: None,
                }
            }
        } // End of Query
        
        
        pub struct QueryBuilder {
            meter_device_id_: Option<String>,
            start_: Option<DateTime>,
            end_: Option<DateTime>,
            grouping_: Option<TelemetryGrouping>,
        }
        
        impl QueryBuilder {
            pub fn with_meter_device_id(mut self, value: String) -> Self {
                self.meter_device_id_ = Some(value);
                self
            }
            
            pub fn with_start(mut self, value: DateTime) -> Self {
                self.start_ = Some(value);
                self
            }
            
            pub fn with_end(mut self, value: DateTime) -> Self {
                self.end_ = Some(value);
                self
            }
            
            pub fn with_grouping(mut self, value: TelemetryGrouping) -> Self {
                self.grouping_ = Some(value);
                self
            }
            
            pub fn build(self) -> Result<Query, sparko_graphql::error::Error> {
                if let None = self.meter_device_id_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("meterDeviceId"))
                }
                Ok(Query::from(Variables {
                    meter_device_id_: self.meter_device_id_.unwrap(),
                    start_: self.start_,
                    end_: self.end_,
                    grouping_: self.grouping_,
                    }))
            }
        }
        
        impl GraphQLQuery<Response> for Query {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("query getCurrentDemand");
                buf.push('(');
                self.variables.get_formal_params(&mut buf);
                buf.push(')');
                buf.push('{');
                    buf.push_str("smartMeterTelemetry\n");
                    buf.push('(');
                        buf.push_str("deviceId: $meterDeviceId,\n");
                        if self.variables.start_.is_some() {
                            buf.push_str("start: $start,\n");
                        }
                        if self.variables.end_.is_some() {
                            buf.push_str("end: $end,\n");
                        }
                        if self.variables.grouping_.is_some() {
                            buf.push_str("grouping: $grouping,\n");
                        }
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("readAt\n");
                        buf.push_str("demand\n");
                    buf.push('}');
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                serde_json::to_string_pretty(&self.variables)
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
    pub mod meter_consumption {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::ConsumptionGroupings;
        use super::super::DateTime;
        use super::super::Decimal;
        // Start dependencies
        // generate name=ConsumptionType id=45, selection.name=ConsumptionType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct ConsumptionType {
            #[serde(rename = "value")]
            pub value_: Decimal, // T1
            #[serde(rename = "startAt")]
            pub start_at_: DateTime, // T1
            #[serde(rename = "endAt")]
            pub end_at_: DateTime, // T1
        }
        
        // generate name=ImportMeter id=46, selection.name=ImportMeter
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "ElectricityMeterType")]
        pub struct ImportMeter {
            #[serde(rename = "id")]
            pub id_: String, // T1
        }
        
        // generate name=ElectricityMeterType id=47, selection.name=ElectricityMeterType
        // generate name=GasMeterType id=48, selection.name=GasMeterType
        // generate name=Node id=49, selection.name=Node
        // implemented_by ["InkTag", "InkGenericMessage", "InkBucket", "ElectricityMeterType", "GasMeterType", "EmailEventType", "PrintEventType", "PrintMessageType", "AccountFileAttachment", "RestrictedElectricityAgreement", "RestrictedGasAgreement"]
        /* 2 variants 11 implementors */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(tag = "__typename")]
        pub enum Node {
        /* variants
        ElectricityMeterType Variant { index: 47, name: "ElectricityMeterType", fields: {"consumptionUnits": SelectionField { name: "consumptionUnits", selection_type: BuiltinType(String), force_nonnull: true }, "consumption": SelectionField { name: "consumption", selection_type: ForwardPageOf(Selection(45)), force_nonnull: true }, "serialNumber": SelectionField { name: "serialNumber", selection_type: Required(BuiltinType(String)), force_nonnull: true }, "importMeter": SelectionField { name: "importMeter", selection_type: Selection(46), force_nonnull: false }}, type_condition: "ElectricityMeterType" }
        GasMeterType Variant { index: 48, name: "GasMeterType", fields: {"consumptionUnits": SelectionField { name: "consumptionUnits", selection_type: BuiltinType(String), force_nonnull: true }, "consumption": SelectionField { name: "consumption", selection_type: ForwardPageOf(Selection(45)), force_nonnull: true }, "serialNumber": SelectionField { name: "serialNumber", selection_type: Required(BuiltinType(String)), force_nonnull: true }}, type_condition: "GasMeterType" }
        */
            InkTag(AbstractNode),
            InkGenericMessage(AbstractNode),
            InkBucket(AbstractNode),
            ElectricityMeterType(ElectricityMeterType),
            GasMeterType(GasMeterType),
            EmailEventType(AbstractNode),
            PrintEventType(AbstractNode),
            PrintMessageType(AbstractNode),
            AccountFileAttachment(AbstractNode),
            RestrictedElectricityAgreement(AbstractNode),
            RestrictedGasAgreement(AbstractNode),
        }
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AbstractNode {
        }
        
        impl AbstractNode {
            pub fn as_node(&self) -> &AbstractNode {
                self
            }
        }
        
        // Variant names "ElectricityMeterType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "ElectricityMeterType")]
        pub struct ElectricityMeterType {
            #[serde(rename = "consumptionUnits")]
            pub consumption_units_: String, // T1
            #[serde(rename = "consumption")]
            pub consumption_: sparko_graphql::types::ForwardPageOf<ConsumptionType>, // T1
            #[serde(rename = "serialNumber")]
            pub serial_number_: String, // T1
            #[serde(rename = "importMeter")]
            pub import_meter_: Option<ImportMeter>, // T1
        }
        
        // Variant names "GasMeterType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "GasMeterType")]
        pub struct GasMeterType {
            #[serde(rename = "consumptionUnits")]
            pub consumption_units_: String, // T1
            #[serde(rename = "consumption")]
            pub consumption_: sparko_graphql::types::ForwardPageOf<ConsumptionType>, // T1
            #[serde(rename = "serialNumber")]
            pub serial_number_: String, // T1
        }
        
        // generate name=Response id=50, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "node")]
            pub node_: Node, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Variables {
            #[serde(rename = "meterId")]
            meter_id_: String,
            #[serde(rename = "grouping")]
            grouping_: ConsumptionGroupings,
            #[serde(rename = "startAt")]
            start_at_: DateTime,
            #[serde(rename = "first")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_: Option<i32>,
            #[serde(rename = "timezone")]
            timezone_: String,
            #[serde(rename = "after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            after_: Option<String>,
        }
        
        impl Variables {
            pub fn get_formal_params(&self, buf: &mut String) {
                buf.push_str("$meterId: ID!,");
                buf.push_str("$grouping: ConsumptionGroupings!,");
                buf.push_str("$startAt: DateTime!,");
                if self.first_.is_some() {
                    buf.push_str("$first: Int,");
                }
                buf.push_str("$timezone: String!,");
                if self.after_.is_some() {
                    buf.push_str("$after: String,");
                }
            }
        }
        
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Query {
            variables: Variables,
        }
        
        impl Query {
            const REQUEST_NAME: &str = "meterConsumption";
            
            pub fn from(variables: Variables) -> Query {
                Query {variables}
            }
            
            pub fn new(
                meter_id_: String,
                grouping_: ConsumptionGroupings,
                start_at_: DateTime,
                first_: Option<i32>,
                timezone_: String,
                after_: Option<String>,
            ) -> Query {
                Query {
                variables: Variables {
                    meter_id_,
                    grouping_,
                    start_at_,
                    first_,
                    timezone_,
                    after_,
                }
                }
            }
            pub fn builder() -> QueryBuilder {
                QueryBuilder {
                    meter_id_: None,
                    grouping_: None,
                    start_at_: None,
                    first_: None,
                    timezone_: None,
                    after_: None,
                }
            }
        } // End of Query
        
        
        pub struct QueryBuilder {
            meter_id_: Option<String>,
            grouping_: Option<ConsumptionGroupings>,
            start_at_: Option<DateTime>,
            first_: Option<i32>,
            timezone_: Option<String>,
            after_: Option<String>,
        }
        
        impl QueryBuilder {
            pub fn with_meter_id(mut self, value: String) -> Self {
                self.meter_id_ = Some(value);
                self
            }
            
            pub fn with_grouping(mut self, value: ConsumptionGroupings) -> Self {
                self.grouping_ = Some(value);
                self
            }
            
            pub fn with_start_at(mut self, value: DateTime) -> Self {
                self.start_at_ = Some(value);
                self
            }
            
            pub fn with_first(mut self, value: i32) -> Self {
                self.first_ = Some(value);
                self
            }
            
            pub fn with_timezone(mut self, value: String) -> Self {
                self.timezone_ = Some(value);
                self
            }
            
            pub fn with_after(mut self, value: String) -> Self {
                self.after_ = Some(value);
                self
            }
            
            pub fn build(self) -> Result<Query, sparko_graphql::error::Error> {
                if let None = self.meter_id_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("meterId"))
                }
                if let None = self.grouping_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("grouping"))
                }
                if let None = self.start_at_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("startAt"))
                }
                if let None = self.timezone_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("timezone"))
                }
                Ok(Query::from(Variables {
                    meter_id_: self.meter_id_.unwrap(),
                    grouping_: self.grouping_.unwrap(),
                    start_at_: self.start_at_.unwrap(),
                    first_: self.first_,
                    timezone_: self.timezone_.unwrap(),
                    after_: self.after_,
                    }))
            }
        }
        
        impl GraphQLQuery<Response> for Query {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("query meterConsumption");
                buf.push('(');
                self.variables.get_formal_params(&mut buf);
                buf.push(')');
                buf.push('{');
                    buf.push_str("node\n");
                    buf.push('(');
                        buf.push_str("id: $meterId,\n");
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("... on ElectricityMeterType {\n");
                            buf.push_str("...meterFields\n");
                            buf.push_str("importMeter: importMeter\n");
                            buf.push('{');
                                buf.push_str("id\n");
                            buf.push('}');
                            buf.push_str("__typename\n");
                        buf.push('}');
                        buf.push_str("... on GasMeterType {\n");
                            buf.push_str("...meterFields\n");
                            buf.push_str("__typename\n");
                        buf.push('}');
                        buf.push_str("__typename\n");
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment meterFields on Meter\n");
                buf.push('{');
                    buf.push_str("consumptionUnits\n");
                    buf.push_str("consumption\n");
                    buf.push('(');
                        if self.variables.first_.is_some() {
                            buf.push_str("first: $first,\n");
                        }
                        buf.push_str("grouping: $grouping,\n");
                        buf.push_str("startAt: $startAt,\n");
                        buf.push_str("timezone: $timezone,\n");
                        if self.variables.after_.is_some() {
                            buf.push_str("after: $after,\n");
                        }
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("...consumptionFields\n");
                        buf.push_str("__typename\n");
                    buf.push('}');
                    buf.push_str("serialNumber\n");
                buf.push('}');
                
                buf.push_str("fragment consumptionFields on ConsumptionConnection\n");
                buf.push('{');
                    buf.push_str("edges\n");
                    buf.push('{');
                        buf.push_str("node\n");
                        buf.push('{');
                            buf.push_str("value\n");
                            buf.push_str("startAt\n");
                            buf.push_str("endAt\n");
                        buf.push('}');
                        buf.push_str("cursor\n");
                    buf.push('}');
                    buf.push_str("pageInfo\n");
                    buf.push('{');
                        buf.push_str("endCursor\n");
                        buf.push_str("hasNextPage\n");
                    buf.push('}');
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                serde_json::to_string_pretty(&self.variables)
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
} // End of executable_document meter
pub mod bill {
    // Start dependencies
    // End dependencies
    pub mod get_bills {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::Date;
        use super::super::BillTypeEnum;
        use super::super::StatementReversalsAfterClose;
        use super::super::AccountStatementStatus;
        // Start dependencies
        // generate name=HeldStatus id=51, selection.name=HeldStatus
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct HeldStatus {
            #[serde(rename = "isHeld")]
            pub is_held_: bool, // T1
            #[serde(rename = "reason")]
            pub reason_: Option<String>, // T1
        }
        
        // generate name=StatementTotalType id=52, selection.name=StatementTotalType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct StatementTotalType {
            #[serde(rename = "netTotal")]
            pub net_total_: i32, // T1
            #[serde(rename = "taxTotal")]
            pub tax_total_: i32, // T1
            #[serde(rename = "grossTotal")]
            pub gross_total_: i32, // T1
        }
        
        // generate name=StatementType id=53, selection.name=StatementType
        // generate name=PeriodBasedDocumentType id=54, selection.name=PeriodBasedDocumentType
        // generate name=InvoiceType id=55, selection.name=InvoiceType
        // generate name=BillInterface id=56, selection.name=BillInterface
        // implemented_by ["StatementType", "PreKrakenBillType", "PeriodBasedDocumentType", "InvoiceType"]
        /* 3 variants 4 implementors */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(tag = "__typename")]
        pub enum BillInterface {
        /* variants
        StatementType Variant { index: 53, name: "StatementType", fields: {"closingBalance": SelectionField { name: "closingBalance", selection_type: BuiltinType(Int), force_nonnull: true }, "openingBalance": SelectionField { name: "openingBalance", selection_type: BuiltinType(Int), force_nonnull: true }, "isExternalBill": SelectionField { name: "isExternalBill", selection_type: BuiltinType(Boolean), force_nonnull: true }, "userId": SelectionField { name: "userId", selection_type: BuiltinType(Int), force_nonnull: true }, "toAddress": SelectionField { name: "toAddress", selection_type: BuiltinType(String), force_nonnull: true }, "paymentDueDate": SelectionField { name: "paymentDueDate", selection_type: Scalar("Date"), force_nonnull: true }, "reversalsAfterClose": SelectionField { name: "reversalsAfterClose", selection_type: Required(Enum("StatementReversalsAfterClose")), force_nonnull: true }, "status": SelectionField { name: "status", selection_type: Enum("AccountStatementStatus"), force_nonnull: true }, "heldStatus": SelectionField { name: "heldStatus", selection_type: Selection(51), force_nonnull: true }, "totalCharges": SelectionField { name: "totalCharges", selection_type: Selection(52), force_nonnull: true }, "totalCredits": SelectionField { name: "totalCredits", selection_type: Selection(52), force_nonnull: true }}, type_condition: "StatementType" }
        PeriodBasedDocumentType Variant { index: 54, name: "PeriodBasedDocumentType", fields: {"identifier": SelectionField { name: "identifier", selection_type: BuiltinType(ID), force_nonnull: false }, "totalCharges": SelectionField { name: "totalCharges", selection_type: Selection(52), force_nonnull: true }, "totalCredits": SelectionField { name: "totalCredits", selection_type: Selection(52), force_nonnull: true }}, type_condition: "PeriodBasedDocumentType" }
        InvoiceType Variant { index: 55, name: "InvoiceType", fields: {"grossAmount": SelectionField { name: "grossAmount", selection_type: BuiltinType(Int), force_nonnull: true }}, type_condition: "InvoiceType" }
        */
            StatementType(StatementType),
            PreKrakenBillType(AbstractBillInterface),
            PeriodBasedDocumentType(PeriodBasedDocumentType),
            InvoiceType(InvoiceType),
        }
        
        impl BillInterface {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                match self {
                    BillInterface::StatementType(content) => content.as_bill_interface(),
                    BillInterface::PreKrakenBillType(content) => content,
                    BillInterface::PeriodBasedDocumentType(content) => content.as_bill_interface(),
                    BillInterface::InvoiceType(content) => content.as_bill_interface(),
                }
            }
            
        }
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AbstractBillInterface {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "billType")]
            pub bill_type_: BillTypeEnum, // T1
            #[serde(rename = "fromDate")]
            pub from_date_: Date, // T1
            #[serde(rename = "toDate")]
            pub to_date_: Date, // T1
            #[serde(rename = "issuedDate")]
            pub issued_date_: Date, // T1
        }
        
        impl AbstractBillInterface {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                self
            }
        }
        
        // Variant names "StatementType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "StatementType")]
        pub struct StatementType {
            #[serde(flatten)]
            pub bill_interface_: AbstractBillInterface,
            #[serde(rename = "closingBalance")]
            pub closing_balance_: i32, // T1
            #[serde(rename = "openingBalance")]
            pub opening_balance_: i32, // T1
            #[serde(rename = "isExternalBill")]
            pub is_external_bill_: bool, // T1
            #[serde(rename = "userId")]
            pub user_id_: i32, // T1
            #[serde(rename = "toAddress")]
            pub to_address_: String, // T1
            #[serde(rename = "paymentDueDate")]
            pub payment_due_date_: Date, // T1
            #[serde(rename = "reversalsAfterClose")]
            pub reversals_after_close_: StatementReversalsAfterClose, // T1
            #[serde(rename = "status")]
            pub status_: AccountStatementStatus, // T1
            #[serde(rename = "heldStatus")]
            pub held_status_: HeldStatus, // T1
            #[serde(rename = "totalCharges")]
            pub total_charges_: StatementTotalType, // T1
            #[serde(rename = "totalCredits")]
            pub total_credits_: StatementTotalType, // T1
        }
        
        impl StatementType {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                &self.bill_interface_
            }
        }
        
        // Variant names "PeriodBasedDocumentType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "PeriodBasedDocumentType")]
        pub struct PeriodBasedDocumentType {
            #[serde(flatten)]
            pub bill_interface_: AbstractBillInterface,
            #[serde(rename = "identifier")]
            pub identifier_: Option<String>, // T1
            #[serde(rename = "totalCharges")]
            pub total_charges_: StatementTotalType, // T1
            #[serde(rename = "totalCredits")]
            pub total_credits_: StatementTotalType, // T1
        }
        
        impl PeriodBasedDocumentType {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                &self.bill_interface_
            }
        }
        
        // Variant names "InvoiceType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "InvoiceType")]
        pub struct InvoiceType {
            #[serde(flatten)]
            pub bill_interface_: AbstractBillInterface,
            #[serde(rename = "grossAmount")]
            pub gross_amount_: i32, // T1
        }
        
        impl InvoiceType {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                &self.bill_interface_
            }
        }
        
        // generate name=AccountType id=57, selection.name=AccountType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AccountType {
            #[serde(rename = "bills")]
            pub bills_: sparko_graphql::types::ReversePageOf<BillInterface>, // T1
        }
        
        // generate name=Response id=58, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "account")]
            pub account_: AccountType, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Variables {
            #[serde(rename = "accountNumber")]
            account_number_: String,
            #[serde(rename = "includeBillsWithoutPDF")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_bills_without_pdf_: Option<bool>,
            #[serde(rename = "includeOpenStatements")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_open_statements_: Option<bool>,
            #[serde(rename = "includeHeldStatements")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_held_statements_: Option<bool>,
            #[serde(rename = "includeHistoricStatements")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_historic_statements_: Option<bool>,
            #[serde(rename = "onlyCurrentEmail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            only_current_email_: Option<bool>,
            #[serde(rename = "fromDate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            from_date_: Option<Date>,
            #[serde(rename = "toDate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            to_date_: Option<Date>,
            #[serde(rename = "issuedFromDate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            issued_from_date_: Option<Date>,
            #[serde(rename = "issuedToDate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            issued_to_date_: Option<Date>,
            #[serde(rename = "offset")]
            #[serde(skip_serializing_if = "Option::is_none")]
            offset_: Option<i32>,
            #[serde(rename = "before")]
            #[serde(skip_serializing_if = "Option::is_none")]
            before_: Option<String>,
            #[serde(rename = "after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            after_: Option<String>,
            #[serde(rename = "first")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_: Option<i32>,
            #[serde(rename = "last")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_: Option<i32>,
        }
        
        impl Variables {
            pub fn get_formal_params(&self, buf: &mut String) {
                buf.push_str("$accountNumber: String!,");
                if self.include_bills_without_pdf_.is_some() {
                    buf.push_str("$includeBillsWithoutPDF: Boolean,");
                }
                if self.include_open_statements_.is_some() {
                    buf.push_str("$includeOpenStatements: Boolean,");
                }
                if self.include_held_statements_.is_some() {
                    buf.push_str("$includeHeldStatements: Boolean,");
                }
                if self.include_historic_statements_.is_some() {
                    buf.push_str("$includeHistoricStatements: Boolean,");
                }
                if self.only_current_email_.is_some() {
                    buf.push_str("$onlyCurrentEmail: Boolean,");
                }
                if self.from_date_.is_some() {
                    buf.push_str("$fromDate: Date,");
                }
                if self.to_date_.is_some() {
                    buf.push_str("$toDate: Date,");
                }
                if self.issued_from_date_.is_some() {
                    buf.push_str("$issuedFromDate: Date,");
                }
                if self.issued_to_date_.is_some() {
                    buf.push_str("$issuedToDate: Date,");
                }
                if self.offset_.is_some() {
                    buf.push_str("$offset: Int,");
                }
                if self.before_.is_some() {
                    buf.push_str("$before: String,");
                }
                if self.after_.is_some() {
                    buf.push_str("$after: String,");
                }
                if self.first_.is_some() {
                    buf.push_str("$first: Int,");
                }
                if self.last_.is_some() {
                    buf.push_str("$last: Int,");
                }
            }
        }
        
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Query {
            variables: Variables,
        }
        
        impl Query {
            const REQUEST_NAME: &str = "getBills";
            
            pub fn from(variables: Variables) -> Query {
                Query {variables}
            }
            
            pub fn new(
                account_number_: String,
                include_bills_without_pdf_: Option<bool>,
                include_open_statements_: Option<bool>,
                include_held_statements_: Option<bool>,
                include_historic_statements_: Option<bool>,
                only_current_email_: Option<bool>,
                from_date_: Option<Date>,
                to_date_: Option<Date>,
                issued_from_date_: Option<Date>,
                issued_to_date_: Option<Date>,
                offset_: Option<i32>,
                before_: Option<String>,
                after_: Option<String>,
                first_: Option<i32>,
                last_: Option<i32>,
            ) -> Query {
                Query {
                variables: Variables {
                    account_number_,
                    include_bills_without_pdf_,
                    include_open_statements_,
                    include_held_statements_,
                    include_historic_statements_,
                    only_current_email_,
                    from_date_,
                    to_date_,
                    issued_from_date_,
                    issued_to_date_,
                    offset_,
                    before_,
                    after_,
                    first_,
                    last_,
                }
                }
            }
            pub fn builder() -> QueryBuilder {
                QueryBuilder {
                    account_number_: None,
                    include_bills_without_pdf_: None,
                    include_open_statements_: None,
                    include_held_statements_: None,
                    include_historic_statements_: None,
                    only_current_email_: None,
                    from_date_: None,
                    to_date_: None,
                    issued_from_date_: None,
                    issued_to_date_: None,
                    offset_: None,
                    before_: None,
                    after_: None,
                    first_: None,
                    last_: None,
                }
            }
        } // End of Query
        
        
        pub struct QueryBuilder {
            account_number_: Option<String>,
            include_bills_without_pdf_: Option<bool>,
            include_open_statements_: Option<bool>,
            include_held_statements_: Option<bool>,
            include_historic_statements_: Option<bool>,
            only_current_email_: Option<bool>,
            from_date_: Option<Date>,
            to_date_: Option<Date>,
            issued_from_date_: Option<Date>,
            issued_to_date_: Option<Date>,
            offset_: Option<i32>,
            before_: Option<String>,
            after_: Option<String>,
            first_: Option<i32>,
            last_: Option<i32>,
        }
        
        impl QueryBuilder {
            pub fn with_account_number(mut self, value: String) -> Self {
                self.account_number_ = Some(value);
                self
            }
            
            pub fn with_include_bills_without_pdf(mut self, value: bool) -> Self {
                self.include_bills_without_pdf_ = Some(value);
                self
            }
            
            pub fn with_include_open_statements(mut self, value: bool) -> Self {
                self.include_open_statements_ = Some(value);
                self
            }
            
            pub fn with_include_held_statements(mut self, value: bool) -> Self {
                self.include_held_statements_ = Some(value);
                self
            }
            
            pub fn with_include_historic_statements(mut self, value: bool) -> Self {
                self.include_historic_statements_ = Some(value);
                self
            }
            
            pub fn with_only_current_email(mut self, value: bool) -> Self {
                self.only_current_email_ = Some(value);
                self
            }
            
            pub fn with_from_date(mut self, value: Date) -> Self {
                self.from_date_ = Some(value);
                self
            }
            
            pub fn with_to_date(mut self, value: Date) -> Self {
                self.to_date_ = Some(value);
                self
            }
            
            pub fn with_issued_from_date(mut self, value: Date) -> Self {
                self.issued_from_date_ = Some(value);
                self
            }
            
            pub fn with_issued_to_date(mut self, value: Date) -> Self {
                self.issued_to_date_ = Some(value);
                self
            }
            
            pub fn with_offset(mut self, value: i32) -> Self {
                self.offset_ = Some(value);
                self
            }
            
            pub fn with_before(mut self, value: String) -> Self {
                self.before_ = Some(value);
                self
            }
            
            pub fn with_after(mut self, value: String) -> Self {
                self.after_ = Some(value);
                self
            }
            
            pub fn with_first(mut self, value: i32) -> Self {
                self.first_ = Some(value);
                self
            }
            
            pub fn with_last(mut self, value: i32) -> Self {
                self.last_ = Some(value);
                self
            }
            
            pub fn build(self) -> Result<Query, sparko_graphql::error::Error> {
                if let None = self.account_number_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("accountNumber"))
                }
                Ok(Query::from(Variables {
                    account_number_: self.account_number_.unwrap(),
                    include_bills_without_pdf_: self.include_bills_without_pdf_,
                    include_open_statements_: self.include_open_statements_,
                    include_held_statements_: self.include_held_statements_,
                    include_historic_statements_: self.include_historic_statements_,
                    only_current_email_: self.only_current_email_,
                    from_date_: self.from_date_,
                    to_date_: self.to_date_,
                    issued_from_date_: self.issued_from_date_,
                    issued_to_date_: self.issued_to_date_,
                    offset_: self.offset_,
                    before_: self.before_,
                    after_: self.after_,
                    first_: self.first_,
                    last_: self.last_,
                    }))
            }
        }
        
        impl GraphQLQuery<Response> for Query {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("query getBills");
                buf.push('(');
                self.variables.get_formal_params(&mut buf);
                buf.push(')');
                buf.push('{');
                    buf.push_str("account\n");
                    buf.push('(');
                        buf.push_str("accountNumber: $accountNumber,\n");
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("bills\n");
                        buf.push('(');
                            if self.variables.include_bills_without_pdf_.is_some() {
                                buf.push_str("includeBillsWithoutPDF: $includeBillsWithoutPDF,\n");
                            }
                            if self.variables.include_open_statements_.is_some() {
                                buf.push_str("includeOpenStatements: $includeOpenStatements,\n");
                            }
                            if self.variables.include_held_statements_.is_some() {
                                buf.push_str("includeHeldStatements: $includeHeldStatements,\n");
                            }
                            if self.variables.include_historic_statements_.is_some() {
                                buf.push_str("includeHistoricStatements: $includeHistoricStatements,\n");
                            }
                            if self.variables.only_current_email_.is_some() {
                                buf.push_str("onlyCurrentEmail: $onlyCurrentEmail,\n");
                            }
                            if self.variables.from_date_.is_some() {
                                buf.push_str("fromDate: $fromDate,\n");
                            }
                            if self.variables.to_date_.is_some() {
                                buf.push_str("toDate: $toDate,\n");
                            }
                            if self.variables.issued_from_date_.is_some() {
                                buf.push_str("issuedFromDate: $issuedFromDate,\n");
                            }
                            if self.variables.issued_to_date_.is_some() {
                                buf.push_str("issuedToDate: $issuedToDate,\n");
                            }
                            if self.variables.offset_.is_some() {
                                buf.push_str("offset: $offset,\n");
                            }
                            if self.variables.before_.is_some() {
                                buf.push_str("before: $before,\n");
                            }
                            if self.variables.after_.is_some() {
                                buf.push_str("after: $after,\n");
                            }
                            if self.variables.first_.is_some() {
                                buf.push_str("first: $first,\n");
                            }
                            if self.variables.last_.is_some() {
                                buf.push_str("last: $last,\n");
                            }
                        buf.push(')');
                        buf.push('{');
                            buf.push_str("pageInfo\n");
                            buf.push('{');
                                buf.push_str("startCursor\n");
                                buf.push_str("hasPreviousPage\n");
                            buf.push('}');
                            buf.push_str("edges\n");
                            buf.push('{');
                                buf.push_str("cursor\n");
                                buf.push_str("node\n");
                                buf.push('{');
                                    buf.push_str("id\n");
                                    buf.push_str("billType\n");
                                    buf.push_str("fromDate\n");
                                    buf.push_str("toDate\n");
                                    buf.push_str("issuedDate\n");
                                    buf.push_str("...Statement\n");
                                    buf.push_str("...PeriodBasedDocument\n");
                                    buf.push_str("...Invoice\n");
                                    buf.push_str("__typename\n");
                                buf.push('}');
                            buf.push('}');
                        buf.push('}');
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment Statement on StatementType\n");
                buf.push('{');
                    buf.push_str("closingBalance\n");
                    buf.push_str("openingBalance\n");
                    buf.push_str("isExternalBill\n");
                    buf.push_str("userId\n");
                    buf.push_str("toAddress\n");
                    buf.push_str("paymentDueDate\n");
                    buf.push_str("reversalsAfterClose\n");
                    buf.push_str("status\n");
                    buf.push_str("heldStatus\n");
                    buf.push('{');
                        buf.push_str("isHeld\n");
                        buf.push_str("reason\n");
                    buf.push('}');
                    buf.push_str("totalCharges\n");
                    buf.push('{');
                        buf.push_str("netTotal\n");
                        buf.push_str("taxTotal\n");
                        buf.push_str("grossTotal\n");
                    buf.push('}');
                    buf.push_str("totalCredits\n");
                    buf.push('{');
                        buf.push_str("netTotal\n");
                        buf.push_str("taxTotal\n");
                        buf.push_str("grossTotal\n");
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment PeriodBasedDocument on PeriodBasedDocumentType\n");
                buf.push('{');
                    buf.push_str("identifier\n");
                    buf.push_str("totalCharges\n");
                    buf.push('{');
                        buf.push_str("netTotal\n");
                        buf.push_str("taxTotal\n");
                        buf.push_str("grossTotal\n");
                    buf.push('}');
                    buf.push_str("totalCredits\n");
                    buf.push('{');
                        buf.push_str("netTotal\n");
                        buf.push_str("taxTotal\n");
                        buf.push_str("grossTotal\n");
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment Invoice on InvoiceType\n");
                buf.push('{');
                    buf.push_str("grossAmount\n");
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                serde_json::to_string_pretty(&self.variables)
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
    pub mod get_statement_transactions {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::Date;
        use super::super::DateTime;
        use super::super::Decimal;
        use super::super::ConsumptionUnit;
        // Start dependencies
        // generate name=TransactionAmountType id=59, selection.name=TransactionAmountType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct TransactionAmountType {
            #[serde(rename = "net")]
            pub net_: i32, // T1
            #[serde(rename = "tax")]
            pub tax_: i32, // T1
            #[serde(rename = "gross")]
            pub gross_: i32, // T1
        }
        
        // generate name=Consumption id=60, selection.name=Consumption
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Consumption {
            #[serde(rename = "startDate")]
            pub start_date_: Date, // T1
            #[serde(rename = "endDate")]
            pub end_date_: Date, // T1
            #[serde(rename = "quantity")]
            pub quantity_: Decimal, // T1
            #[serde(rename = "unit")]
            pub unit_: ConsumptionUnit, // T1
            #[serde(rename = "usageCost")]
            pub usage_cost_: i32, // T1
            #[serde(rename = "supplyCharge")]
            pub supply_charge_: i32, // T1
        }
        
        // generate name=Charge id=61, selection.name=Charge
        // generate name=TransactionType id=62, selection.name=TransactionType
        // implemented_by ["Charge", "Payment", "Refund", "Credit"]
        /* 1 variants 4 implementors */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(tag = "__typename")]
        pub enum TransactionType {
        /* variants
        Charge Variant { index: 61, name: "Charge", fields: {"consumption": SelectionField { name: "consumption", selection_type: Selection(60), force_nonnull: false }, "isExport": SelectionField { name: "isExport", selection_type: BuiltinType(Boolean), force_nonnull: true }}, type_condition: "Charge" }
        */
            Charge(Charge),
            Payment(AbstractTransactionType),
            Refund(AbstractTransactionType),
            Credit(AbstractTransactionType),
        }
        
        impl TransactionType {
            pub fn as_transaction_type(&self) -> &AbstractTransactionType {
                match self {
                    TransactionType::Charge(content) => content.as_transaction_type(),
                    TransactionType::Payment(content) => content,
                    TransactionType::Refund(content) => content,
                    TransactionType::Credit(content) => content,
                }
            }
            
        }
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AbstractTransactionType {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "postedDate")]
            pub posted_date_: Date, // T1
            #[serde(rename = "createdAt")]
            pub created_at_: DateTime, // T1
            #[serde(rename = "accountNumber")]
            pub account_number_: String, // T1
            #[serde(rename = "amounts")]
            pub amounts_: TransactionAmountType, // T1
            #[serde(rename = "balanceCarriedForward")]
            pub balance_carried_forward_: i32, // T1
            #[serde(rename = "isHeld")]
            pub is_held_: bool, // T1
            #[serde(rename = "isIssued")]
            pub is_issued_: bool, // T1
            #[serde(rename = "title")]
            pub title_: String, // T1
            #[serde(rename = "billingDocumentIdentifier")]
            pub billing_document_identifier_: String, // T1
            #[serde(rename = "isReversed")]
            pub is_reversed_: bool, // T1
            #[serde(rename = "hasStatement")]
            pub has_statement_: bool, // T1
            #[serde(rename = "note")]
            pub note_: Option<String>, // T1
        }
        
        impl AbstractTransactionType {
            pub fn as_transaction_type(&self) -> &AbstractTransactionType {
                self
            }
        }
        
        // Variant names "Charge"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "Charge")]
        pub struct Charge {
            #[serde(flatten)]
            pub transaction_type_: AbstractTransactionType,
            #[serde(rename = "consumption")]
            pub consumption_: Option<Consumption>, // T1
            #[serde(rename = "isExport")]
            pub is_export_: bool, // T1
        }
        
        impl Charge {
            pub fn as_transaction_type(&self) -> &AbstractTransactionType {
                &self.transaction_type_
            }
        }
        
        // generate name=StatementType id=63, selection.name=StatementType
        // generate name=BillInterface id=64, selection.name=BillInterface
        // implemented_by ["StatementType", "PreKrakenBillType", "PeriodBasedDocumentType", "InvoiceType"]
        /* 1 variants 4 implementors */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(tag = "__typename")]
        pub enum BillInterface {
        /* variants
        StatementType Variant { index: 63, name: "StatementType", fields: {"transactions": SelectionField { name: "transactions", selection_type: ReversePageOf(Selection(62)), force_nonnull: true }}, type_condition: "StatementType" }
        */
            StatementType(StatementType),
            PreKrakenBillType(AbstractBillInterface),
            PeriodBasedDocumentType(AbstractBillInterface),
            InvoiceType(AbstractBillInterface),
        }
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AbstractBillInterface {
        }
        
        impl AbstractBillInterface {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                self
            }
        }
        
        // Variant names "StatementType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "StatementType")]
        pub struct StatementType {
            #[serde(rename = "transactions")]
            pub transactions_: sparko_graphql::types::ReversePageOf<TransactionType>, // T1
        }
        
        // generate name=AccountType id=65, selection.name=AccountType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AccountType {
            #[serde(rename = "bill")]
            pub bill_: BillInterface, // T1
        }
        
        // generate name=Response id=66, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "account")]
            pub account_: AccountType, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Variables {
            #[serde(rename = "accountNumber")]
            account_number_: String,
            #[serde(rename = "statementId")]
            statement_id_: String,
            #[serde(rename = "transactions_before")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transactions_before_: Option<String>,
            #[serde(rename = "transactions_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transactions_after_: Option<String>,
            #[serde(rename = "transactions_first")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transactions_first_: Option<i32>,
            #[serde(rename = "transactions_last")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transactions_last_: Option<i32>,
        }
        
        impl Variables {
            pub fn get_formal_params(&self, buf: &mut String) {
                buf.push_str("$accountNumber: String!,");
                buf.push_str("$statementId: ID!,");
                if self.transactions_before_.is_some() {
                    buf.push_str("$transactions_before: String,");
                }
                if self.transactions_after_.is_some() {
                    buf.push_str("$transactions_after: String,");
                }
                if self.transactions_first_.is_some() {
                    buf.push_str("$transactions_first: Int,");
                }
                if self.transactions_last_.is_some() {
                    buf.push_str("$transactions_last: Int,");
                }
            }
        }
        
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Query {
            variables: Variables,
        }
        
        impl Query {
            const REQUEST_NAME: &str = "getStatementTransactions";
            
            pub fn from(variables: Variables) -> Query {
                Query {variables}
            }
            
            pub fn new(
                account_number_: String,
                statement_id_: String,
                transactions_before_: Option<String>,
                transactions_after_: Option<String>,
                transactions_first_: Option<i32>,
                transactions_last_: Option<i32>,
            ) -> Query {
                Query {
                variables: Variables {
                    account_number_,
                    statement_id_,
                    transactions_before_,
                    transactions_after_,
                    transactions_first_,
                    transactions_last_,
                }
                }
            }
            pub fn builder() -> QueryBuilder {
                QueryBuilder {
                    account_number_: None,
                    statement_id_: None,
                    transactions_before_: None,
                    transactions_after_: None,
                    transactions_first_: None,
                    transactions_last_: None,
                }
            }
        } // End of Query
        
        
        pub struct QueryBuilder {
            account_number_: Option<String>,
            statement_id_: Option<String>,
            transactions_before_: Option<String>,
            transactions_after_: Option<String>,
            transactions_first_: Option<i32>,
            transactions_last_: Option<i32>,
        }
        
        impl QueryBuilder {
            pub fn with_account_number(mut self, value: String) -> Self {
                self.account_number_ = Some(value);
                self
            }
            
            pub fn with_statement_id(mut self, value: String) -> Self {
                self.statement_id_ = Some(value);
                self
            }
            
            pub fn with_transactions_before(mut self, value: String) -> Self {
                self.transactions_before_ = Some(value);
                self
            }
            
            pub fn with_transactions_after(mut self, value: String) -> Self {
                self.transactions_after_ = Some(value);
                self
            }
            
            pub fn with_transactions_first(mut self, value: i32) -> Self {
                self.transactions_first_ = Some(value);
                self
            }
            
            pub fn with_transactions_last(mut self, value: i32) -> Self {
                self.transactions_last_ = Some(value);
                self
            }
            
            pub fn build(self) -> Result<Query, sparko_graphql::error::Error> {
                if let None = self.account_number_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("accountNumber"))
                }
                if let None = self.statement_id_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("statementId"))
                }
                Ok(Query::from(Variables {
                    account_number_: self.account_number_.unwrap(),
                    statement_id_: self.statement_id_.unwrap(),
                    transactions_before_: self.transactions_before_,
                    transactions_after_: self.transactions_after_,
                    transactions_first_: self.transactions_first_,
                    transactions_last_: self.transactions_last_,
                    }))
            }
        }
        
        impl GraphQLQuery<Response> for Query {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("query getStatementTransactions");
                buf.push('(');
                self.variables.get_formal_params(&mut buf);
                buf.push(')');
                buf.push('{');
                    buf.push_str("account\n");
                    buf.push('(');
                        buf.push_str("accountNumber: $accountNumber,\n");
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("bill\n");
                        buf.push('(');
                            buf.push_str("id: $statementId,\n");
                            buf.push_str("billType: STATEMENT,\n");
                        buf.push(')');
                        buf.push('{');
                            buf.push_str("...StatementTransactions\n");
                            buf.push_str("__typename\n");
                        buf.push('}');
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment StatementTransactions on StatementType\n");
                buf.push('{');
                    buf.push_str("transactions\n");
                    buf.push('(');
                        if self.variables.transactions_before_.is_some() {
                            buf.push_str("before: $transactions_before,\n");
                        }
                        if self.variables.transactions_after_.is_some() {
                            buf.push_str("after: $transactions_after,\n");
                        }
                        if self.variables.transactions_first_.is_some() {
                            buf.push_str("first: $transactions_first,\n");
                        }
                        if self.variables.transactions_last_.is_some() {
                            buf.push_str("last: $transactions_last,\n");
                        }
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("pageInfo\n");
                        buf.push('{');
                            buf.push_str("startCursor\n");
                            buf.push_str("hasPreviousPage\n");
                        buf.push('}');
                        buf.push_str("edges\n");
                        buf.push('{');
                            buf.push_str("cursor\n");
                            buf.push_str("node\n");
                            buf.push('{');
                                buf.push_str("id\n");
                                buf.push_str("postedDate\n");
                                buf.push_str("createdAt\n");
                                buf.push_str("accountNumber\n");
                                buf.push_str("amounts\n");
                                buf.push('{');
                                    buf.push_str("net\n");
                                    buf.push_str("tax\n");
                                    buf.push_str("gross\n");
                                buf.push('}');
                                buf.push_str("balanceCarriedForward\n");
                                buf.push_str("isHeld\n");
                                buf.push_str("isIssued\n");
                                buf.push_str("title\n");
                                buf.push_str("billingDocumentIdentifier\n");
                                buf.push_str("isReversed\n");
                                buf.push_str("hasStatement\n");
                                buf.push_str("note\n");
                                buf.push_str("...Charge\n");
                                buf.push_str("__typename\n");
                            buf.push('}');
                        buf.push('}');
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment Charge on Charge\n");
                buf.push('{');
                    buf.push_str("consumption\n");
                    buf.push('{');
                        buf.push_str("startDate\n");
                        buf.push_str("endDate\n");
                        buf.push_str("quantity\n");
                        buf.push_str("unit\n");
                        buf.push_str("usageCost\n");
                        buf.push_str("supplyCharge\n");
                    buf.push('}');
                    buf.push_str("isExport\n");
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                serde_json::to_string_pretty(&self.variables)
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
    pub mod get_bills_and_transactions {
        
        use display_json::DisplayAsJsonPretty;
        use serde::{Deserialize, Serialize};
        use sparko_graphql::{GraphQLResponse, GraphQLQuery};
        
        use super::super::Date;
        use super::super::BillTypeEnum;
        use super::super::StatementReversalsAfterClose;
        use super::super::AccountStatementStatus;
        use super::super::DateTime;
        use super::super::Decimal;
        use super::super::ConsumptionUnit;
        // Start dependencies
        // generate name=HeldStatus id=51, selection.name=HeldStatus
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct HeldStatus {
            #[serde(rename = "isHeld")]
            pub is_held_: bool, // T1
            #[serde(rename = "reason")]
            pub reason_: Option<String>, // T1
        }
        
        // generate name=StatementTotalType id=52, selection.name=StatementTotalType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct StatementTotalType {
            #[serde(rename = "netTotal")]
            pub net_total_: i32, // T1
            #[serde(rename = "taxTotal")]
            pub tax_total_: i32, // T1
            #[serde(rename = "grossTotal")]
            pub gross_total_: i32, // T1
        }
        
        // generate name=TransactionAmountType id=59, selection.name=TransactionAmountType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct TransactionAmountType {
            #[serde(rename = "net")]
            pub net_: i32, // T1
            #[serde(rename = "tax")]
            pub tax_: i32, // T1
            #[serde(rename = "gross")]
            pub gross_: i32, // T1
        }
        
        // generate name=Consumption id=60, selection.name=Consumption
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Consumption {
            #[serde(rename = "startDate")]
            pub start_date_: Date, // T1
            #[serde(rename = "endDate")]
            pub end_date_: Date, // T1
            #[serde(rename = "quantity")]
            pub quantity_: Decimal, // T1
            #[serde(rename = "unit")]
            pub unit_: ConsumptionUnit, // T1
            #[serde(rename = "usageCost")]
            pub usage_cost_: i32, // T1
            #[serde(rename = "supplyCharge")]
            pub supply_charge_: i32, // T1
        }
        
        // generate name=Charge id=67, selection.name=Charge
        // generate name=TransactionType id=68, selection.name=TransactionType
        // implemented_by ["Charge", "Payment", "Refund", "Credit"]
        /* 1 variants 4 implementors */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(tag = "__typename")]
        pub enum TransactionType {
        /* variants
        Charge Variant { index: 67, name: "Charge", fields: {"consumption": SelectionField { name: "consumption", selection_type: Selection(60), force_nonnull: false }, "isExport": SelectionField { name: "isExport", selection_type: BuiltinType(Boolean), force_nonnull: true }}, type_condition: "Charge" }
        */
            Charge(Charge),
            Payment(AbstractTransactionType),
            Refund(AbstractTransactionType),
            Credit(AbstractTransactionType),
        }
        
        impl TransactionType {
            pub fn as_transaction_type(&self) -> &AbstractTransactionType {
                match self {
                    TransactionType::Charge(content) => content.as_transaction_type(),
                    TransactionType::Payment(content) => content,
                    TransactionType::Refund(content) => content,
                    TransactionType::Credit(content) => content,
                }
            }
            
        }
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AbstractTransactionType {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "postedDate")]
            pub posted_date_: Date, // T1
            #[serde(rename = "createdAt")]
            pub created_at_: DateTime, // T1
            #[serde(rename = "accountNumber")]
            pub account_number_: String, // T1
            #[serde(rename = "amounts")]
            pub amounts_: TransactionAmountType, // T1
            #[serde(rename = "balanceCarriedForward")]
            pub balance_carried_forward_: i32, // T1
            #[serde(rename = "isHeld")]
            pub is_held_: bool, // T1
            #[serde(rename = "isIssued")]
            pub is_issued_: bool, // T1
            #[serde(rename = "title")]
            pub title_: String, // T1
            #[serde(rename = "billingDocumentIdentifier")]
            pub billing_document_identifier_: String, // T1
            #[serde(rename = "isReversed")]
            pub is_reversed_: bool, // T1
            #[serde(rename = "hasStatement")]
            pub has_statement_: bool, // T1
            #[serde(rename = "note")]
            pub note_: Option<String>, // T1
        }
        
        impl AbstractTransactionType {
            pub fn as_transaction_type(&self) -> &AbstractTransactionType {
                self
            }
        }
        
        // Variant names "Charge"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "Charge")]
        pub struct Charge {
            #[serde(flatten)]
            pub transaction_type_: AbstractTransactionType,
            #[serde(rename = "consumption")]
            pub consumption_: Option<Consumption>, // T1
            #[serde(rename = "isExport")]
            pub is_export_: bool, // T1
        }
        
        impl Charge {
            pub fn as_transaction_type(&self) -> &AbstractTransactionType {
                &self.transaction_type_
            }
        }
        
        // generate name=StatementType id=69, selection.name=StatementType
        // generate name=PeriodBasedDocumentType id=70, selection.name=PeriodBasedDocumentType
        // generate name=InvoiceType id=71, selection.name=InvoiceType
        // generate name=BillInterface id=72, selection.name=BillInterface
        // implemented_by ["StatementType", "PreKrakenBillType", "PeriodBasedDocumentType", "InvoiceType"]
        /* 3 variants 4 implementors */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(tag = "__typename")]
        pub enum BillInterface {
        /* variants
        StatementType Variant { index: 69, name: "StatementType", fields: {"closingBalance": SelectionField { name: "closingBalance", selection_type: BuiltinType(Int), force_nonnull: true }, "openingBalance": SelectionField { name: "openingBalance", selection_type: BuiltinType(Int), force_nonnull: true }, "isExternalBill": SelectionField { name: "isExternalBill", selection_type: BuiltinType(Boolean), force_nonnull: true }, "userId": SelectionField { name: "userId", selection_type: BuiltinType(Int), force_nonnull: true }, "toAddress": SelectionField { name: "toAddress", selection_type: BuiltinType(String), force_nonnull: true }, "paymentDueDate": SelectionField { name: "paymentDueDate", selection_type: Scalar("Date"), force_nonnull: true }, "reversalsAfterClose": SelectionField { name: "reversalsAfterClose", selection_type: Required(Enum("StatementReversalsAfterClose")), force_nonnull: true }, "status": SelectionField { name: "status", selection_type: Enum("AccountStatementStatus"), force_nonnull: true }, "heldStatus": SelectionField { name: "heldStatus", selection_type: Selection(51), force_nonnull: true }, "totalCharges": SelectionField { name: "totalCharges", selection_type: Selection(52), force_nonnull: true }, "totalCredits": SelectionField { name: "totalCredits", selection_type: Selection(52), force_nonnull: true }, "transactions": SelectionField { name: "transactions", selection_type: ReversePageOf(Selection(68)), force_nonnull: true }}, type_condition: "StatementType" }
        PeriodBasedDocumentType Variant { index: 70, name: "PeriodBasedDocumentType", fields: {"identifier": SelectionField { name: "identifier", selection_type: BuiltinType(ID), force_nonnull: false }, "totalCharges": SelectionField { name: "totalCharges", selection_type: Selection(52), force_nonnull: true }, "totalCredits": SelectionField { name: "totalCredits", selection_type: Selection(52), force_nonnull: true }}, type_condition: "PeriodBasedDocumentType" }
        InvoiceType Variant { index: 71, name: "InvoiceType", fields: {"grossAmount": SelectionField { name: "grossAmount", selection_type: BuiltinType(Int), force_nonnull: true }}, type_condition: "InvoiceType" }
        */
            StatementType(StatementType),
            PreKrakenBillType(AbstractBillInterface),
            PeriodBasedDocumentType(PeriodBasedDocumentType),
            InvoiceType(InvoiceType),
        }
        
        impl BillInterface {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                match self {
                    BillInterface::StatementType(content) => content.as_bill_interface(),
                    BillInterface::PreKrakenBillType(content) => content,
                    BillInterface::PeriodBasedDocumentType(content) => content.as_bill_interface(),
                    BillInterface::InvoiceType(content) => content.as_bill_interface(),
                }
            }
            
        }
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AbstractBillInterface {
            #[serde(rename = "id")]
            pub id_: String, // T1
            #[serde(rename = "billType")]
            pub bill_type_: BillTypeEnum, // T1
            #[serde(rename = "fromDate")]
            pub from_date_: Date, // T1
            #[serde(rename = "toDate")]
            pub to_date_: Date, // T1
            #[serde(rename = "issuedDate")]
            pub issued_date_: Date, // T1
        }
        
        impl AbstractBillInterface {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                self
            }
        }
        
        // Variant names "StatementType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "StatementType")]
        pub struct StatementType {
            #[serde(flatten)]
            pub bill_interface_: AbstractBillInterface,
            #[serde(rename = "closingBalance")]
            pub closing_balance_: i32, // T1
            #[serde(rename = "openingBalance")]
            pub opening_balance_: i32, // T1
            #[serde(rename = "isExternalBill")]
            pub is_external_bill_: bool, // T1
            #[serde(rename = "userId")]
            pub user_id_: i32, // T1
            #[serde(rename = "toAddress")]
            pub to_address_: String, // T1
            #[serde(rename = "paymentDueDate")]
            pub payment_due_date_: Date, // T1
            #[serde(rename = "reversalsAfterClose")]
            pub reversals_after_close_: StatementReversalsAfterClose, // T1
            #[serde(rename = "status")]
            pub status_: AccountStatementStatus, // T1
            #[serde(rename = "heldStatus")]
            pub held_status_: HeldStatus, // T1
            #[serde(rename = "totalCharges")]
            pub total_charges_: StatementTotalType, // T1
            #[serde(rename = "totalCredits")]
            pub total_credits_: StatementTotalType, // T1
            #[serde(rename = "transactions")]
            pub transactions_: sparko_graphql::types::ReversePageOf<TransactionType>, // T1
        }
        
        impl StatementType {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                &self.bill_interface_
            }
        }
        
        // Variant names "PeriodBasedDocumentType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "PeriodBasedDocumentType")]
        pub struct PeriodBasedDocumentType {
            #[serde(flatten)]
            pub bill_interface_: AbstractBillInterface,
            #[serde(rename = "identifier")]
            pub identifier_: Option<String>, // T1
            #[serde(rename = "totalCharges")]
            pub total_charges_: StatementTotalType, // T1
            #[serde(rename = "totalCredits")]
            pub total_credits_: StatementTotalType, // T1
        }
        
        impl PeriodBasedDocumentType {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                &self.bill_interface_
            }
        }
        
        // Variant names "InvoiceType"
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        #[serde(rename = "InvoiceType")]
        pub struct InvoiceType {
            #[serde(flatten)]
            pub bill_interface_: AbstractBillInterface,
            #[serde(rename = "grossAmount")]
            pub gross_amount_: i32, // T1
        }
        
        impl InvoiceType {
            pub fn as_bill_interface(&self) -> &AbstractBillInterface {
                &self.bill_interface_
            }
        }
        
        // generate name=AccountType id=73, selection.name=AccountType
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct AccountType {
            #[serde(rename = "bills")]
            pub bills_: sparko_graphql::types::ForwardPageOf<BillInterface>, // T1
        }
        
        // generate name=Response id=74, selection.name=Response
        /* No variants */
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Response {
            #[serde(rename = "account")]
            pub account_: AccountType, // T1
        }
        
        // End dependencies
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Variables {
            #[serde(rename = "accountNumber")]
            account_number_: String,
            #[serde(rename = "includeBillsWithoutPDF")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_bills_without_pdf_: Option<bool>,
            #[serde(rename = "includeOpenStatements")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_open_statements_: Option<bool>,
            #[serde(rename = "includeHeldStatements")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_held_statements_: Option<bool>,
            #[serde(rename = "includeHistoricStatements")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_historic_statements_: Option<bool>,
            #[serde(rename = "onlyCurrentEmail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            only_current_email_: Option<bool>,
            #[serde(rename = "fromDate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            from_date_: Option<Date>,
            #[serde(rename = "toDate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            to_date_: Option<Date>,
            #[serde(rename = "issuedFromDate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            issued_from_date_: Option<Date>,
            #[serde(rename = "issuedToDate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            issued_to_date_: Option<Date>,
            #[serde(rename = "offset")]
            #[serde(skip_serializing_if = "Option::is_none")]
            offset_: Option<i32>,
            #[serde(rename = "before")]
            #[serde(skip_serializing_if = "Option::is_none")]
            before_: Option<String>,
            #[serde(rename = "after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            after_: Option<String>,
            #[serde(rename = "first")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_: Option<i32>,
            #[serde(rename = "last")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_: Option<i32>,
            #[serde(rename = "transactions_before")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transactions_before_: Option<String>,
            #[serde(rename = "transactions_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transactions_after_: Option<String>,
            #[serde(rename = "transactions_first")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transactions_first_: Option<i32>,
            #[serde(rename = "transactions_last")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transactions_last_: Option<i32>,
        }
        
        impl Variables {
            pub fn get_formal_params(&self, buf: &mut String) {
                buf.push_str("$accountNumber: String!,");
                if self.include_bills_without_pdf_.is_some() {
                    buf.push_str("$includeBillsWithoutPDF: Boolean,");
                }
                if self.include_open_statements_.is_some() {
                    buf.push_str("$includeOpenStatements: Boolean,");
                }
                if self.include_held_statements_.is_some() {
                    buf.push_str("$includeHeldStatements: Boolean,");
                }
                if self.include_historic_statements_.is_some() {
                    buf.push_str("$includeHistoricStatements: Boolean,");
                }
                if self.only_current_email_.is_some() {
                    buf.push_str("$onlyCurrentEmail: Boolean,");
                }
                if self.from_date_.is_some() {
                    buf.push_str("$fromDate: Date,");
                }
                if self.to_date_.is_some() {
                    buf.push_str("$toDate: Date,");
                }
                if self.issued_from_date_.is_some() {
                    buf.push_str("$issuedFromDate: Date,");
                }
                if self.issued_to_date_.is_some() {
                    buf.push_str("$issuedToDate: Date,");
                }
                if self.offset_.is_some() {
                    buf.push_str("$offset: Int,");
                }
                if self.before_.is_some() {
                    buf.push_str("$before: String,");
                }
                if self.after_.is_some() {
                    buf.push_str("$after: String,");
                }
                if self.first_.is_some() {
                    buf.push_str("$first: Int,");
                }
                if self.last_.is_some() {
                    buf.push_str("$last: Int,");
                }
                if self.transactions_before_.is_some() {
                    buf.push_str("$transactions_before: String,");
                }
                if self.transactions_after_.is_some() {
                    buf.push_str("$transactions_after: String,");
                }
                if self.transactions_first_.is_some() {
                    buf.push_str("$transactions_first: Int,");
                }
                if self.transactions_last_.is_some() {
                    buf.push_str("$transactions_last: Int,");
                }
            }
        }
        
        
        #[derive(Serialize, Deserialize, Debug, DisplayAsJsonPretty)]
        pub struct Query {
            variables: Variables,
        }
        
        impl Query {
            const REQUEST_NAME: &str = "getBillsAndTransactions";
            
            pub fn from(variables: Variables) -> Query {
                Query {variables}
            }
            
            pub fn new(
                account_number_: String,
                include_bills_without_pdf_: Option<bool>,
                include_open_statements_: Option<bool>,
                include_held_statements_: Option<bool>,
                include_historic_statements_: Option<bool>,
                only_current_email_: Option<bool>,
                from_date_: Option<Date>,
                to_date_: Option<Date>,
                issued_from_date_: Option<Date>,
                issued_to_date_: Option<Date>,
                offset_: Option<i32>,
                before_: Option<String>,
                after_: Option<String>,
                first_: Option<i32>,
                last_: Option<i32>,
                transactions_before_: Option<String>,
                transactions_after_: Option<String>,
                transactions_first_: Option<i32>,
                transactions_last_: Option<i32>,
            ) -> Query {
                Query {
                variables: Variables {
                    account_number_,
                    include_bills_without_pdf_,
                    include_open_statements_,
                    include_held_statements_,
                    include_historic_statements_,
                    only_current_email_,
                    from_date_,
                    to_date_,
                    issued_from_date_,
                    issued_to_date_,
                    offset_,
                    before_,
                    after_,
                    first_,
                    last_,
                    transactions_before_,
                    transactions_after_,
                    transactions_first_,
                    transactions_last_,
                }
                }
            }
            pub fn builder() -> QueryBuilder {
                QueryBuilder {
                    account_number_: None,
                    include_bills_without_pdf_: None,
                    include_open_statements_: None,
                    include_held_statements_: None,
                    include_historic_statements_: None,
                    only_current_email_: None,
                    from_date_: None,
                    to_date_: None,
                    issued_from_date_: None,
                    issued_to_date_: None,
                    offset_: None,
                    before_: None,
                    after_: None,
                    first_: None,
                    last_: None,
                    transactions_before_: None,
                    transactions_after_: None,
                    transactions_first_: None,
                    transactions_last_: None,
                }
            }
        } // End of Query
        
        
        pub struct QueryBuilder {
            account_number_: Option<String>,
            include_bills_without_pdf_: Option<bool>,
            include_open_statements_: Option<bool>,
            include_held_statements_: Option<bool>,
            include_historic_statements_: Option<bool>,
            only_current_email_: Option<bool>,
            from_date_: Option<Date>,
            to_date_: Option<Date>,
            issued_from_date_: Option<Date>,
            issued_to_date_: Option<Date>,
            offset_: Option<i32>,
            before_: Option<String>,
            after_: Option<String>,
            first_: Option<i32>,
            last_: Option<i32>,
            transactions_before_: Option<String>,
            transactions_after_: Option<String>,
            transactions_first_: Option<i32>,
            transactions_last_: Option<i32>,
        }
        
        impl QueryBuilder {
            pub fn with_account_number(mut self, value: String) -> Self {
                self.account_number_ = Some(value);
                self
            }
            
            pub fn with_include_bills_without_pdf(mut self, value: bool) -> Self {
                self.include_bills_without_pdf_ = Some(value);
                self
            }
            
            pub fn with_include_open_statements(mut self, value: bool) -> Self {
                self.include_open_statements_ = Some(value);
                self
            }
            
            pub fn with_include_held_statements(mut self, value: bool) -> Self {
                self.include_held_statements_ = Some(value);
                self
            }
            
            pub fn with_include_historic_statements(mut self, value: bool) -> Self {
                self.include_historic_statements_ = Some(value);
                self
            }
            
            pub fn with_only_current_email(mut self, value: bool) -> Self {
                self.only_current_email_ = Some(value);
                self
            }
            
            pub fn with_from_date(mut self, value: Date) -> Self {
                self.from_date_ = Some(value);
                self
            }
            
            pub fn with_to_date(mut self, value: Date) -> Self {
                self.to_date_ = Some(value);
                self
            }
            
            pub fn with_issued_from_date(mut self, value: Date) -> Self {
                self.issued_from_date_ = Some(value);
                self
            }
            
            pub fn with_issued_to_date(mut self, value: Date) -> Self {
                self.issued_to_date_ = Some(value);
                self
            }
            
            pub fn with_offset(mut self, value: i32) -> Self {
                self.offset_ = Some(value);
                self
            }
            
            pub fn with_before(mut self, value: String) -> Self {
                self.before_ = Some(value);
                self
            }
            
            pub fn with_after(mut self, value: String) -> Self {
                self.after_ = Some(value);
                self
            }
            
            pub fn with_first(mut self, value: i32) -> Self {
                self.first_ = Some(value);
                self
            }
            
            pub fn with_last(mut self, value: i32) -> Self {
                self.last_ = Some(value);
                self
            }
            
            pub fn with_transactions_before(mut self, value: String) -> Self {
                self.transactions_before_ = Some(value);
                self
            }
            
            pub fn with_transactions_after(mut self, value: String) -> Self {
                self.transactions_after_ = Some(value);
                self
            }
            
            pub fn with_transactions_first(mut self, value: i32) -> Self {
                self.transactions_first_ = Some(value);
                self
            }
            
            pub fn with_transactions_last(mut self, value: i32) -> Self {
                self.transactions_last_ = Some(value);
                self
            }
            
            pub fn build(self) -> Result<Query, sparko_graphql::error::Error> {
                if let None = self.account_number_ {
                    return Err(sparko_graphql::error::Error::MissingRequiredValueError("accountNumber"))
                }
                Ok(Query::from(Variables {
                    account_number_: self.account_number_.unwrap(),
                    include_bills_without_pdf_: self.include_bills_without_pdf_,
                    include_open_statements_: self.include_open_statements_,
                    include_held_statements_: self.include_held_statements_,
                    include_historic_statements_: self.include_historic_statements_,
                    only_current_email_: self.only_current_email_,
                    from_date_: self.from_date_,
                    to_date_: self.to_date_,
                    issued_from_date_: self.issued_from_date_,
                    issued_to_date_: self.issued_to_date_,
                    offset_: self.offset_,
                    before_: self.before_,
                    after_: self.after_,
                    first_: self.first_,
                    last_: self.last_,
                    transactions_before_: self.transactions_before_,
                    transactions_after_: self.transactions_after_,
                    transactions_first_: self.transactions_first_,
                    transactions_last_: self.transactions_last_,
                    }))
            }
        }
        
        impl GraphQLQuery<Response> for Query {
            fn get_request_name() -> &'static str {
                Self::REQUEST_NAME
            }
            fn get_query(&self) -> String {
                let mut buf = String::from("query getBillsAndTransactions");
                buf.push('(');
                self.variables.get_formal_params(&mut buf);
                buf.push(')');
                buf.push('{');
                    buf.push_str("account\n");
                    buf.push('(');
                        buf.push_str("accountNumber: $accountNumber,\n");
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("bills\n");
                        buf.push('(');
                            if self.variables.include_bills_without_pdf_.is_some() {
                                buf.push_str("includeBillsWithoutPDF: $includeBillsWithoutPDF,\n");
                            }
                            if self.variables.include_open_statements_.is_some() {
                                buf.push_str("includeOpenStatements: $includeOpenStatements,\n");
                            }
                            if self.variables.include_held_statements_.is_some() {
                                buf.push_str("includeHeldStatements: $includeHeldStatements,\n");
                            }
                            if self.variables.include_historic_statements_.is_some() {
                                buf.push_str("includeHistoricStatements: $includeHistoricStatements,\n");
                            }
                            if self.variables.only_current_email_.is_some() {
                                buf.push_str("onlyCurrentEmail: $onlyCurrentEmail,\n");
                            }
                            if self.variables.from_date_.is_some() {
                                buf.push_str("fromDate: $fromDate,\n");
                            }
                            if self.variables.to_date_.is_some() {
                                buf.push_str("toDate: $toDate,\n");
                            }
                            if self.variables.issued_from_date_.is_some() {
                                buf.push_str("issuedFromDate: $issuedFromDate,\n");
                            }
                            if self.variables.issued_to_date_.is_some() {
                                buf.push_str("issuedToDate: $issuedToDate,\n");
                            }
                            if self.variables.offset_.is_some() {
                                buf.push_str("offset: $offset,\n");
                            }
                            if self.variables.before_.is_some() {
                                buf.push_str("before: $before,\n");
                            }
                            if self.variables.after_.is_some() {
                                buf.push_str("after: $after,\n");
                            }
                            if self.variables.first_.is_some() {
                                buf.push_str("first: $first,\n");
                            }
                            if self.variables.last_.is_some() {
                                buf.push_str("last: $last,\n");
                            }
                        buf.push(')');
                        buf.push('{');
                            buf.push_str("pageInfo\n");
                            buf.push('{');
                                buf.push_str("endCursor\n");
                                buf.push_str("hasNextPage\n");
                            buf.push('}');
                            buf.push_str("edges\n");
                            buf.push('{');
                                buf.push_str("cursor\n");
                                buf.push_str("node\n");
                                buf.push('{');
                                    buf.push_str("id\n");
                                    buf.push_str("billType\n");
                                    buf.push_str("fromDate\n");
                                    buf.push_str("toDate\n");
                                    buf.push_str("issuedDate\n");
                                    buf.push_str("...Statement\n");
                                    buf.push_str("...StatementTransactions\n");
                                    buf.push_str("...PeriodBasedDocument\n");
                                    buf.push_str("...Invoice\n");
                                    buf.push_str("__typename\n");
                                buf.push('}');
                            buf.push('}');
                        buf.push('}');
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment Statement on StatementType\n");
                buf.push('{');
                    buf.push_str("closingBalance\n");
                    buf.push_str("openingBalance\n");
                    buf.push_str("isExternalBill\n");
                    buf.push_str("userId\n");
                    buf.push_str("toAddress\n");
                    buf.push_str("paymentDueDate\n");
                    buf.push_str("reversalsAfterClose\n");
                    buf.push_str("status\n");
                    buf.push_str("heldStatus\n");
                    buf.push('{');
                        buf.push_str("isHeld\n");
                        buf.push_str("reason\n");
                    buf.push('}');
                    buf.push_str("totalCharges\n");
                    buf.push('{');
                        buf.push_str("netTotal\n");
                        buf.push_str("taxTotal\n");
                        buf.push_str("grossTotal\n");
                    buf.push('}');
                    buf.push_str("totalCredits\n");
                    buf.push('{');
                        buf.push_str("netTotal\n");
                        buf.push_str("taxTotal\n");
                        buf.push_str("grossTotal\n");
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment StatementTransactions on StatementType\n");
                buf.push('{');
                    buf.push_str("transactions\n");
                    buf.push('(');
                        if self.variables.transactions_before_.is_some() {
                            buf.push_str("before: $transactions_before,\n");
                        }
                        if self.variables.transactions_after_.is_some() {
                            buf.push_str("after: $transactions_after,\n");
                        }
                        if self.variables.transactions_first_.is_some() {
                            buf.push_str("first: $transactions_first,\n");
                        }
                        if self.variables.transactions_last_.is_some() {
                            buf.push_str("last: $transactions_last,\n");
                        }
                    buf.push(')');
                    buf.push('{');
                        buf.push_str("pageInfo\n");
                        buf.push('{');
                            buf.push_str("startCursor\n");
                            buf.push_str("hasPreviousPage\n");
                        buf.push('}');
                        buf.push_str("edges\n");
                        buf.push('{');
                            buf.push_str("cursor\n");
                            buf.push_str("node\n");
                            buf.push('{');
                                buf.push_str("id\n");
                                buf.push_str("postedDate\n");
                                buf.push_str("createdAt\n");
                                buf.push_str("accountNumber\n");
                                buf.push_str("amounts\n");
                                buf.push('{');
                                    buf.push_str("net\n");
                                    buf.push_str("tax\n");
                                    buf.push_str("gross\n");
                                buf.push('}');
                                buf.push_str("balanceCarriedForward\n");
                                buf.push_str("isHeld\n");
                                buf.push_str("isIssued\n");
                                buf.push_str("title\n");
                                buf.push_str("billingDocumentIdentifier\n");
                                buf.push_str("isReversed\n");
                                buf.push_str("hasStatement\n");
                                buf.push_str("note\n");
                                buf.push_str("...Charge\n");
                                buf.push_str("__typename\n");
                            buf.push('}');
                        buf.push('}');
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment PeriodBasedDocument on PeriodBasedDocumentType\n");
                buf.push('{');
                    buf.push_str("identifier\n");
                    buf.push_str("totalCharges\n");
                    buf.push('{');
                        buf.push_str("netTotal\n");
                        buf.push_str("taxTotal\n");
                        buf.push_str("grossTotal\n");
                    buf.push('}');
                    buf.push_str("totalCredits\n");
                    buf.push('{');
                        buf.push_str("netTotal\n");
                        buf.push_str("taxTotal\n");
                        buf.push_str("grossTotal\n");
                    buf.push('}');
                buf.push('}');
                
                buf.push_str("fragment Invoice on InvoiceType\n");
                buf.push('{');
                    buf.push_str("grossAmount\n");
                buf.push('}');
                
                buf.push_str("fragment Charge on Charge\n");
                buf.push('{');
                    buf.push_str("consumption\n");
                    buf.push('{');
                        buf.push_str("startDate\n");
                        buf.push_str("endDate\n");
                        buf.push_str("quantity\n");
                        buf.push_str("unit\n");
                        buf.push_str("usageCost\n");
                        buf.push_str("supplyCharge\n");
                    buf.push('}');
                    buf.push_str("isExport\n");
                buf.push('}');
                buf
            }
            
            fn get_variables(&self) -> Result<std::string::String, serde_json::Error> {
                serde_json::to_string_pretty(&self.variables)
            }
        }
        
        impl GraphQLResponse for Response {
        }
    }
} // End of executable_document bill

} // End model graphql

